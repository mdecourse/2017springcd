<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>2017Spring 協同產品設計實習 (虎尾科大MDE)</title><link href="./" rel="alternate"></link><link href="./feeds/course.atom.xml" rel="self"></link><id>./</id><updated>2017-06-14T11:00:00+08:00</updated><entry><title>期末協同查驗與自評</title><link href="./final-collaboration-evaluation.html" rel="alternate"></link><published>2017-06-14T11:00:00+08:00</published><updated>2017-06-14T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-06-14:./final-collaboration-evaluation.html</id><summary type="html">&lt;p&gt;以下為協同產品設計實習 2017 Spring 期末考前一週起的實習查驗題目. 完成後, 請各組員依照指示完成期末自評簡報.&lt;/p&gt;


&lt;p&gt;以下各題請各組員在任務執行時, 利用 ShareX 拍攝操作影片, 影片名稱依題序設為"學號-2017springcd-final-1.mp4 ~ 學號-2017springcd-final-7.mp4", 並在指定時間內分別上傳到以學號建立帳號的 Youtube 與 Vimeo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;各組員倉儲中的 Github 檔案推送&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各組員網誌上的 2D 繪圖, 並將程式碼顯示在繪圖網誌文章中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各組員倉儲中的子模組建立與運用, 並將程式碼顯示在繪圖網誌文章中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各組員 Solvespace 近端零組件繪圖, 並在各組員網誌中顯示指定的零組件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各組員 Solvespace 零件轉入 V-rep, 並設定驅動零件進行動態模擬&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各組員說明在分組行走機構模擬與實作過程中所扮演的角色, 並利用影片檔說明所負責完成的任務&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各組以協同方式整合各組組員所完成的倉儲, 網誌與操作影片後, 以學號名稱當作子目錄, 其中放入各組員上述各題所完成的操作影片後, 上傳到各組在系上的 Fossil SCM 倉儲, 並設法用各組的 Github Pages 進行分組簡報.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="solvespace"></category><category term="v-rep"></category><category term="w17"></category></entry><entry><title>Fabric.js 範例</title><link href="./brython-fabric-canvas.html" rel="alternate"></link><published>2017-05-30T12:00:00+08:00</published><updated>2017-05-30T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-05-30:./brython-fabric-canvas.html</id><summary type="html">&lt;p&gt;結合 Brython 與 Fabric.js 繪圖.&lt;/p&gt;


&lt;p&gt;&lt;a href="http://fabricjs.com/fabric-intro-part-1"&gt;http://fabricjs.com/fabric-intro-part-1&lt;/a&gt;&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;script src="./../data/Fabric-1.7.11/fabric.min.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="c" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;p&gt;&lt;input id="part1" value="./../data/eight_bar_solvespace_vrep_1.png"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="button"&gt;Get Part&lt;/button&gt;&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import window, document
from browser.timer import set_interval
# 透過 window 將 Javascript 的 fabric 函式轉為 brython fab 物件
fab = window.fabric
# 特別注意要使用 new 方法建立新 Canvas 物件
canvas = fab.Canvas.new("c")

# 以下各 fabric 物件都採用 new 方法轉換為 brython 物件
rect = fab.Rect.new({
  'left': 100,
  'top': 100,
  'fill': 'red',
  'width': 80,
  'height': 80,
  'angle': 45
})

line1 = fab.Line.new([0, 0, 0, 100], {
'left': 20,
'top': 20,
'stroke': 'red'
})

line2 = fab.Line.new([0, 0, 100, 0], {
'left': 20,
'top': 20,
'stroke': 'blue'
})

circle = fab.Circle.new({
  'radius': 20, 'fill': 'green', 'left': 100, 'top': 100
})
triangle = fab.Triangle.new({
  'width': 20, 'height': 30, 'fill': 'blue', 'left': 50, 'top': 50
})
text = fab.Text.new("使用 fabric.js 畫出中文", {
  'fontFamily': 'Comic Sans'
})

def showImg(img):
    canvas.backgroundImage = img
    canvas.backgroundImage.width = 200
    canvas.backgroundImage.height = 200
    img.set({ 'left': 150, 'top': 170 })
    canvas.add(img)

def seturl(e):
    if document["part1"].value:
        fab.Image.fromURL(document["part1"].value, showImg)
    else:
        fab.Image.fromURL('./../data/eight_bar_solvespace_vrep_1.png', showImg)

canvas.add(rect, circle, triangle, text, line1, line2)
text.set({ 'left': 100, 'top': 50 })
text.set({'angle': 15})
# 利用各物件的 set 方法, 可以固定物件位置
rect.set({ 'left': 20, 'top': 50 })

rect.set('fill', 'red')
rect.set({ 'strokeWidth': 5, 'stroke': 'rgba(100,200,200,0.5)' })
# 特別注意 brython 中必須使用 True 而非 Javascript 的 true
rect.set('angle', 60).set('flipY', True)
def test(e):
    print("circle selected")
circle.on('selected', test)

#canvas.renderAll()
rect.animate('left', 500, {
  'onChange': canvas.renderAll.bind(canvas),
  'duration': 1000,
  'easing': fab.util.ease.easeOutBounce
})

def draw():
    # 旋轉 text, 為 add 物件序號 3
    curAngle = canvas.item(3).getAngle()
    canvas.item(3).setAngle(curAngle+36)

#set_interval(draw, 100)
document['button'].bind('click',seturl)
&lt;/script&gt;

&lt;p&gt;&lt;a href="http://fabricjs.com/fabric-intro-part-2"&gt;http://fabricjs.com/fabric-intro-part-2&lt;/a&gt;&lt;/p&gt;</summary><category term="Brython"></category><category term="fabric"></category></entry><entry><title>網際正齒輪組傳動繪圖</title><link href="./brython-spur-gears.html" rel="alternate"></link><published>2017-05-11T12:00:00+08:00</published><updated>2017-05-11T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-05-11:./brython-spur-gears.html</id><summary type="html">&lt;p&gt;利用 &lt;a href="https://github.com/brython-dev/brython/releases/tag/3.3.1"&gt;Brython 3.3.1&lt;/a&gt; 執行 3 個正齒輪傳動繪圖.&lt;/p&gt;


&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;p&gt;&lt;input id="n1" value="13"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="n2" value="11"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;input id="n3" value="17"&gt;&lt;/input&gt;&lt;br /&gt;
&lt;button id="button"&gt;Set Number of Gears&lt;/button&gt;&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)

canvas = doc['onegear']
ctx = canvas.getContext("2d")

# 以 button 驅動的事件函式
def setgearnumber(e):
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    x = (canvas.width)/2
    y = (canvas.height)/2
    if doc["n1"].value.isdigit():
        n17 = int(doc["n1"].value)
    else:
        n17 = 17

    if doc["n2"].value.isdigit():
        n11 = int(doc["n2"].value)
    else:
        n11 = 11

    if doc["n3"].value.isdigit():
        n13 = int(doc["n3"].value)
    else:
        n13 = 13

    # 只使用畫布高度的 80%
    canvas_size = canvas.height*0.4
    r17 = canvas_size*n17/(n17+n11+n13)
    r11 = canvas_size*n11/(n17+n11+n13)
    r13 = canvas_size*n13/(n17+n11+n13)
    # 計算各齒輪中心座標
    x17 = x - r17-r11
    y17 = y

    x11 = x 
    y11 = y

    x13 = x + r11+r13
    y13 = y

    pa = 20
    # 開始繪製齒輪
    # 儲存原有的座標系統
    ctx.save()
    # 平移到齒輪圓心
    ctx.translate(x17, y17)
    # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平
    ctx.rotate(90*deg)
    # 平移回原來的座標原點
    ctx.translate(-x17, -y17)
    gear17 = Spur(ctx).Gear(x17, y17, r17, n17, pa, "blue")
    # 回復原有的座標系統
    ctx.restore()

    ctx.save()
    ctx.translate(x11, y11)
    # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n11)
    ctx.translate(-x11, -y11)
    gear11 = Spur(ctx).Gear(x11, y11, r11, n11, pa, "blue")
    ctx.restore()

    ctx.save()
    ctx.translate(x13, y13)
    # 右側齒輪轉動 -90 度加上一齒, 可以與原來標線在左側水平的中間齒輪囓合, 但是目前中間齒輪的標線已經轉了 180 度加或減一次
    # 必須配合兩齒的速比轉換旋轉角, 以便讓中間齒輪與右側齒輪囓合
    ctx.rotate(-90*deg-math.pi/n13+(180*deg+math.pi/n11)*n11/n13)
    ctx.translate(-x13, -y13)
    gear13 = Spur(ctx).Gear(x13, y13, r13, n13, pa, "blue")
    ctx.restore()

setgearnumber(True)

'''
div = doc["onegear_div"]
form = html.FORM()
input1 = html.INPUT(type="text", id="n1", name="n1", value="13")
input2 = html.INPUT(type="text", id="n2", name="n2", value="11")
input3 = html.INPUT(type="text", id="n3", name="n3", value="19")
div &lt;= input1 + html.BR() + input2 + html.BR() + input3
'''
doc['button'].bind('click',setgearnumber)
&lt;/script&gt;

&lt;p&gt;請各組以協同方式利用 2D 與 3D 繪圖設計方法, 完成行走機構所需齒輪減速組合之分析、模擬與製作.&lt;/p&gt;
&lt;p&gt;&lt;a href="./../GearSketch/index.html"&gt;GearSketch&lt;/a&gt; (source: &lt;a href="http://modeldrawing.eu/our-software/gearsketch/"&gt;http://modeldrawing.eu/our-software/gearsketch/&lt;/a&gt; &amp;amp; &lt;a href="https://github.com/frankleenaars/gearsketch"&gt;https://github.com/frankleenaars/gearsketch&lt;/a&gt;)&lt;/p&gt;</summary><category term="Brython"></category><category term="spur"></category><category term="gear"></category></entry><entry><title>網際平面四連桿運動模擬</title><link href="./brython-2d-canvas-fourbar.html" rel="alternate"></link><published>2017-05-07T13:00:00+08:00</published><updated>2017-05-07T13:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-05-07:./brython-2d-canvas-fourbar.html</id><summary type="html">&lt;p&gt;利用 &lt;a href="https://github.com/brython-dev/brython/releases/tag/3.3.1"&gt;Brython 3.3.1&lt;/a&gt; 執行四連桿運動模擬.&lt;/p&gt;


&lt;p&gt;直接在網頁中編寫 Brython 模擬程式:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="600" height="450"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document
import math
import time
from browser import timer

class Coord(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def __sub__(self,other):
        # This allows you to substract vectors
        return Coord(self.x-other.x,self.y-other.y)

    def __repr__(self):
        # Used to get human readable coordinates when printing
        return "Coord(%f,%f)"%(self.x,self.y)

    def length(self):
        # Returns the length of the vector
        return math.sqrt(self.x**2 + self.y**2)

    def angle(self):
        # Returns the vector's angle
        return math.atan2(self.y,self.x)

def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )

def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )

# 點類別
class Point(object):
    # 起始方法
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # 繪製方法
    def drawMe(self, g, r):
        self.g = g
        self.r = r
        self.g.save()
        self.g.moveTo(self.x,self.y)
        self.g.beginPath()
        # 根據 r 半徑繪製一個圓代表點的所在位置
        self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True)
        self.g.moveTo(self.x,self.y)
        self.g.lineTo(self.x+self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x-self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y+self.r)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y-self.r)
        self.g.restore()
        self.g.stroke()

    # 加入 Eq 方法
    def Eq(self, pt):
        self.x = pt.x
        self.y = pt.y

    # 加入 setPoint 方法
    def setPoint(self, px, py):
        self.x = px
        self.y = py

    # 加上 distance(pt) 方法, 計算點到 pt 的距離
    def distance(self, pt):
        self.pt = pt
        x = self.x - self.pt.x
        y = self.y - self.pt.y
        return math.sqrt(x * x + y * y)

    # 利用文字標示點的座標位置
    def tag(self, g):
        self.g = g
        self.g.beginPath()
        self.g.fillText("%d, %d"%(self.x, self.y),self.x, self.y)
        self.g.stroke()


# Line 類別物件
class Line(object):

    # 起始方法
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        # 直線的第一點, 設為線尾
        self.Tail = self.p1
        # 直線組成的第二點, 設為線頭
        self.Head = self.p2
        # 直線的長度屬性
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setPP 以指定頭尾座標點來定義直線
    def setPP(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.Tail = self.p1
        self.Head = self.p2
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
    def setRT(self, r, t):
        self.r = r
        self.t = t
        x = self.r * math.cos(self.t)
        y = self.r * math.sin(self.t)
        self.Tail.Eq(self.p1)
        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)

    # getR 方法 for Line
    def getR(self):
        # x 分量與 y 分量
        x = self.p1.x - self.p2.x
        y = self.p1.y - self.p2.y
        return math.sqrt(x * x + y * y)

    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
    def getT(self):
        x = self.p2.x - self.p1.x
        y = self.p2.y - self.p1.y
        if (math.fabs(x) &lt; math.pow(10,-100)):
            if(y &lt; 0.0):
                return (-math.pi/2)
            else:
                return (math.pi/2)
        else:
            return math.atan2(y, x)

    # setTail 方法 for Line
    def setTail(self, pt):
        self.pt = pt
        self.Tail.Eq(pt)
        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)

    # getHead 方法 for Line
    def getHead(self):
        return self.Head

    def getTail(self):
        return self.Tail

    def drawMe(self, g):
        self.g = g
        self.g.beginPath()
        self.g.moveTo(self.p1.x,self.p1.y)
        self.g.lineTo(self.p2.x,self.p2.y)
        self.g.stroke()

    def test(self):
        return ("this is pure test to Inherit")


class Link(Line):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))

    #g context
    def drawMe(self, g):
        self.g = g
        hole = 5
        radius = 10
        length = self.getR()
        # alert(length)
        # 儲存先前的繪圖狀態
        self.g.save()
        self.g.translate(self.p1.x,self.p1.y)
        #alert(str(self.p1.x)+","+str(self.p1.y))
        #self.g.rotate(-((math.pi/2)-self.getT()))
        self.g.rotate(-math.pi*0.5 + self.getT())
        #alert(str(self.getT()))
        #self.g.rotate(10*math.pi/180)
        #this.g.rotate(-(Math.PI/2-this.getT()));
        # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
        self.g.beginPath()
        self.g.moveTo(0,0)
        self.g.arc(0, 0, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,length)
        self.g.beginPath()
        self.g.arc(0,length, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,0)
        self.g.beginPath()
        self.g.arc(0,0, radius, 0, math.pi, True)
        self.g.moveTo(0+radius,0)
        self.g.lineTo(0+radius,0+length)
        self.g.stroke()
        self.g.moveTo(0,0+length)
        self.g.beginPath()
        self.g.arc(0, 0+length, radius, math.pi, 0, True)
        self.g.moveTo(0-radius,0+length)
        self.g.lineTo(0-radius,0)
        self.g.stroke()
        self.g.restore()
        '''
        self.g.beginPath()
        self.g.fillStyle = "red"
        self.g.font = "bold 18px sans-serif"
        self.g.fillText("%d, %d"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y)
        self.g.stroke()
        '''


class Triangle(object):
    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3

    def getLenp3(self):
        p1 = self.p1
        ret = p1.distance(self.p2)
        return ret

    def getLenp1(self):
        p2 = self.p2
        ret = p2.distance(self.p3)
        return ret

    def getLenp2(self):
        p1 = self.p1
        ret = p1.distance(self.p3)
        return ret

    # 角度
    def getAp1(self):
        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
        return ret

    #
    def getAp2(self):
        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
        return ret

    def getAp3(self):
        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
        return ret

    def drawMe(self, g):
        self.g = g
        r = 5
        # 繪出三個頂點
        self.p1.drawMe(self.g,r)
        self.p2.drawMe(self.g,r)
        self.p3.drawMe(self.g,r)
        line1 = Line(self.p1,self.p2)
        line2 = Line(self.p1,self.p3)
        line3 = Line(self.p2,self.p3)
        # 繪出三邊線
        line1.drawMe(self.g)
        line2.drawMe(self.g)
        line3.drawMe(self.g)

    # ends Triangle def
    # 透過三個邊長定義三角形
    def setSSS(self, lenp3, lenp1, lenp2):
        self.lenp3 = lenmidpt = Point(0, 0)
        self.lenp1 = lenp1
        self.lenp2 = lenp2
        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))

    # 透過兩個邊長與夾角定義三角形
    def setSAS(self, lenp3, ap2, lenp1):
        self.lenp3 = lenp3
        self.ap2 = ap2
        self.lenp1 = lenp1
        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
        #等於 SSS(AB, BC, CA)

    def setSaSS(self, lenp2, lenp3, lenp1):
        self.lenp2 = lenp2
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        if(self.lenp1 &gt; (self.lenp2 + self.lenp3)):
        #&lt;CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
            ret = math.pi
        else :
            # &lt;CAB 夾角為 0, 三點共線且 A 不在 BC 之間
            if((self.lenp1 &lt; (self.lenp2 - self.lenp3)) or (self.lenp1 &lt; (self.lenp3 - self.lenp2))):
                ret = 0.0
            else :
            # 透過餘絃定理求出夾角 &lt;CAB 
                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
        return ret

    # 取得三角形的三個邊長值
    def getSSS(self):
        temp = []
        temp.append( self.getLenp1() )
        temp.append( self.getLenp2() )
        temp.append( self.getLenp3() )
        return temp

    # 取得三角形的三個角度值
    def getAAA(self):
        temp = []
        temp.append( self.getAp1() )
        temp.append( self.getAp2() )
        temp.append( self.getAp3() )
        return temp

    # 取得三角形的三個角度與三個邊長
    def getASASAS(self):
        temp = []
        temp.append(self.getAp1())
        temp.append(self.getLenp1())
        temp.append(self.getAp2())
        temp.append(self.getLenp2())
        temp.append(self.getAp3())
        temp.append(self.getLenp3())
        return temp
    #2P 2L return mid P
    def setPPSS(self, p1, p3, lenp1, lenp3):
        temp = []
        self.p1 = p1
        self.p3 = p3
        self.lenp1 = lenp1
        self.lenp3 = lenp3

        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
        line31 = Line(p3, p1)
        self.lenp2 = line31.getR()
        #self.lenp2 = self.p3.distance(self.p1)
        #這裡是求角3
        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))
        bp3 = line31.getT()
        cp3 = bp3 - ap3
        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
        return temp

def tag(g, p):
    None

midpt = Point(0, 0)
tippt = Point(0, 0)
contour = []
# 執行繪圖流程, 注意 x, y 為 global variables
def draw():
    global theta, midpt, oldpt
    context.clearRect(0, 0, canvas.width, canvas.height)
    line1.drawMe(context)
    line2.drawMe(context)
    line3.drawMe(context)
    #triangle1.drawMe(context)
    #triangle2.drawMe(context)
    theta += dx
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)
    # 計算垂直單位向量
    a = Coord(p3.x, p3.y)
    b = Coord(p2.x, p2.y)
    normal = perpendicular(normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    if theta &lt; 360:
        contour.append((tippt.x, tippt.y))
    context.beginPath()
    context.moveTo(midpt.x, midpt.y)
    context.lineTo(tippt.x, tippt.y)
    # 利用 fillRect 繪製一個長寬各 1 單位的正方形
    for i in range(len(contour)):
        context.fillRect(contour[i][0], contour[i][1], 1, 1)
    context.stroke()
    #p1.tag(context)


# 以上為相關函式物件的定義區
# 全域變數
# 幾何位置輸入變數
x=10
y=10
r=10

# 畫布與繪圖內容
# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4

#set p1.p2.p3.p4 position
lift = 10
p1 =  Point(150,100+lift)
p2 =  Point(150,200+lift)
p3 =  Point(300,300+lift)
p4 =  Point(350,100+lift)

#accord position create link
line1 =  Link(p1,p2)
line2 =  Link(p2,p3)
line3 =  Link(p3,p4)
line4 =  Link(p1,p4)
line5 =  Link(p2,p4)

link2_len = p2.distance(p3)
link3_len = p3.distance(p4)

#link2_len = line1.getR()
#link3_len = line3.getR()
#alert(str(link2_len)+','+str(link3_len))

triangle1 =  Triangle(p1,p2,p4)
triangle2 =  Triangle(p2,p3,p4)

# 視窗載入時執行內容
# 繪圖畫布設定

canvas = document["plotarea"]
context = canvas.getContext("2d")

# 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角
context.translate(0,canvas.height)
context.scale(1,-1)

#以間隔 20 micro seconds 重複呼叫 draw()
timer.set_interval(draw,20)
#timer.set_interval(draw,10)
&lt;/script&gt;

&lt;p&gt;將四連桿模擬程式庫存在 ./../data/py 子目錄, 然後以 import 導入方式執行運算:&lt;/p&gt;
&lt;canvas id="plotarea2" width="600" height="450"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
# import point-line-triangle module
import plt
import math
from browser import document
from browser import timer

midpt = plt.Point(0, 0)
tippt = plt.Point(0, 0)
contour = []
# 執行繪圖流程, 注意 x, y 為 global variables
def draw():
    global theta, midpt, oldpt
    context.clearRect(0, 0, canvas.width, canvas.height)
    line1.drawMe(context)
    line2.drawMe(context)
    line3.drawMe(context)
    line4.drawMe(context)
    #triangle1.drawMe(context)
    #triangle2.drawMe(context)
    theta += dx
    #PLAP
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    #PLLP
    p3.x, p3.y = triangle2.setPPSS(p2,p4,line2.length,line3.length)
    # 計算垂直單位向量
    a = plt.Coord(p3.x, p3.y)
    b = plt.Coord(p2.x, p2.y)
    normal = plt.perpendicular(plt.normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    if theta &lt; 360:
        contour.append((tippt.x, tippt.y))
    context.beginPath()
    context.moveTo(midpt.x, midpt.y)
    context.lineTo(tippt.x, tippt.y)
    # 利用 fillRect 繪製一個長寬各 1 單位的正方形
    for i in range(len(contour)):
        context.fillRect(contour[i][0], contour[i][1], 1, 1)
    context.stroke()
    #p1.tag(context)


# 以上為相關函式物件的定義區
# 全域變數
# 幾何位置輸入變數
x=10
y=10
r=10

# 畫布與繪圖內容
# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4

#set p1.p2.p3.p4 position
lift = 10
# 各起始座標點必須精確
p1 =  plt.Point(150,100+lift)
p2 =  plt.Point(150,200+lift)
p3 =  plt.Point(300,300+lift)
p4 =  plt.Point(350,100+lift)
#共有五條線
line1 =  plt.Link(p1,p2)
line2 =  plt.Link(p2,p3)
line3 =  plt.Link(p3,p4)
line4 =  plt.Link(p1,p4)
line5 =  plt.Link(p2,p4)

#link2_len = p2.distance(p3)
#link3_len = p3.distance(p4)

#link2_len = line1.getR()
#link3_len = line3.getR()
#alert(str(link2_len)+','+str(link3_len))

triangle1 =  plt.Triangle(p1,p2,p4)
triangle2 =  plt.Triangle(p2,p3,p4)

# 視窗載入時執行內容
# 繪圖畫布設定

canvas = document["plotarea2"]
context = canvas.getContext("2d")

# 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角
context.translate(0,canvas.height)
context.scale(1,-1)

#以間隔 20 micro seconds 重複呼叫 draw()
timer.set_interval(draw,20)
&lt;/script&gt;</summary><category term="Brython"></category><category term="fourbar"></category></entry><entry><title>網際 SVG 繪圖</title><link href="./brython-2d-svg-canvas.html" rel="alternate"></link><published>2017-05-04T13:00:00+08:00</published><updated>2017-05-04T13:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-05-04:./brython-2d-svg-canvas.html</id><summary type="html">&lt;p&gt;結合 &lt;a href="https://github.com/brython-dev/brython/releases/tag/3.3.1"&gt;Brython 3.3.1&lt;/a&gt; 與 &lt;a href="./../data/w11/cango/Cango-9v05.js"&gt;Cango-9v05.js&lt;/a&gt; 繪圖, 將 &lt;a href="http://www.arc.id.au/CanvasGraphics.html"&gt;Cango Canvas 繪圖範例&lt;/a&gt;轉為 Brython.&lt;/p&gt;


&lt;h3&gt;&lt;a href="http://www.arc.id.au"&gt;Cango 程式庫&lt;/a&gt;&lt;/h3&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="cango_canvas" width="800" height="60"&gt;&lt;/canvas&gt;

&lt;div id="cango_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import window
import math
# 利用 window 擷取 Cango 物件, 然後以 new 方法轉為 Brython 物件
cango = window.Cango.new
# 利用 browser 中的 document 擷取 id = "cango_div" 的標註
cango_div = doc["cango_div"]
def sayHullo(cvsID):
    # create a graphics context
    cgo = cango(cvsID) 
    # use RH Cartesian on full canvas
    cgo.setGridboxRHC() 
    # Different X and Y scale
    cgo.setWorldCoords(-10, -5, 20, 10)
    cgo.drawText("以 Cango 顯示中文", {
        'fillColor': "blue",
        'fontSize': 58,
        'lorg':5 })
sayHullo("cango_canvas")
cango_div &lt;= "以 Brython 顯示中文"
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
上述 Cango 與 Brython 文字列印程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;
&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="cango_canvas" width="800" height="60"&gt;&lt;/canvas&gt;
&lt;div id="cango_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import window
import math
# 利用 window 擷取 Cango 物件, 然後以 new 方法轉為 Brython 物件
cango = window.Cango.new
# 利用 browser 中的 document 擷取 id = "cango_div" 的標註
cango_div = doc["cango_div"]
def sayHullo(cvsID):
    # create a graphics context
    cgo = cango(cvsID) 
    # use RH Cartesian on full canvas
    cgo.setGridboxRHC() 
    # Different X and Y scale
    cgo.setWorldCoords(-10, -5, 20, 10)
    cgo.drawText("以 Cango 顯示中文", {
        'fillColor': "blue",
        'fontSize': 58,
        'lorg':5 })
sayHullo("cango_canvas")
cango_div &lt;= "以 Brython 顯示中文"
&lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;Cango drawPath 範例:&lt;/p&gt;
&lt;canvas id="cango_canvas1" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import window
import math
# 利用 window 擷取 Cango 物件, 然後以 new 方法轉為 Brython 物件
cango = window.Cango.new

def plotSine(cvsID):
    data = []
    g = cango(cvsID)
    g.setGridboxRHC(10, 10, 80, 60)
    g.setWorldCoords(0, -50, 2*math.pi, 100)
    g.drawAxes(0, 6.5, -50, 50, {
    'xOrigin':0, 'yOrigin':0,
    'fontSize':10,
    'strokeColor':'gray'})
    for i in range(int(2*math.pi/0.03)):
        #[0, 0.03, 0.06 ... 3.14159]
        i = i * 0.03
        # 特別注意在 Javascript 採用 data.push(i, 50*math.sin(i)), 但是 Python 必須分為兩段 append
        data.append(i)
        data.append(50*math.sin(i))
    g.drawPath(data, {'strokeColor':'red'})
plotSine("cango_canvas1")
&lt;/script&gt;

&lt;p&gt;以上繪圖程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;canvas id="cango_canvas1" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import window
import math
# 利用 window 擷取 Cango 物件, 然後以 new 方法轉為 Brython 物件
cango = window.Cango.new

def plotSine(cvsID):
    data = []
    g = cango(cvsID)
    g.setGridboxRHC(10, 10, 80, 60)
    g.setWorldCoords(0, -50, 2*math.pi, 100)
    g.drawAxes(0, 6.5, -50, 50, {
    'xOrigin':0, 'yOrigin':0,
    'fontSize':10,
    'strokeColor':'gray'})
    for i in range(int(2*math.pi/0.03)):
        #[0, 0.03, 0.06 ... 3.14159]
        i = i * 0.03
        # 特別注意在 Javascript 採用 data.push(i, 50*math.sin(i)), 但是 Python 必須分為兩段 append
        data.append(i)
        data.append(50*math.sin(i))
    g.drawPath(data, {'strokeColor':'red'})
plotSine("cango_canvas1")
&lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;重用 Cango 繪圖物件:&lt;/p&gt;
&lt;canvas id="cango_canvas2" width="800" height="800"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import window
import math
# 利用 window 擷取 Cango 物件, 然後以 new 方法轉為 Brython 物件
cango = window.Cango.new
shape = window.Shape.new
shapedefs = window.shapeDefs

def drawSpiral(cvsID):
    g = cango(cvsID)
    chamber = ['M',289.16,447.14,
                 'C',233.33,399.03, 267.47,290.34, 364.53,265.28,
                     408.88,269.91, 448.14,282.58, 483.22,303.79,
                     391.79,287.12, 292.99,369.50, 331.90,451.11,
                     318.79,447.43, 302.35,446.61, 289.16,447.14, 'z']
    cobj = shape(chamber, {
        'fillColor':"lightyellow",
        'strokeColor':"tan",
        'lineWidthWC':4,
        'border':True })
    cobj.translate(-287, -536)
    g.setGridboxSVG()
    g.setWorldCoords(-250, -320, 500)
    # draw the spiral center dot
    g.drawShape(shapedefs.circle(8), {'fillColor':"tan"})
    # draw the 50 spiral segments
    scale = 1
    for i in range(50):
        scale = scale/1.08
        g.render(cobj, {'scl':scale, 'degs':i*24.5})

drawSpiral("cango_canvas2")
&lt;/script&gt;

&lt;p&gt;上述繪圖程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;canvas id="cango_canvas2" width="800" height="800"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import window
import math
# 利用 window 擷取 Cango 物件, 然後以 new 方法轉為 Brython 物件
cango = window.Cango.new
shape = window.Shape.new
shapedefs = window.shapeDefs

def drawSpiral(cvsID):
    g = cango(cvsID)
    chamber = ['M',289.16,447.14,
                 'C',233.33,399.03, 267.47,290.34, 364.53,265.28,
                     408.88,269.91, 448.14,282.58, 483.22,303.79,
                     391.79,287.12, 292.99,369.50, 331.90,451.11,
                     318.79,447.43, 302.35,446.61, 289.16,447.14, 'z']
    cobj = shape(chamber, {
        'fillColor':"lightyellow",
        'strokeColor':"tan",
        'lineWidthWC':4,
        'border':True })
    cobj.translate(-287, -536)
    g.setGridboxSVG()
    g.setWorldCoords(-250, -320, 500)
    # draw the spiral center dot
    g.drawShape(shapedefs.circle(8), {'fillColor':"tan"})
    # draw the 50 spiral segments
    scale = 1
    for i in range(50):
        scale = scale/1.08
        g.render(cobj, {'scl':scale, 'degs':i*24.5})

drawSpiral("cango_canvas2")
&lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;目前正透過 &lt;a href="https://github.com/mdecourse/kmol2018"&gt;https://github.com/mdecourse/kmol2018&lt;/a&gt; 測試 Windows 64 位元可攜 Python3.6.1 與 Brython 3.3.1 的應用, 已經發現 Pelican DISPLAY_PAGES_ON_MENU 無法運作, 且 Brython 3.3.1 在 Windows 環境中無法正確擷取字串值.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://snapsvg.io/"&gt;Snap 程式庫&lt;/a&gt;&lt;/h3&gt;
&lt;script type="text/javascript" src="./../data/w11/snap/snap.svg-min.js"&gt;&lt;/script&gt;

&lt;p&gt;&lt;svg id="svgout" width="800" height="500" viewBox="0 0 800 500"&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
from browser import alert
from browser import window, document
# 將 Snap 轉為 Brython 物件
snap = window.Snap.new
# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")

offsetY = 50

# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })

g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()

r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)

r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })

g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);

r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })

g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)

r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
&lt;/script&gt;

&lt;p&gt;上述 Snap 繪圖程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;script type="text/javascript" src="./../data/w11/snap/snap.svg-min.js"&gt;&lt;/script&gt;

&lt;svg id="svgout" width="800" height="500" viewBox="0 0 800 500"&gt;&lt;/svg&gt;

&lt;script type="text/python"&gt;
from browser import alert
from browser import window, document
# 將 Snap 轉為 Brython 物件
snap = window.Snap.new
# 使用 id 為 "svgout" 的 svg 標註進行繪圖
s = snap("#svgout")

offsetY = 50

# 是否標示出繪圖範圍
#borderRect = s.rect(0,0,800,640,10,10).attr({ 'stroke': "silver", 'fill': "silver", 'strokeWidth': "3" })

g = s.group().transform('t250,120')
r0 = s.rect(150,150,100,100,20,20).attr({ 'fill': "orange", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c0 = s.circle(225,225,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4"  }).attr({ 'id': 'c0' })
g0 = s.group( r0,c0 ).attr({ 'id': 'g0' })
#g0.animate({ 'transform' : 't250,120r360,225,225' },4000)
g0.appendTo( g )
g0.animate({ 'transform' : 'r360,225,225' },4000)
# 讓 g0 可以拖動
g0.drag()

r1 = s.rect(100,100,100,100,20,20).attr({ 'fill': "red", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c1 = s.circle(175,175,10).attr({ 'fill': "silver", 'stroke': "black" , 'strokeWidth': "4"}).attr({ 'id': 'c1' })
g1 = s.group( r1,c1 ).attr({ 'id': 'g1' })
g1.appendTo( g0 ).attr({ 'id': 'g1' })
g1.animate({ 'transform' : 'r360,175,175' },4000)

r2 = s.rect(50,50,100,100,20,20).attr({ 'fill': "blue", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c2 = s.circle(125,125,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c2' })
g2 = s.group(r2,c2).attr({ 'id': 'g2' })

g2.appendTo( g1 );
g2.animate( { 'transform' : 'r360,125,125' },4000);

r3 = s.rect(0,0,100,100,20,20).attr({ 'fill': "yellow", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c3 = s.circle(75,75,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c3' })
g3 = s.group(r3,c3).attr({ 'id': 'g3' })

g3.appendTo( g2 )
g3.animate( { 'transform' : 'r360,75,75' },4000)

r4 = s.rect(-50,-50,100,100,20,20).attr({ 'fill': "green", 'opacity': "0.8", 'stroke': "black", 'strokeWidth': "2" })
c4 = s.circle(25,25,10).attr({ 'fill': "silver", 'stroke': "black", 'strokeWidth': "4" }).attr({ 'id': 'c4' })
g4 = s.group(r4,c4).attr({ 'id': 'g4' });
g4.appendTo( g3 )
g4.animate( { 'transform' : 'r360,25,25' },4000)
&lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;svg id="svgout1" width="800" height="500" viewBox="0 0 800 500"&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;script type="text/python"&gt;
from browser import window
from browser import document
# 將 Snap 轉為 Brython 物件
snap = window.Snap.new

s = snap("#svgout1")
# 建立物件時, 同時設定 id 名稱
r = s.rect(10,10,100,100).attr({'id': 'rect'})
c = s.circle(100,100,50).attr({'id': 'circle'})
r.attr('fill', 'red')
c.attr({ 'fill': 'blue', 'stroke': 'black', 'strokeWidth': 10 })
r.attr({ 'stroke': '#123456', 'strokeWidth': 20 })
s.text(180,100, '點按一下圖形').attr({'fill' : 'blue',  'stroke': 'blue', 'stroke-width': 0.2 })

g = s.group().attr({'id': 'tux'})

def hoverover(ev):
    g.animate({'transform': 's1.2r45,t180,20'}, 1000, window.mina.bounce)

def hoverout(ev):
    g.animate({'transform': 's1r0,t180,20'}, 1000, window.mina.bounce) 

# callback 函式
def onSVGLoaded(data):
    #s.append(data)
    g.append(data)
    #g.hover(hoverover, hoverout )
    g.text(300,100, '將滑鼠指向企鵝')

# 利用 window.Snap.load 載入 svg 檔案
tux = window.Snap.load("https://chiamingyen.github.io/kmolab_data/files/Dreaming_tux.svg", onSVGLoaded)
g.transform('t180,20')

# 與視窗事件對應的函式
def rtoyellow(ev):
    r.attr('fill', 'yellow')

def ctogreen(ev):
    c.attr('fill', 'green')

# 根據物件 id 綁定滑鼠事件執行對應函式
document['rect'].bind('click', rtoyellow)
document['circle'].bind('click', ctogreen)
document['tux'].bind('mouseover', hoverover)
document['tux'].bind('mouseleave', hoverout)
&lt;/script&gt;

&lt;p&gt;上述繪圖程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;svg id="svgout1" width="800" height="500" viewBox="0 0 800 500"&gt;&lt;/svg&gt;

&lt;script type="text/python"&gt;
from browser import window
from browser import document
# 將 Snap 轉為 Brython 物件
snap = window.Snap.new

s = snap("#svgout1")
# 建立物件時, 同時設定 id 名稱
r = s.rect(10,10,100,100).attr({'id': 'rect'})
c = s.circle(100,100,50).attr({'id': 'circle'})
r.attr('fill', 'red')
c.attr({ 'fill': 'blue', 'stroke': 'black', 'strokeWidth': 10 })
r.attr({ 'stroke': '#123456', 'strokeWidth': 20 })
s.text(180,100, '點按一下圖形').attr({'fill' : 'blue',  'stroke': 'blue', 'stroke-width': 0.2 })

g = s.group().attr({'id': 'tux'})

def hoverover(ev):
    g.animate({'transform': 's1.2r45,t180,20'}, 1000, window.mina.bounce)

def hoverout(ev):
    g.animate({'transform': 's1r0,t180,20'}, 1000, window.mina.bounce) 

# callback 函式
def onSVGLoaded(data):
    #s.append(data)
    g.append(data)
    #g.hover(hoverover, hoverout )
    g.text(300,100, '將滑鼠指向企鵝')

# 利用 window.Snap.load 載入 svg 檔案
tux = window.Snap.load("https://chiamingyen.github.io/kmolab_data/files/Dreaming_tux.svg", onSVGLoaded)
g.transform('t180,20')

# 與視窗事件對應的函式
def rtoyellow(ev):
    r.attr('fill', 'yellow')

def ctogreen(ev):
    c.attr('fill', 'green')

# 根據物件 id 綁定滑鼠事件執行對應函式
document['rect'].bind('click', rtoyellow)
document['circle'].bind('click', ctogreen)
document['tux'].bind('mouseover', hoverover)
document['tux'].bind('mouseleave', hoverout)
&lt;/script&gt;
&lt;/pre&gt;

&lt;p&gt;Other SVG library: &lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/duopixel/Method-Draw"&gt;https://github.com/duopixel/Method-Draw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/mozman/svgwrite"&gt;https://github.com/mozman/svgwrite&lt;/a&gt;&lt;/p&gt;</summary><category term="Brython"></category><category term="svg"></category></entry><entry><title>協同 2D 正齒輪傳動繪圖 (二)</title><link href="./brython-2d-spur-gear-matching-2.html" rel="alternate"></link><published>2017-05-03T12:00:00+08:00</published><updated>2017-05-03T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-05-03:./brython-2d-spur-gear-matching-2.html</id><summary type="html">&lt;p&gt;採用最新的 &lt;a href="https://github.com/brython-dev/brython/releases/tag/3.3.1"&gt;Brython 3.3.1&lt;/a&gt; 與 Cango Javascript 程式庫 (&lt;a href="./../data/w11/cango/Cango-9v05.js"&gt;Cango-9v05.js&lt;/a&gt;), 從單一 2D 正齒輪繪圖到齒輪組嚙合&lt;/p&gt;


&lt;p&gt;利用漸開線原理, 以 Brython 繪製單一正齒輪廓:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
# 以下列出 W11 2B 與 2A 未出席人數
data = open("./../data/w11/2b0503.txt", encoding="utf-8").read()
data1 = open("./../data/w11/2a0504.txt", encoding="utf-8").read()
count = 0
count1 = 0
# 去掉前面兩列
student = data.split("\n")[2:]
student1 = data1.split("\n")[2:]
for i in range(len(student)):
    each = student[i].split("\t")
    # 請注意, Brython 在 Windows 環境無法正確判定字串, 原因不明
    if each[1] != "出席":
        count = count + 1
for i in range(len(student1)):
    each1 = student1[i].split("\t")
    if each1[1] != "present":
        count1 = count1 + 1
div = doc["onegear_div"]
div &lt;= "2b: " +  str(count) + "/" + str(len(student)) + "|" + "2a: " +  str(count1) + "/" + str(len(student1))
&lt;/script&gt;

&lt;!-- 以下處理 Cango Spur Gear --&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/Cango-9v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAxes-2v09.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/CangoAnimation-5v00.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
#cobj = window.Cobj.new
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new

tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = shape(data, {
  "fillColor":"#ddd0dd",
  "border": True,
  "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = path(shapedefs.circle(hr))
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path

# setup the animation
# backlash (mm)
bklsh = 0.04*m
# centre shift to make backlash
dC = bklsh/(2*math.tan(math.pi*pa/180))
# np 為小齒輪齒數
np = 13
# gear ratio
gr = n/np              
gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]}
# gr*0.666 rpm
#pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]}
# 0.666 rpm
twnr = tweener(0, 90000, "loop")

cx = canvas.width/2
cy = canvas.height/2
#gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
#cgo.render(gear)
# 利用 gear 資料複製一份, 命名為 gear1
gear1 = gear.dup()

from time import time
from browser.timer import request_animation_frame as raf
from browser.timer import set_interval

deg = math.pi/180

def draw():
    cgo.clearCanvas()
    gear.rotate(2*deg)
    # 在特定位置, 以特定 scale, 特定 degs 執行 render
    cgo.render(gear, {'x':cx-pr/2, 'y':cy, 'scl':0.5, 'degs':0})
    gear1.rotate(-2*deg)
    cgo.render(gear1, {'x':cx+pr*2*0.5-pr/2, 'y':cy, 'scl':0.5, 'degs':0})

set_interval(draw, 2)
&lt;/script&gt;

&lt;p&gt;接著將設法處理以 Canvas 直接繪圖, 以及呼叫 Cango 程式庫兩種正齒輪嚙合的協同繪圖 (17t-11t-13t):&lt;/p&gt;
&lt;p&gt;以 &lt;a href="http://www.arc.id.au"&gt;Cango 程式庫&lt;/a&gt;完成鏈條傳動模擬:&lt;/p&gt;
&lt;p&gt;設法導出直線與圓弧倒圓角的繪圖流程:&lt;/p&gt;</summary><category term="Brython"></category><category term="w11"></category></entry><entry><title>協同 2D 正齒輪傳動繪圖</title><link href="./brython-2d-spur-gear-matching.html" rel="alternate"></link><published>2017-05-03T11:00:00+08:00</published><updated>2017-05-03T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-05-03:./brython-2d-spur-gear-matching.html</id><summary type="html">&lt;p&gt;從單一 2D 正齒輪繪圖到齒輪組嚙合&lt;/p&gt;


&lt;p&gt;利用漸開線原理, 以 Brython 繪製單一正齒輪廓:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 繪圖--&gt;

&lt;canvas id="onegear" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;div id="onegear_div" width="800" height="20"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx

    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
canvas = doc['onegear']
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.height/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
# 以下列出 W11 2B 未出席人數
data = open("./../data/w11/2b0503.txt", encoding="utf-8").read()
count = 0
# 去掉前面兩列
student = data.split("\n")[2:]
for i in range(len(student)):
    each = student[i].split("\t")
    if each[1] != "出席":
        count = count + 1
#print(count)
div = doc["onegear_div"]
div &lt;= "2b: " +  str(count) + "/" + str(len(student))
&lt;/script&gt;

&lt;!-- 以下處理 Cango Spur Gear --&gt;

&lt;!-- Cango 程式庫 --&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/Cango-8v03.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/Cango2D-7v01-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/CangoAxes-1v33.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/CangoAnimation-4v01.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/w11/cango
_old/gearUtils-05.js"&gt;&lt;/script&gt;

&lt;canvas id='cango_gear' width='800' height='750'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
import math

# 主要用來取得畫布大小
canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = window.Cobj.new
creategeartooth = window.createGearTooth.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)

# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True

# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&lt;/script&gt;

&lt;p&gt;接著將設法處理兩種正齒輪嚙合的協同繪圖 (17t-11t-13t):&lt;/p&gt;
&lt;p&gt;以及設法導出直線與圓弧倒圓角的繪圖流程:&lt;/p&gt;</summary><category term="Brython"></category><category term="w11"></category></entry><entry><title>協同產品設計實習第十一週</title><link href="./onshape-taiwan.html" rel="alternate"></link><published>2017-05-02T11:00:00+08:00</published><updated>2017-05-02T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-05-02:./onshape-taiwan.html</id><summary type="html">&lt;p&gt;就在 Onshape 網站最底下, 您看到什麼?&lt;/p&gt;


&lt;p&gt;&lt;img src="./../data/w11/buttomline_onshape.png" width="800" height="600" /&gt;&lt;/p&gt;
&lt;p&gt;Two Ebooks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;An Introduction to Agile Product Design – by Onshape.pdf (The Move To Agile Design.pdf) (協同閱讀寫心得)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Onshape's Greatest Tech Tips– Volume 1.pdf  (協同閱讀寫心得)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Designing Linkages in Context:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.onshape.com/cad-blog/designing-linkages-in-context"&gt;https://www.onshape.com/cad-blog/designing-linkages-in-context&lt;/a&gt; (參考寫心得)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/FsDoc/"&gt;FeatureScript&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.onshape.com/cad-blog/featurescript-its-so-easy-an-engineer-can-do-it"&gt;https://www.onshape.com/cad-blog/featurescript-its-so-easy-an-engineer-can-do-it&lt;/a&gt; (參考寫心得)&lt;/p&gt;
&lt;p&gt;Spur Gear speed reducer design: &lt;a href="http://geargenerator.com"&gt;http://geargenerator.com&lt;/a&gt; (2D 靜態網際繪圖-3D 減速齒輪組動態模擬)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=mq_b58jUZAU"&gt;V-rep 齒輪組模擬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&amp;t=3057"&gt;V-rep 齒輪組模擬參考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Leg_mechanism"&gt;https://en.wikipedia.org/wiki/Leg_mechanism&lt;/a&gt; Project (實作)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wikis.utexas.edu/display/RMD/Simulation"&gt;V-rep 行走機構模擬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=5CfIpbY7N-s"&gt;多四連桿行走機構模擬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://galvanicloop.com/blog/post/7/quadruped-robot-5-simulation-on-v-rep"&gt;四足行走機構&lt;/a&gt;&lt;/p&gt;</summary><category term="Onshape"></category><category term="w11"></category></entry><entry><title>W10</title><link href="./brython-programming.html" rel="alternate"></link><published>2017-04-27T11:00:00+08:00</published><updated>2017-04-27T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-04-27:./brython-programming.html</id><summary type="html">&lt;p&gt;brython&lt;/p&gt;


&lt;p&gt;&lt;a href="https://github.com/mdecourse/cdw10"&gt;https://github.com/mdecourse/cdw10&lt;/a&gt; 為提供 .py 程式功能的倉儲, 而 &lt;a href="https://github.com/mdecourse/cdw10_task"&gt;https://github.com/mdecourse/cdw10_task&lt;/a&gt; 則是將 cdw10 倉儲設為子模組的主倉儲. 一旦 cdw10 納入作為 cdw10_task gh-pages 模式下的子模組, 使用者就可以透過 cdw10_task 直接 import cdw10 倉儲中的程式碼與連組件.&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;

&lt;!--&lt;canvas id="w10" width="800" height="600"&gt;&lt;/canvas&gt;--&gt;

&lt;div id="container" width="600" height="400"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
container = doc['container']
degree = math.pi/180
def button1(event):
    a = input("give me a")
    container &lt;= str(math.cos(60*degree)+float(a))
doc["button1"].bind("click", button1)
&lt;/script&gt;

&lt;p&gt;&lt;button id="button1"&gt;按下取 a 值&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;上述按鈕取值程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;
&lt;script src="../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;
&lt;!--&lt;canvas id="w10" width="800" height="600"&gt;&lt;/canvas&gt;--&gt;

&lt;div id="container" width="600" height="400"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
container = doc['container']
degree = math.pi/180
def button1(event):
    a = input("give me a")
    container &lt;= str(math.cos(60*degree)+float(a))
doc["button1"].bind("click", button1)
&lt;/script&gt;
&lt;button id="button1"&gt;按下取 a 值&lt;/button&gt;
&lt;/pre&gt;</summary><category term="Brython"></category><category term="w10"></category></entry><entry><title>期中協同查驗與自評</title><link href="./midterm-collaboration-evaluation.html" rel="alternate"></link><published>2017-04-15T11:00:00+08:00</published><updated>2017-04-15T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-04-15:./midterm-collaboration-evaluation.html</id><summary type="html">&lt;p&gt;以下為協同產品設計實習 2017 Spring 期中考週的四個實習查驗題目. 完成後, 請各組員依照指示完成期中自評與互評.&lt;/p&gt;


&lt;h3&gt;(一) Fossil Server 實習查驗&lt;/h3&gt;
&lt;p&gt;本實習查驗題目必須在期中考當天 0810-0900 時段中完成.&lt;/p&gt;
&lt;p&gt;請各組利用電腦輔助設計室中的電腦, 重新建立一台以 https 為連結協定的 Fossil Server (起始 Timeline 必須為期中考當天日期與時間為準), 並以"[a or b]g[1 ~8] 期中報告" (例如: 甲班第1組為 ag1 期中報告, 依此類推) 為 server 標題, 每一組員以學號為帳號, 各組員分別在 Wiki 中以 [學號] 期中學習心得" (例如: 4012345 期中學習心得) 為 Wiki 頁面標題, 概述上課至今的心得與自評成績.&lt;/p&gt;
&lt;p&gt;完成後, 請報上各組 Serve 的 ip 位址進行查驗.&lt;/p&gt;
&lt;h3&gt;(二) 四連桿機構協同 Trace Point 查驗&lt;/h3&gt;
&lt;p&gt;本實習查驗題目必須在期中考當天 0910-1000 時段中完成.&lt;/p&gt;
&lt;p&gt;請參考 &lt;a href="http://mde.tw/2016fallcadp/blog/2016fall-ping-mian-ji-gou-mo-ni.html"&gt;電腦輔助設計實習第十週上課內容&lt;/a&gt;, 在各組網誌中, 以子模組 (&lt;a href="https://github.com/blog/2104-working-with-submodules"&gt;Github Submodule&lt;/a&gt;) 的設定, 擷取各組員倉儲中的 T 點軌跡座標檔 (請以 midterm1.csv, midterm2.csv .... 依序命名) 後進行網際協同繪圖.&lt;/p&gt;
&lt;p&gt;各組組員請依學號遞增排序, 排序第1者負責分析 Length=50 的 T 點軌跡圖, 其餘組員則依序將 Length -5, 分別在各組網誌中列出所有組員所完成的四連桿 T 點運動軌跡圖. (例如: 第2位組員負責 Length=45 的四連桿分析, 第3位則負責 Length=40 ....)&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/midterm_fourbar_linkage.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;(長 30 mm 的連桿為馬達輸入桿, Trace Point 為 T 點)&lt;/p&gt;
&lt;p&gt;參考的網際程式如下:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script type="text/javascript" 
    src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;

&lt;canvas id="fourbar" width="600" height="400"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# 準備繪圖畫布
canvas = doc["fourbar"]
ctx = canvas.getContext("2d")

fourbar_data = open("./../data/cadpa_w10_4bar.csv").read()
fourbar_list = fourbar_data.splitlines()
#container1 &lt;= fourbar_list[0]
# 以下可以利用 ctx 物件進行畫圖
# 先畫一條直線
ctx.beginPath()
# 設定線的寬度為 1 個單位
ctx.lineWidth = 1
# 利用 transform 將 y 座標反轉, 且 offset canvas.height
# (X scale, X skew, Y skew, Y scale, X offset, Y offset)
# 配合圖形位置進行座標轉換
ctx.transform(1, 0, 0, -1, canvas.width/2+250, canvas.height/2+100)
# 畫出 x 與 y 座標線
# 各座標值放大 8 倍
ratio = 8
ctx.moveTo(0, 0)
ctx.lineTo(-30*ratio, 0)
start_point = fourbar_list[0].split(",")
ctx.moveTo(float(start_point[0])*ratio, float(start_point[1])*ratio)
count = 0
for data in fourbar_list[1:]:
    point = data.split(",")
    #count = count + 1
    #container1 &lt;= str(count) + ":" + point[0] + "," + point[1]
    #container1 &lt;= html.BR()
    ctx.lineTo(float(point[0])*ratio, float(point[1])*ratio)
# 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
ctx.strokeStyle = "blue"
# 實際執行畫線
ctx.stroke()
ctx.closePath()
&lt;/script&gt;
&lt;/pre&gt;

&lt;h3&gt;(三) Fourbar Walker OnShape 零件協同繪圖與組立查驗&lt;/h3&gt;
&lt;p&gt;本實習查驗題目必須在期中考當天 1010-1100 時段中完成.&lt;/p&gt;
&lt;p&gt;請各組依照下列基本尺寸規劃, 以協同方式在 OnShape 環境中完成四連桿四足行走機構,  並分別拍攝協同規劃與實際操作影片, 將影片送到 1) Youtube 2) Vimeo 以及各組的 Fossil Server.&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/fourbar_walker.png" width="800" /&gt;&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/213422859" width="800" height="600" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/213422859"&gt;機械設計工程系-協同產品設計實習課程: 期中四連桿四足行走機構題目&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;(四) 分組協同零件展示&lt;/h3&gt;
&lt;p&gt;本實習查驗題目必須在期中考當天 1110-1145 時段中完成, 1145-1200 將以所指定的 Ethercalc 即時表單, 取各學員的期中自評成績.&lt;/p&gt;
&lt;p&gt;請各組於完成四足行走機構後, 轉為 STL 格式, 利用下列 viewer, 將機構展示在各組的網誌中.&lt;/p&gt;
&lt;p&gt;利用 &lt;a href="https://github.com/JinJunho/Madeleine.js"&gt;Madeleine 程式庫&lt;/a&gt;, 擷取位於 ./../data/spikeball.stl 位置的零件 stl 格式檔案:&lt;/p&gt;
&lt;p&gt;&lt;link href="./../data/madeleine/src/css/Madeleine.css" rel="stylesheet"&gt;
&lt;script src="./../data/madeleine/src/lib/stats.js"&gt;&lt;/script&gt;
&lt;script src="./../data/madeleine/src/lib/detector.js"&gt;&lt;/script&gt;
&lt;script src="./../data/madeleine/src/lib/three.min.js"&gt;&lt;/script&gt;
&lt;script src="./../data/madeleine/src/Madeleine.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;div id="target" class="madeleine"&gt;&lt;/div&gt;

&lt;script&gt;
window.onload = function(){
    var madeleine = new Madeleine({
      target: 'target', // target div id
      data: './../data/spikeball.stl', // data path
      path: './../data/madeleine/src/' // path to source directory from current html file
    });
}; 
&lt;/script&gt;

&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.min.js"
&gt;&lt;/script&gt;

&lt;script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"
&gt;&lt;/script&gt;

&lt;script src="./../data/w9/loader.js"&gt;&lt;/script&gt;

&lt;script src="./../data/w9/stl.js"&gt;&lt;/script&gt;

&lt;div&gt;
select stl file: &lt;input type="file" id="file" /&gt; or drop stl file
&lt;/div&gt;

&lt;div id="view"&gt;&lt;/div&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;

&lt;canvas id="fourbar" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# 導入 fourbar 
import fourbar
# 準備繪圖畫布
canvas = doc["fourbar"]
ctx = canvas.getContext("2d")

# y 軸向上移動 pixel 數
y_lift = 150

# 將 y 轉為向上為正
def newy(y):
    return (canvas.height - y - y_lift)

# 所有尺寸放大倍數
ratio = 4

# 畫線函式
def line(ctx, ax, ay, bx, by, width=1, color='blue'):
    ctx.beginPath()
    ctx.strokeStyle = color
    ctx.lineWidth = width
    # 直接轉換 y 座標
    ctx.moveTo(ax*ratio, newy(ay*ratio))
    ctx.lineTo(bx*ratio, newy(by*ratio))
    ctx.stroke()
    ctx.closePath()

def getT(x1, y1, x2, y2):
    x = x2 - x1
    y = y2 - y1
    if (math.fabs(x) &lt; math.pow(10,-100)):
        if(y &lt; 0.0):
            return (-math.pi/2)
        else:
            return (math.pi/2)
    else:
        return math.atan2(y, x)

def link(ctx, ax, ay, bx, by, width=1, color='blue'):
    hole = 5
    radius = 10
    length = math.sqrt((ax*ratio-bx*ratio)**2+(newy(ay*ratio)-newy(by*ratio))**2)
    # 儲存先前的繪圖狀態
    ctx.save()
    ctx.translate(ax*ratio, newy(ay*ratio))
    ctx.rotate(-math.pi*0.5 + getT(ax*ratio, newy(ay*ratio), bx*ratio, newy(by*ratio)))
    # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
    ctx.beginPath()
    ctx.strokeStyle = color
    ctx.lineWidth = width
    ctx.moveTo(0,0)
    ctx.arc(0, 0, hole, 0, 2*math.pi, True)
    ctx.stroke()
    ctx.moveTo(0,length)
    ctx.beginPath()
    ctx.arc(0,length, hole, 0, 2*math.pi, True)
    ctx.stroke()
    ctx.moveTo(0,0)
    ctx.beginPath()
    ctx.arc(0,0, radius, 0, math.pi, True)
    ctx.moveTo(0+radius,0)
    ctx.lineTo(0+radius,0+length)
    ctx.stroke()
    ctx.moveTo(0,0+length)
    ctx.beginPath()
    ctx.arc(0, 0+length, radius, math.pi, 0, True)
    ctx.moveTo(0-radius,0+length)
    ctx.lineTo(0-radius,0)
    ctx.stroke()
    ctx.restore()

degree = math.pi/180
ax = 60
ay = 0
bx = 120
by = 0
bac = 0
ac = 30
cd = 50
db = 60
ce = 50
ed = 50

# 利用 fourbar 物件建立案例
f = fourbar.fourbar(ax = 60, ay = 0, bx = 120, by = 0, bac = 0, ac = 30, cd = 50, db = 60, ce = 50, ed = 50)

# 兩條軸線
#line(ctx, 0, 0, 0, 100, 3, 'blue')
#line(ctx, 0, 0, 100, 0, 3, 'blue')
# base line
#line(ctx, ax, ay, bx, by, 3, 'red')
f.bac = 0
for j in range(10):
    f.ce = 50 - j *3
    # link1
    link(ctx, f.ax, f.ay, f.cx, f.cy, 1, 'blue')
    # link2
    link(ctx, f.cx, f.cy, f.dx, f.dy, 1, 'blue')
    # link3
    link(ctx, f.dx, f.dy, f.bx, f.by, 1, 'blue')
    # triangle sides
    line(ctx, f.cx, f.cy, f.ex, f.ey, 1, 'black')
    line(ctx, f.dx, f.dy, f.ex, f.ey, 1, 'black')
    # 進入 e 點輪廓繪製流程
    # f.bac = 0 開始繪圖
    # 直接轉換 y 座標
    ctx.moveTo(f.ex*ratio, newy(f.ey*ratio))
    ctx.beginPath()
    ctx.strokeStyle = 'red'
    ctx.lineWidth = 1
    for i in range(0, 365, 5):
        f.bac = i *degree
        ctx.lineTo(f.ex*ratio, newy(f.ey*ratio))
    ctx.stroke()
    ctx.closePath()
&lt;/script&gt;

&lt;p&gt;參考用 fourbar.py:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from math import pi, cos, sin, sqrt, acos

radian = 180/pi
degree = pi/180

#PLAP
def plap(ax, ay, ac, bac, bx, by, pos):
    if pos == 0:
        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    else:
        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    return cx, cy

#PLLP
def pllp(ax, ay, ac, cb, bx, by, pos):
    if pos == 0:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    else:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    return cx, cy

class fourbar(object):

    '''
    (ax, ay) motor coord
    (bx, by) rocker base coord
    bac motor angle
    ac link1 length
    cd link2 length
    db link3 length
    ce triangle side1
    ed triangle side2
    '''
    def __init__(self, ax, ay, bx, by, bac, ac, cd, db, ce, ed):

        self.ax = ax
        self.ay = ay
        self.bx = bx
        self.by = by
        self.bac = bac
        self.ac = ac
        self.cd = cd
        self.db = db
        self.ce = ce
        self.ed = ed

    @property
    def cx(self):
        return plap(self.ax, self.ay, self.ac, self.bac, self.bx, self.by, pos=0)[0]

    @property
    def cy(self):
        return plap(self.ax, self.ay, self.ac, self.bac, self.bx, self.by, pos=0)[1]

    @property
    def dx(self):
        return pllp(self.cx, self.cy, self.cd, self.db, self.bx, self.by, pos=0)[0]

    @property
    def dy(self):
        return pllp(self.cx, self.cy, self.cd, self.db, self.bx, self.by, pos=0)[1]

    @property
    def ex(self):
        return pllp(self.cx, self.cy, self.ce, self.ed, self.dx, self.dy, pos=0)[0]

    @property
    def ey(self):
        return pllp(self.cx, self.cy, self.ce, self.ed, self.dx, self.dy, pos=0)[1]

'''    
# 利用 fourbar 物件建立案例
f = fourbar(ax = -60, ay = 0, bx = 0, by = 0, bac = 50*degree, ac = 30, cd = 50, db = 60, ce = 50, ed = 50)

# 利用 fourbar 物件案例的方法求各點座標
#f.cx, f.cy 為 C 點座標
#f.dx, f.dy 為 D 點座標
#f.ex, f.ey 為 E 點座標
'''
&lt;/pre&gt;

&lt;p&gt;Brython 四連桿 E 點運動軌跡繪圖程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫四連桿 trace point 路徑--&gt;
&lt;canvas id="fourbar" width="800" height="600"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# 導入 fourbar 
import fourbar
# 準備繪圖畫布
canvas = doc["fourbar"]
ctx = canvas.getContext("2d")

# y 軸向上移動 pixel 數
y_lift = 150

# 將 y 轉為向上為正
def newy(y):
    return (canvas.height - y - y_lift)

# 所有尺寸放大倍數
ratio = 4

# 畫線函式
def line(ctx, ax, ay, bx, by, width=1, color='blue'):
    ctx.beginPath()
    ctx.strokeStyle = color
    ctx.lineWidth = width
    # 直接轉換 y 座標
    ctx.moveTo(ax*ratio, newy(ay*ratio))
    ctx.lineTo(bx*ratio, newy(by*ratio))
    ctx.stroke()
    ctx.closePath()

def getT(x1, y1, x2, y2):
    x = x2 - x1
    y = y2 - y1
    if (math.fabs(x) &lt; math.pow(10,-100)):
        if(y &lt; 0.0):
            return (-math.pi/2)
        else:
            return (math.pi/2)
    else:
        return math.atan2(y, x)

def link(ctx, ax, ay, bx, by, width=1, color='blue'):
    hole = 5
    radius = 10
    length = math.sqrt((ax*ratio-bx*ratio)**2+(newy(ay*ratio)-newy(by*ratio))**2)
    # 儲存先前的繪圖狀態
    ctx.save()
    ctx.translate(ax*ratio, newy(ay*ratio))
    ctx.rotate(-math.pi*0.5 + getT(ax*ratio, newy(ay*ratio), bx*ratio, newy(by*ratio)))
    # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
    ctx.beginPath()
    ctx.strokeStyle = color
    ctx.lineWidth = width
    ctx.moveTo(0,0)
    ctx.arc(0, 0, hole, 0, 2*math.pi, True)
    ctx.stroke()
    ctx.moveTo(0,length)
    ctx.beginPath()
    ctx.arc(0,length, hole, 0, 2*math.pi, True)
    ctx.stroke()
    ctx.moveTo(0,0)
    ctx.beginPath()
    ctx.arc(0,0, radius, 0, math.pi, True)
    ctx.moveTo(0+radius,0)
    ctx.lineTo(0+radius,0+length)
    ctx.stroke()
    ctx.moveTo(0,0+length)
    ctx.beginPath()
    ctx.arc(0, 0+length, radius, math.pi, 0, True)
    ctx.moveTo(0-radius,0+length)
    ctx.lineTo(0-radius,0)
    ctx.stroke()
    ctx.restore()

degree = math.pi/180
ax = 60
ay = 0
bx = 120
by = 0
bac = 0
ac = 30
cd = 50
db = 60
ce = 50
ed = 50

# 利用 fourbar 物件建立案例
f = fourbar.fourbar(ax = 60, ay = 0, bx = 120, by = 0, bac = 0, ac = 30, cd = 50, db = 60, ce = 50, ed = 50)

# 兩條軸線
#line(ctx, 0, 0, 0, 100, 3, 'blue')
#line(ctx, 0, 0, 100, 0, 3, 'blue')
# base line
#line(ctx, ax, ay, bx, by, 3, 'red')
f.bac = 0
for j in range(10):
    f.ce = 50 - j *3
    # link1
    link(ctx, f.ax, f.ay, f.cx, f.cy, 1, 'blue')
    # link2
    link(ctx, f.cx, f.cy, f.dx, f.dy, 1, 'blue')
    # link3
    link(ctx, f.dx, f.dy, f.bx, f.by, 1, 'blue')
    # triangle sides
    line(ctx, f.cx, f.cy, f.ex, f.ey, 1, 'black')
    line(ctx, f.dx, f.dy, f.ex, f.ey, 1, 'black')
    # 進入 e 點輪廓繪製流程
    # f.bac = 0 開始繪圖
    # 直接轉換 y 座標
    ctx.moveTo(f.ex*ratio, newy(f.ey*ratio))
    ctx.beginPath()
    ctx.strokeStyle = 'red'
    ctx.lineWidth = 1
    for i in range(0, 365, 5):
        f.bac = i *degree
        ctx.lineTo(f.ex*ratio, newy(f.ey*ratio))
    ctx.stroke()
    ctx.closePath()
&lt;/script&gt;
&lt;pre&gt;</summary><category term="v-rep"></category><category term="w9"></category></entry><entry><title>V-rep 平面機構運動模擬</title><link href="./vrep-planar-mechanism-simulation.html" rel="alternate"></link><published>2017-03-21T11:00:00+08:00</published><updated>2017-03-21T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-03-21:./vrep-planar-mechanism-simulation.html</id><summary type="html">&lt;p&gt;V-rep planar one-line and fourbar linkage simulation&lt;/p&gt;


&lt;h2&gt;One-link Robot Velocity Control&lt;/h2&gt;
&lt;p&gt;One-link manipulator Python3 remote API program:&lt;/p&gt;
&lt;p&gt;Joint Properties - &lt;/p&gt;
&lt;p&gt;Torque/Force Mode.&lt;/p&gt;
&lt;p&gt;Moter enabled with Maximum torque setup and zero target velocity.&lt;/p&gt;
&lt;p&gt;Joint ObjectName: Revolute_joint&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import vrep
import sys
# child threaded script: 
# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入
#simExtRemoteApiStart(19999)

vrep.simxFinish(-1)

clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')

errorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,'Revolute_joint',vrep.simx_opmode_oneshot_wait)

if errorCode == -1:
    print('Can not find left or right motor')
    sys.exit()

errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)

while True:
    choice = input("(e to exit, p to pause and enter to exec)&gt;")
    if choice == "e":
        print("exiting")
        vrep.simxStopSimulation(clientID, vrep.simx_opmode_oneshot_wait)
        break
    elif choice == "p":
        vrep.simxPauseSimulation(clientID, vrep.simx_opmode_oneshot_wait)
    else:
        vrep.simxStartSimulation(clientID, vrep.simx_opmode_oneshot_wait)
&lt;/pre&gt;

&lt;h2&gt;One-link Robot Position Control&lt;/h2&gt;
&lt;p&gt;One-link manipulator Python3 remote API program:&lt;/p&gt;
&lt;p&gt;Joint Properties - &lt;/p&gt;
&lt;p&gt;Torque/Force Mode.&lt;/p&gt;
&lt;p&gt;Moter enabled with Maximum torque setup and zero target velocity.&lt;/p&gt;
&lt;p&gt;Joint ObjectName: Revolute_joint&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import vrep
import sys, math
# child threaded script: 
# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入
#simExtRemoteApiStart(19999)

vrep.simxFinish(-1)

clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')

errorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,'Revolute_joint',vrep.simx_opmode_oneshot_wait)

if errorCode == -1:
    print('Can not find left or right motor')
    sys.exit()

deg = math.pi/180

#errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)

def setJointPosition(incAngle, steps):
    for i  in range(steps):
        errorCode=vrep.simxSetJointPosition(clientID, Revolute_joint_handle, i*incAngle*deg, vrep.simx_opmode_oneshot_wait)

# 每步 10 度, 轉兩圈
setJointPosition(10, 72)
# 每步 1 度, 轉兩圈
#setJointPosition(1, 720)
# 每步 0.1  度, 轉720 步
#setJointPosition(0.1, 720)

'''
三軸同動時
simxPauseCommunication(clientID,1);
simxSetJointPosition(clientID,joint1Handle,joint1Value,simx_opmode_oneshot);
simxSetJointPosition(clientID,joint2Handle,joint2Value,simx_opmode_oneshot);
simxSetJointPosition(clientID,joint3Handle,joint3Value,simx_opmode_oneshot);
simxPauseCommunication(clientID,0);
'''
&lt;/pre&gt;

&lt;h2&gt;Fourbar Linkage Velocity Control&lt;/h2&gt;
&lt;p&gt;the First Joint properties - &lt;/p&gt;
&lt;p&gt;Torque/Force mode with motor enabled and target velocity 120 deg/s and maximum torque 50 N*m.&lt;/p&gt;
&lt;p&gt;Joint ObjectName: Revolute_joint&lt;/p&gt;
&lt;p&gt;All other joints with Torque/Force mode without motor enabled.&lt;/p&gt;
&lt;pre class="brush:python"&gt;
import vrep
import sys
# child threaded script: 
# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入
#simExtRemoteApiStart(19999)

vrep.simxFinish(-1)

clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')

errorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,'Revolute_joint',vrep.simx_opmode_oneshot_wait)

if errorCode == -1:
    print('Can not find left or right motor')
    sys.exit()

errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)

while True:
    choice = input("(e to exit, p to pause and enter to exec)&gt;")
    if choice == "e":
        print("exiting")
        vrep.simxStopSimulation(clientID, vrep.simx_opmode_oneshot_wait)
        break
    elif choice == "p":
        vrep.simxPauseSimulation(clientID, vrep.simx_opmode_oneshot_wait)
    else:
        vrep.simxStartSimulation(clientID, vrep.simx_opmode_oneshot_wait)
&lt;/pre&gt;

&lt;h2&gt;Fourbar Linkage Position Control&lt;/h2&gt;
&lt;p&gt;V-rep Fourbar linkage remote API program:&lt;/p&gt;
&lt;p&gt;the First Joint properties - &lt;/p&gt;
&lt;p&gt;Passive mode with Hybrid operation.&lt;/p&gt;
&lt;p&gt;Position control (PID) with proportional parameter 0.1 without I and D controls.&lt;/p&gt;
&lt;p&gt;Joint ObjectName: Revolute_joint&lt;/p&gt;
&lt;p&gt;All other joints properties - &lt;/p&gt;
&lt;p&gt;Inverse kinematics mode with Hybrid operation.&lt;/p&gt;
&lt;p&gt;Position control (PID) with proportional parameter 0.1 without I and D controls.&lt;/p&gt;
&lt;pre class="brush:python"&gt;
import vrep, math
import sys
# child threaded script: 
#simExtRemoteApiStart(19999)

vrep.simxFinish(-1)

clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')

errorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,'Revolute_joint',vrep.simx_opmode_oneshot_wait)

deg = math.pi/180

if errorCode == -1:
    print('Can not find left or right motor')
    sys.exit()

#errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)

def setJointPosition(incAngle, steps):
    for i  in range(steps):
        errorCode=vrep.simxSetJointPosition(clientID, Revolute_joint_handle, i*incAngle*deg, vrep.simx_opmode_oneshot_wait)

# 每步 10 度, 轉兩圈
setJointPosition(10,72)
&lt;/pre&gt;

&lt;p&gt;與上述四連桿位置控制流程相同, 但是由 Python3 remote API 程式負責控制 V-rep 的模擬啟動與模擬終止.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import vrep, math
import sys
# child threaded script: 
#simExtRemoteApiStart(19999)

vrep.simxFinish(-1)

clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)
#啟動模擬
vrep.simxStartSimulation(clientID, vrep.simx_opmode_oneshot)

if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')

errorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,'Revolute_joint',vrep.simx_opmode_oneshot_wait)

deg = math.pi/180

if errorCode == -1:
    print('Can not find left or right motor')
    sys.exit()

#errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)

def setJointPosition(incAngle, steps):
    for i  in range(steps):
        errorCode=vrep.simxSetJointPosition(clientID, Revolute_joint_handle, i*incAngle*deg, vrep.simx_opmode_oneshot_wait)
    #終止模擬
    vrep.simxStopSimulation(clientID, vrep.simx_opmode_oneshot_wait)

# 每步 10 度, 轉兩圈
setJointPosition(10, 72)
&lt;/pre&gt;</summary><category term="v-rep"></category><category term="w5"></category></entry><entry><title>網際平面機構模擬</title><link href="./brython-planar-linkage.html" rel="alternate"></link><published>2017-03-15T11:00:00+08:00</published><updated>2017-03-15T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-03-15:./brython-planar-linkage.html</id><summary type="html">&lt;p&gt;Brython 平面 quadratic bezier 曲線:&lt;/p&gt;


&lt;!-- 導入 Brython 標準程式庫 3.3.1 --&gt;

&lt;script type="text/javascript" src="./../data/brython_dist.js"&gt;
&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/Cango-8v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/Cango2D-7v04-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/CangoAnimation-4v01.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython 時, 設定 pythonpath 為 data/py --&gt;

&lt;script&gt;
window.onload=function(){
// 此地可以透過 github 的 submodule 設定, 分別導入各組員的協同網際程式
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;canvas id="plotarea" width="600" height="600"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from browser import window

cango = window.Cango2D.new
shapedefs = window.shapeDefs
obj2d = window.Obj2D.new
group2d = window.Group2D.new
cgo = cango("plotarea")

x1, y1 = 40, 20
cx1, cy1 = 90, 120
x2, y2 = 120, 100
cx2, cy2 = 130, 20
cx3, cy3 = 150, 120
x3, y3 = 180, 60

def dragC1(mousePos):
    global cx1, cy1
    cx1 = mousePos.x
    cy1 = mousePos.y
    drawCurve()

def dragC2(mousePos):
    global cx2, cy2
    cx2 = mousePos.x
    cy2 = mousePos.y
    drawCurve()

def dragC3(mousePos):
    global cx3, cy3
    cx3 = mousePos.x
    cy3 = mousePos.y
    drawCurve()

def drawCurve():
    # curve change shape so it must be re-draw each time
    # draw a quadratic bezier from x1,y2 to x2,y2
    qbez = obj2d(['M', x1, y1, 'Q', cx1, cy1, x2, y2], "PATH",  {
          "strokeColor":'blue'})
    cbez = obj2d(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], "PATH",  {
          "strokeColor":'green'})
    # show lines to control point
    L1 = obj2d(['M', x1, y1, 'L', cx1, cy1, x2, y2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})  # semi-transparent gray
    L2 = obj2d(['M', x2, y2, 'L', cx2, cy2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    L3 = obj2d(['M', x3, y3, 'L', cx3, cy3], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    #c1.transform.reset()
    c1.transform.translate(cx1, cy1)
    #c2.transform.reset()
    c2.transform.translate(cx2, cy2)
    #c3.transform.reset()
    c3.transform.translate(cx3, cy3)
    grp = group2d(qbez, cbez, L1, L2, L3, c1, c2, c3)
    cgo.clearCanvas()
    cgo.render(grp)

cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(0, 0, 200)

# draggable control points
c1 = obj2d(shapedefs.circle(4), "SHAPE", {"fillColor":'red'})
c1.enableDrag(None, dragC1, None)
c2 = c1.dup()
c2.enableDrag(None, dragC2, None)
c3 = c1.dup()
c3.enableDrag(None, dragC3, None)
drawCurve();
&lt;/script&gt;

&lt;p&gt;平面機構繪圖:&lt;/p&gt;
&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;canvas id="plotarea2" width="600" height="600"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from browser import window

cango = window.Cango2D.new
shapedefs = window.shapeDefs
obj2d = window.Obj2D.new
group2d = window.Group2D.new
cgo = cango("plotarea2")

x1, y1 = 40, 20
cx1, cy1 = 90, 120

x2, y2 = 120, 100
cx2, cy2 = 130, 20

cx3, cy3 = 150, 120
x3, y3 = 180, 60

def dragC1(mousePos):
    global cx1, cy1
    cx1 = mousePos.x
    cy1 = mousePos.y
    drawCurve()

def dragC2(mousePos):
    global cx2, cy2
    cx2 = mousePos.x
    cy2 = mousePos.y
    drawCurve()

def dragC3(mousePos):
    global cx3, cy3
    cx3 = mousePos.x
    cy3 = mousePos.y
    drawCurve()

def dragX1(mousePos):
    global x1, y1
    x1 = mousePos.x
    y1 = mousePos.y
    drawCurve()

def drawCurve():
    # curve change shape so it must be re-draw each time
    # draw a quadratic bezier from x1,y2 to x2,y2
    qbez = obj2d(['M', x1, y1, 'Q', cx1, cy1, x2, y2], "PATH",  {
          "strokeColor":'blue'})
    cbez = obj2d(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], "PATH",  {
          "strokeColor":'green'})
    # show lines to control point
    '''
    L1 = obj2d(['M', x1, y1, 'L', cx1, cy1, x2, y2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})  # semi-transparent gray
    L2 = obj2d(['M', x2, y2, 'L', cx2, cy2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    L3 = obj2d(['M', x3, y3, 'L', cx3, cy3], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "dashed":[4]})
    '''
    L1 = obj2d(['M', x1, y1, 'L', cx1, cy1], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "solided":[10]})  # semi-transparent gray

    L2 = obj2d(['M', cx1, cy1, 'L', cx2, cy2], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "solided":[10]})

    L3 = obj2d(['M', cx2, cy2, 'L', cx3, cy3], "PATH", {
      "strokeColor":"rgba(0, 0, 0, 0.2)",
      "solided":[10]})

    #c1.transform.reset()
    c1.transform.translate(cx1, cy1)
    #c2.transform.reset()
    c2.transform.translate(cx2, cy2)
    #c3.transform.reset()
    c3.transform.translate(cx3, cy3)
    #mx1.transform.reset()
    mx1.transform.translate(x1, y1)
    #grp = group2d(qbez, cbez, L1, L2, L3, c1, c2, c3)
    grp = group2d(L1, L2, L3, c1, c2, c3, mx1)
    cgo.clearCanvas()
    cgo.render(grp)

cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(0, 0, 200)

# draggable control points
c1 = obj2d(shapedefs.circle(4), "SHAPE", {"fillColor":'red'})
c1.enableDrag(None, dragC1, None)
c2 = c1.dup()
c2.enableDrag(None, dragC2, None)
c3 = c1.dup()
c3.enableDrag(None, dragC3, None)
mx1 = c1.dup()
mx1.enableDrag(None, dragX1, None)
drawCurve();
&lt;/script&gt;

&lt;p&gt;機械手臂動態模擬:&lt;/p&gt;
&lt;canvas id='robot' width='800' height='400'&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from browser import window

cango2d = window.Cango2D.new
shapedefs = window.shapeDefs
obj2d = window.Obj2D.new
tweener = window.Tweener.new

cgo = cango2d("robot")
# 清除畫面
cgo.clearCanvas("lightyellow")
cgo.setWorldCoords(-50, -50, 300)

# 加上基軸與第一桿
# 畫筆移到 -20, -10, 畫直線到 -10,-10 以及 -10,0 
standData = ['M', -20,-10, 'L', -10,-10, -10,0, 'A', 10,10,0,0,0,10,0, 'L',10,-10, 20,-10, 20,-40, -20,-40,'z']
stand = obj2d(standData, "SHAPE", {
        "fillColor":'darkgray',
        "border": True,
        "strokeColor": "#222222" })
axle0 = obj2d(shapedefs.circle(10), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222" })
armGrp = cgo.createGroup2D(stand, axle0)

segData = ['M',0,-8, 'A',8,8,0,0,0,0,8, 'L',50,8, 'A',8,8,0,0,0,50,-8, 'Z']
seg1 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
# 利用 zIndex 決定疊層的先後次序
axle1 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle1.translate(50, 0)
seg1Grp = cgo.createGroup2D(seg1, axle1)
armGrp.addObj(seg1Grp)

# 加上第二軸
seg2 = obj2d(segData, "SHAPE", {
        "fillColor":'darkGray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": -1 })
axle2 = obj2d(shapedefs.circle(8), "SHAPE", {
        "fillColor":'gray',
        "border": True,
        "strokeColor": "#222222",
        "zIndex": 1 })
axle2.translate(50, 0)
seg2Grp = cgo.createGroup2D(seg2, axle2)
cgo.render(seg2Grp)
# 請注意 seg2Grp 加上 seg1Grp 物件上
seg1Grp.addObj(seg2Grp)

seg3 = obj2d(segData, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
axle3 = obj2d(shapedefs.circle(6), "SHAPE", {
        'fillColor':'gray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': 1 })
axle3.translate(50, 0)
seg3Grp = cgo.createGroup2D(seg3, axle3)
seg2Grp.addObj(seg3Grp)

seg4Data = ['M',0,-6, 'A',6,6,0,0,0,0,6, 'L',40,6, 40,12, 50,12, 50,-12, 40,-12, 40,-6, 'Z']
seg4 = obj2d(seg4Data, "SHAPE", {
        'fillColor':'darkGray',
        'border': True,
        'strokeColor': "#222222",
        'zIndex': -1 })
seg3Grp.addObj(seg4)

# setup animation
animData = {'s1': [0, 80, 45, 0],
                  's2': [0, -60, -60, 0],
                  's3': [0, -90, 0, 90, 0],
                  's4': [0, 30, -90, 0]}

armTwnr = tweener(0, 3500, 'loop')

def initArm(opts):
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.translate(50,0)
    seg4.transform.translate(50,0)


def armPathFn(time, opts):
    seg1Rot = armTwnr.getVal(time, opts.s1)
    seg2Rot = armTwnr.getVal(time, opts.s2)
    seg3Rot = armTwnr.getVal(time, opts.s3)
    seg4Rot = armTwnr.getVal(time, opts.s4)

    seg1Grp.transform.rotate(seg1Rot)
    seg2Grp.transform.rotate(seg2Rot)
    seg2Grp.transform.translate(50,0)
    seg3Grp.transform.rotate(seg3Rot)
    seg3Grp.transform.translate(50,0)
    seg4.transform.rotate(seg4Rot)
    seg4.transform.translate(50,0)

cgo.animate(armGrp, initArm, armPathFn, animData)
cgo.playAnimation()
&lt;/script&gt;

&lt;p&gt;Cango Graphics Library:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arc.id.au/CanvasGraphics.html"&gt;http://www.arc.id.au/CanvasGraphics.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cango3D Graphics Library:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arc.id.au/Canvas3DGraphics.html"&gt;http://www.arc.id.au/Canvas3DGraphics.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cango2D Graphics Library:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arc.id.au/CanvasAnimation.html"&gt;http://www.arc.id.au/CanvasAnimation.html&lt;/a&gt;&lt;/p&gt;</summary><category term="brython"></category><category term="w4"></category></entry><entry><title>網際 Brython 3.3.1 程式執行環境</title><link href="./brython-editor-331.html" rel="alternate"></link><published>2017-03-14T11:00:00+08:00</published><updated>2017-03-14T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-03-14:./brython-editor-331.html</id><summary type="html">&lt;p&gt;Brython 程式環境可以用來練習許多 Python3 的簡單語法, 也可以納入 Javascript 程式庫, 利用 Ajax 模式結合網際瀏覽器與伺服器上的資源解決協同產品設計流程上的問題.&lt;/p&gt;


&lt;!-- 導入 FileSaver 與 filereader --&gt;

&lt;script type="text/javascript" src="./../ace/FileSaver.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../ace/filereader.js"&gt;&lt;/script&gt;

&lt;!-- 導入最新版的 Brython 標準程式庫 3.3.1 --&gt;

&lt;script type="text/javascript" src="./../data/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython 時, 設定 pythonpath 為 data/py, 並將 script1.py 放入, 以便取代 3.2.9 之前版本的 script id 導入 --&gt;

&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;p&gt;列出 2017 Spring 協同產品設計實習課程日期之 Python 程式碼如下:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;div id="cal2"&gt;&lt;/div&gt;
&lt;script type="text/python3"&gt;
from browser import document, html
import calendar
import locale

cal2 = document["cal2"]

def getClassdate(year=2017, startM=2, startD=20, w=0, note=""):
    # w=0 表示課程排在星期一
    # startM 表示開學月份, startD 表示開學日
    # note 為課程初始告示
    # default calendar MONDAY is the first day of the week
    # 每學期共有 18 週
    totalW = 18
    count = 0
    # output = "2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: "
    output = note + html.BR()
    # 若必須全年搜尋則 7 改為 12, 但是因為只有 18 週, 因此邏輯要修改讓程式較快結束
    for month in range(startM, 7):
        monthArray = calendar.monthcalendar(2017, month)
        for week in range(len(monthArray)):
            weekArray = monthArray[week]
            # 只需要列出星期 (w+1)
            if weekArray[w] != 0:
                if month == startM:
                    if weekArray[startM] &gt; startD:
                        count += 1
                        if count &lt;= totalW:
                            if month == 3 and weekArray[w] == 31:
                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "
                            else:
                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
                else:
                    count += 1
                    if count &lt;=  totalW:
                        if month == 3 and weekArray[w] == 31:
                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "
                        else:
                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
    cal2 &lt;= output

# 2b 協同產品設計實習 (三 w=2)
getClassdate(year=2017, startM=2, startD=20, w=2, note="2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 2a 協同產品設計實習 (四 w=3)
getClassdate(year=2017, startM=2, startD=20, w=3, note="2017 Spring 2aCD (四) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring 1aWCM (五) 13:20-16:10 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# VE1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring VE1aCP (五) 18:30-20:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
&lt;/script&gt;
&lt;/pre&gt;

&lt;h3&gt;利用伺服器執行 Python3 程式&lt;/h3&gt;
&lt;p&gt;Jupyterhub: &lt;a href="https://8888.kmol.info:9443"&gt;https://8888.kmol.info:9443&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;利用以下的編輯器執行 Python3 程式&lt;/h3&gt;
&lt;p&gt;在 Firefox 中, 以 Preferences - General - Downloads 選擇"Always ask me where to save files"&lt;/p&gt;
&lt;p&gt;在 Chrome 中, 以 Settings - Advanced - Downloads 選擇 Ask where to save each file before downloading&lt;/p&gt;
&lt;script src="./../ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;

&lt;script type="text/javascript"&gt;
function doSave(){
    var blob = new Blob([localStorage["py_src"]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById('filename').value
    saveAs(blob, filename+".py");
}
&lt;/script&gt;

&lt;!-- 請注意 Brython 3.3.0 之後的版本, 已經不能使用 script id 模式導入, 改用 pythonpath 中的 script1.py 供後續導入 --&gt;

&lt;script type="text/python3" id="script1"&gt;
import sys
import time
import traceback
import javascript

from browser import document as doc, window, alert

has_ace = True
try:
    editor = window.ace.edit("editor")
    session = editor.getSession()
    session.setMode("ace/mode/python")

    editor.setOptions({
     'enableLiveAutocompletion': True,
     'enableSnippets': True,
     'highlightActiveLine': False,
     'highlightSelectedWord': True
    })
except:
    from browser import html
    editor = html.TEXTAREA(rows=20, cols=70)
    doc["editor"] &lt;= editor
    def get_value(): return editor.value
    def set_value(x):editor.value = x
    editor.getValue = get_value
    editor.setValue = set_value
    has_ace = False

if hasattr(window, 'localStorage'):
    from browser.local_storage import storage
else:
    storage = None

def reset_src():
    if storage is not None and "py_src" in storage:
        editor.setValue(storage["py_src"])
    else:
        editor.setValue('for i in range(10):\n\tprint(i)')
    editor.scrollToRow(0)
    editor.gotoLine(0)

def reset_src_area():
    if storage and "py_src" in storage:
        editor.value = storage["py_src"]
    else:
        editor.value = 'for i in range(10):\n\tprint(i)'

class cOutput:

    def __init__(self,target):
        self.target = doc[target]
    def write(self,data):
        self.target.value += str(data)


#if "console" in doc:
sys.stdout = cOutput("console")
sys.stderr = cOutput("console")

def to_str(xx):
    return str(xx)

info = sys.implementation.version
doc['version'].text = 'Brython %s.%s.%s' % (info.major, info.minor, info.micro)

output = ''

def show_console(ev):
    doc["console"].value = output
    doc["console"].cols = 60
    doc["console"].rows = 10

# load a Python script
def load_script(evt):
    _name = evt.target.value + '?foo=%s' % time.time()
    editor.setValue(open(_name).read())

# run a script, in global namespace if in_globals is True
def run(*args):
    global output
    doc["console"].value = ''
    src = editor.getValue()
    if storage is not None:
       storage["py_src"] = src

    t0 = time.perf_counter()
    try:
        #ns = {'__name__':'__main__'}
        ns = {'__name__':'editor'}
        exec(src, ns)
        state = 1
    except Exception as exc:
        traceback.print_exc(file=sys.stderr)
        state = 0
    output = doc["console"].value

    print('&lt;completed in %6.2f ms&gt;' % ((time.perf_counter() - t0) * 1000.0))
    return state

if has_ace:
    reset_src()
else:
    reset_src_area()

def clear_console(ev):
    doc["console"].value = ""

doc['run'].bind('click',run)
doc['show_console'].bind('click',show_console)
doc['clear_console'].bind('click',clear_console)
&lt;/script&gt;

&lt;div id="version"&gt;&lt;/div&gt;

&lt;div id="editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave();"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="run"&gt;Run&lt;/button&gt;
&lt;button id="show_console"&gt;Output&lt;/button&gt;
&lt;button id="clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="common"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex1(ev):
    script1.editor.setValue('''#ex1 簡單的 for 迴圈範例
    for i in range(10):
        print(i)
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex1'].bind('click',ex1)
&lt;/script&gt;

&lt;p&gt;&lt;a id="ex1"&gt;ex1&lt;/a&gt;-for 迴圈&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex2(ev):
    script1.editor.setValue('''#溫度轉換程式
from browser import document as doc

# 因為此函式與滑鼠互動, 需要 event 當作輸入
def convTemp():
    mystring = ""
    cdegree = input("請輸入攝氏溫度:")
    fdegree = float(cdegree)*9/5 + 32
    output_string = "攝氏 " + str(cdegree) + "度=華氏 " + str(fdegree) + "度" 
    # 利用 print() 將轉換結果送到 console 區
    print(output_string)

#直接呼叫 convTemp() 執行
convTemp()
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex2'].bind('click',ex2)
&lt;/script&gt;

&lt;p&gt;&lt;a id="ex2"&gt;ex2&lt;/a&gt;-溫度換算&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex3(ev):
    script1.editor.setValue('''#jansen 多連桿機構驗算
from math import pi, cos, sin, sqrt, acos

radian = 180/pi
degree = pi/180

#PLAP
def plap(ax, ay, ac, bac, bx, by, ccw):
    if ccw == 1:
        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    else:
        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    return cx, cy

#PLLP
def pllp(ax, ay, ac, cb, bx, by, cw):
    if cw == 1:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    else:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    return cx, cy

ax = -38
ay = 0
# b 為原點
bx = 0
by = 0
cx = 0
cy = 7.8
# m 為配合 PLAP 新增固定點
mx = 30
my = 7.8
# dcm ccw 方向角度
dcm = 30*degree
cd = 15
# 三角形 dcm 為 ccw plap d=(a, cd, dcm, m)
dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1)
print("dx=", dx, "dy=", dy)
# 三角形 aed 為 cw pllp e=(a, ae, ed, d)
ae = 41.5
ed = 50
ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1)
print("ex=", ex, "ey=", ey)
# 三角形 afe 為 cw pllp f=(a, af, fe, e)
af = 40.1
fe = 55.8
fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1)
print("fx=", fx, "fy=", fy)
# 三角形 dha 為 cw pllp h=(d, dh, ha, a)
dh = 61.9
ha = 39.3
hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1)
print("hx=", hx, "hy=", hy)
# 三角形 hgf 為 cw pllp g=(h, hg, gf, f)
hg = 36.7
gf = 39.4
gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1)
print("gx=", gx, "gy=", gy)
# 三角形 hkg 為 cw pllp k=(h, hk, kg, g)
hk = 49
kg = 65.7
kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1)
print("kx=", kx, "ky=", ky)
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex3'].bind('click',ex3)
&lt;/script&gt;

&lt;p&gt;&lt;a id="ex3"&gt;ex3&lt;/a&gt;-多連桿機構&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_file(e):
    data = open("./../python_ex/for1.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)

document["get"].bind("click", get_file)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_temp1(e):
    data = open("./../python_ex/temp1.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)

document["get_temp1"].bind("click", get_temp1)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_ver_and_kw(e):
    data = open("./../python_ex/ver_and_kw.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)

document["get_ver_and_kw"].bind("click", get_ver_and_kw)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def jansen(e):
    data = open("./../python_ex/jansen.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)

document["jansen"].bind("click", jansen)
&lt;/script&gt;

&lt;p&gt;&lt;button id="get"&gt;for1.py&lt;/button&gt;&lt;button id="get_temp1"&gt;temp1.py&lt;/button&gt;&lt;button id="get_ver_and_kw"&gt;ver_and_kw.py&lt;/button&gt;&lt;button id="jansen"&gt;jansen.py&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;Jansen 多連桿機構尺寸圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/jansen_sympy.png" width="800" /&gt;&lt;/p&gt;</summary><category term="brython"></category><category term="w1"></category></entry><entry><title>協同產品設計實習第1週任務</title><link href="./brython-2d-drawing.html" rel="alternate"></link><published>2017-02-22T11:00:00+08:00</published><updated>2017-02-22T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-02-22:./brython-2d-drawing.html</id><summary type="html">&lt;p&gt;網際協同設計資料整合, 網際 2D 程式繪圖回顧&lt;/p&gt;


&lt;h2&gt;網際協同設計資料整合&lt;/h2&gt;
&lt;p&gt;利用 Github 倉儲中的組員間 git submodule 設定, 可以進行網際協同設計資料整合.&lt;/p&gt;
&lt;p&gt;導入組員設計資料範例: &lt;a href="http://mde.tw/2016fallcadp/blog/li-yong-git-submodule-gong-neng-jin-xing-zu-yuan-zi-liao-she-ji-zheng-he.html"&gt;http://mde.tw/2016fallcadp/blog/li-yong-git-submodule-gong-neng-jin-xing-zu-yuan-zi-liao-she-ji-zheng-he.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;導入組員程式範例: &lt;a href="https://scrum-1.github.io/2016fallcadp_ag100/blog/dao-ru-zu-yuan-cheng-shi-ce-shi.html"&gt;https://scrum-1.github.io/2016fallcadp_ag100/blog/dao-ru-zu-yuan-cheng-shi-ce-shi.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;網際 2D 程式繪圖回顧&lt;/h2&gt;
&lt;p&gt;利用 HTML5 Canvas 與 Brython, 可以進行網際 2D 設計模擬繪圖:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations"&gt;https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.codeproject.com/Articles/598955/CoordinateplussystemplusinplusHTML-plusCanvas-cpl"&gt;https://www.codeproject.com/Articles/598955/CoordinateplussystemplusinplusHTML-plusCanvas-cpl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.carbonfive.com/2011/03/31/taming-2d-transforms/"&gt;http://blog.carbonfive.com/2011/03/31/taming-2d-transforms/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.carbonfive.com/2011/02/17/visualizing-skillsets-in-html5-canvas-part-1/"&gt;http://blog.carbonfive.com/2011/02/17/visualizing-skillsets-in-html5-canvas-part-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用網際 Python3 程式進行 2D 繪圖:&lt;/p&gt;
&lt;!-- 為了讓 import script1 可以正確運行, 停留在 Brython 3.2.9 版 --&gt;

&lt;script type="text/javascript" src="https://cdn.rawgit.com/brython-dev/brython/3.2.9/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../scrum-1/py']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;!-- 以下實際利用  Brython 畫兩條直線 --&gt;

&lt;canvas id="canvas1" width="600" height="200"&gt;&lt;/canvas&gt;

&lt;script type="text/python3" id="script1"&gt;
from browser import document
import math
# 準備繪圖畫布
canvas = document["canvas1"]
ctx = canvas.getContext("2d")

def axises(ctx):
    ctx.beginPath()
    # 設定線的寬度為 5 個單位
    ctx.lineWidth = 5
    # 將畫筆移動到 (0, 0) 座標點
    ctx.moveTo(0, 0)
    # 然後畫直線到 (100, 0) 座標點
    ctx.strokeStyle = "red"
    ctx.lineTo(100, 0)
    ctx.lineTo(90, 10)
    ctx.stroke()
    ctx.closePath()

    ctx.beginPath()
    # 畫右上左下的斜線
    ctx.moveTo(0, 0)
    ctx.strokeStyle = "green"
    ctx.lineTo(0, 100)
    ctx.lineTo(10, 90)
    # 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
    #ctx.strokeStyle = "blue"
    # 實際執行畫線
    ctx.stroke()
    ctx.closePath()

axises(ctx)
# 以下可以利用 ctx 物件進行畫圖
# 先畫一條直線
ctx.beginPath()
# 設定線的寬度為 1 個單位
ctx.lineWidth = 1
# 將畫筆移動到 (100, 100) 座標點
ctx.moveTo(100, 100)
# 然後畫直線到 (150, 200) 座標點
ctx.lineTo(150, 200)
# 畫右上左下的斜線
ctx.moveTo(150, 100)
ctx.lineTo(100, 200)
# 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
ctx.strokeStyle = "blue"
# 實際執行畫線
ctx.stroke()
ctx.closePath()
&lt;/script&gt;

&lt;p&gt;以上為 canvas1, 座標軸 x 向右為正, y 向下為正.
&lt;hr&gt;&lt;/p&gt;
&lt;canvas id="canvas2" width="600" height="400"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1
import math
# 準備繪圖畫布
canvas = document["canvas2"]
ctx = canvas.getContext("2d")
#ctx.save()
#ctx.transform(1, 0, 0, -1, 0, canvas.height)

def background(x, y, xinc, yinc, xnum, ynum, ctx):
    # 水平線
    for i in range(ynum+1):
        ctx.beginPath()
    # 設定線的寬度為 1 個單位
        if i == 0:
            ctx.lineWidth = 7
        else:
            ctx.lineWidth = 1
        ctx.moveTo(x-1, y+i*yinc)
        ctx.lineTo(x+xnum*xinc+1, y+i*yinc)
        # 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
        ctx.strokeStyle = "blue"
        ctx.stroke()
        ctx.closePath()

    # 垂直線
    for i in range(xnum+1):
        ctx.beginPath()
    # 設定線的寬度為 1 個單位
        ctx.lineWidth = 1
        ctx.moveTo(x+i*xinc, y)
        ctx.lineTo(x+i*xinc, y+ynum*yinc)
        # 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
        ctx.strokeStyle = "blue"
        ctx.stroke()
        ctx.closePath()

def newCoord(x, y):
    global canvas
    newy = canvas.height - y
    return x, newy

def canvasText(x, y, fontSize, string, sup, sub, center, color, ctx):
    #ctx.restore()
    #x, y = newCoord(x, y)
    ctx.beginPath()
    ctx.fillStyle = color
    ctx.strokeStyle = color
    #ctx.font = "20px Arial"
    ctx.font = str(fontSize)+ "px Arial"
    if center != "":
        ctx.fillText(string, x+fontSize/float(center), y)
    else:
        ctx.fillText(string, x, y)
    ctx.font = str(fontSize-8)+ "px Arial"
    if sup != "":
        ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2)
    if sub != "":
        ctx.fillText(sub, x+fontSize/1.6, y+fontSize/4)
    ctx.fill()
    ctx.stroke()
    ctx.closePath()

def canvasDot(x, y, r, color, ctx):
    #ctx.restore()
    #x, y = newCoord(x, y)
    ctx.beginPath()
    #ctx.fillStyle = 'black'
    ctx.fillStyle = color
    #ctx.strokeStyle = "black"
    ctx.strokeStyle = color
    #ctx.arc(50, 80, 9, 0, 2*math.pi, False)
    ctx.arc(x, y, r, 0, 2*math.pi, False)
    # 為了疊上各把位的音名, 暫時不填色
    ctx.fill()
    ctx.stroke()

w = 20
h = 30
script1.axises(ctx)
background(100, 100, w, h, 5, 5, ctx)
mylist = ["E", "A", "D", "G", "B", "E"]
num = 0
for s in mylist:
    #canvasText(100,  80, 20, "A", "b", "", "", "black", ctx)
    canvasText(100+num*w,  80, 20, s, "", "", "", "black", ctx)
    num = num + 1

canvasText(100+num*w,  80, 20, "A", "b", "", "", "black", ctx)
num = num + 1
canvasText(100,  80+h*7, 20, "(", "", "", "2.5", "black", ctx)
inc = 18
canvasText(100+inc*1,  80+h*7, 20, "x", "2", "1", "", "black", ctx)
canvasText(100+inc*2,  80+h*7, 20, ",", "", "", "4", "black", ctx)
canvasText(100+inc*3,  80+h*7, 20, "y", "", "1", "", "black", ctx)
canvasText(100+inc*4,  80+h*7, 20, ")", "", "", "4", "black", ctx)
canvasDot(100+inc*1,  80+h*8, 5, "red", ctx)
&lt;/script&gt;

&lt;p&gt;以上為 canvas2, 座標軸 x 向右為正, y 向下為正.
&lt;hr&gt;&lt;/p&gt;
&lt;canvas id="canvas3" width="600" height="400"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1
import math
# 準備繪圖畫布
canvas = document["canvas3"]
ctx = canvas.getContext("2d")
# save original state
ctx.save()
ctx.transform(1, 0, 0, -1, 0, canvas.height)

def newCoord(x, y):
    global canvas
    newy = canvas.height - y
    return x, newy

def background(x, y, xinc, yinc, xnum, ynum, ctx):
    # 水平線
    for i in range(ynum+1):
        ctx.beginPath()
    # 設定線的寬度為 1 個單位
        if i == 0:
            ctx.lineWidth = 7
        else:
            ctx.lineWidth = 1
        ctx.moveTo(x-1, y+i*yinc)
        ctx.lineTo(x+xnum*xinc+1, y+i*yinc)
        # 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
        ctx.strokeStyle = "blue"
        ctx.stroke()
        ctx.closePath()

    # 垂直線
    for i in range(xnum+1):
        ctx.beginPath()
    # 設定線的寬度為 1 個單位
        ctx.lineWidth = 1
        ctx.moveTo(x+i*xinc, y)
        ctx.lineTo(x+i*xinc, y+ynum*yinc)
        # 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
        ctx.strokeStyle = "blue"
        ctx.stroke()
        ctx.closePath()

def canvasText(x, y, fontSize, string, sup, sub, center, color, ctx):
    ctx.beginPath()
    ctx.fillStyle = color
    ctx.strokeStyle = color
    #ctx.font = "20px Arial"
    ctx.font = str(fontSize)+ "px Arial"
    if center != "":
        ctx.fillText(string, x+fontSize/float(center), y)
    else:
        ctx.fillText(string, x, y)
    ctx.font = str(fontSize-8)+ "px Arial"
    if sup != "":
        ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2)
    if sub != "":
        ctx.fillText(sub, x+fontSize/1.6, y+fontSize/4)
    ctx.fill()
    ctx.stroke()
    ctx.closePath()

def canvasDot(x, y, r, color, ctx):
    ctx.beginPath()
    #ctx.fillStyle = 'black'
    ctx.fillStyle = color
    #ctx.strokeStyle = "black"
    ctx.strokeStyle = color
    #ctx.arc(50, 80, 9, 0, 2*math.pi, False)
    ctx.arc(x, y, r, 0, 2*math.pi, False)
    # 為了疊上各把位的音名, 暫時不填色
    ctx.fill()
    ctx.stroke()

w = 20
h = 30
# 畫座標軸線
script1.axises(ctx)
ctx.restore()
background(100, 100, w, h, 5, 5, ctx)
mylist = ["E", "A", "D", "G", "B", "E"]
num = 0
for s in mylist:
    #canvasText(100,  80, 20, "A", "b", "", "", "black", ctx)
    canvasText(100+num*w,  80, 20, s, "", "", "", "black", ctx)
    num = num + 1

ctx.save()
canvasText(100+num*w,  80, 20, "A", "b", "", "", "black", ctx)
num = num + 1
canvasText(100,  80+h*7, 20, "(", "", "", "2.5", "black", ctx)
inc = 18
canvasText(100+inc*1,  80+h*7, 20, "x", "2", "1", "", "black", ctx)
canvasText(100+inc*2,  80+h*7, 20, ",", "", "", "4", "black", ctx)
canvasText(100+inc*3,  80+h*7, 20, "y", "", "1", "", "black", ctx)
canvasText(100+inc*4,  80+h*7, 20, ")", "", "", "4", "black", ctx)
canvasDot(100+inc*1,  80+h*8, 5, "red", ctx)
&lt;/script&gt;

&lt;p&gt;以上為 canvas3, 座標軸 x 向右為正, y 向上為正.
&lt;hr&gt;&lt;/p&gt;
&lt;canvas id="canvas4" width="600" height="200"&gt;&lt;/canvas&gt;

&lt;script type="text/python3"&gt;
from browser import document
import math
# 準備繪圖畫布
canvas = document["canvas4"]
ctx = canvas.getContext("2d")

ctx.fillRect(0, 0, 150, 150) #Draw a rectangle with default settings
ctx.save() #Save the default state

ctx.fillStyle = '#09F' #Make changes to the settings
ctx.fillRect(15, 15, 120, 120) #Draw a rectangle with new settings

ctx.save() #Save the current state
ctx.fillStyle = '#FFF'; #Make changes to the settings
ctx.globalAlpha = 0.5 
ctx.fillRect(30, 30, 90, 90) #Draw a rectangle with new settings

ctx.restore() #Restore previous state
ctx.fillRect(45, 45, 60, 60) #Draw a rectangle with restored settings

ctx.restore() #Restore original state
ctx.fillRect(60, 60, 30, 30) #Draw a rectangle with restored settings
&lt;/script&gt;

&lt;!--
The first step is to draw a large rectangle with the default settings. Next we save this state and make changes to the fill color. We then draw the second and smaller blue rectangle and save the state. Again we change some drawing settings and draw the third semi-transparent white rectangle.

So far this is pretty similar to what we've done in previous sections. However once we call the first restore() statement, the top drawing state is removed from the stack, and settings are restored. If we hadn't saved the state using save(), we would need to change the fill color and transparency manually in order to return to the previous state. This would be easy for two properties, but if we have more than that, our code would become very long, very fast.

When the second restore() statement is called, the original state (the one we set up before the first call to save) is restored and the last rectangle is once again drawn in black.
--&gt;

&lt;h2&gt;W1 實習任務&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;請自行分組每班分為八組, 各組協調後每一位組員均採固定座位就坐, 請各組設法列出各組員座位圖後, 以全班協同方式直接在各組網誌上呈現各組員學號與座位圖, 以 a 班為例, 各組倉儲名稱分別為 2017springcd_ag1~2017springcd_ag8, 各組的網誌中均必須設法呈現全班的電腦教室座位圖. (問題: 有沒有辦法在每週上課後第1堂下課之前, 在各組網誌上呈現當週各學員的出席情況與座次表?)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各組必須準備一個隨身硬碟儲存下載的可攜系統, 並且分別下載 &lt;a href="http://service.mde.tw/public/tiny2017_50MB.7z"&gt;tiny2017_50MB.7z&lt;/a&gt;, 以及 &lt;a href="http://service.mde.tw/public/tiny2017_1GB.7z"&gt;tiny2017_1GB.7z&lt;/a&gt;, 各組期中簡報時, 必須說明如何從最基本的 50MB 系統逐一納入各類工具得到 1GB 的最終可攜系統. (問題: 各組員會不會從無到有, 自行打造此一可攜程式系統?)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每四組將分配一台電腦當作區網協同伺服主機, 請各組分別指派一名組員負責, 向助教報到, 以便學習如何搭建區域網路上的 Fossil SCM 協同主機, 並負責為各組員建立及管理相關帳號. (問題: 各組有沒有能力自行維護區域網路上的協同產品設計主機?)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本學期課程將會使用 Github, Bitbucket, Vimeo, Youtube, Fossil SCM (由各組自行建立) 與 Onshape 等系統, 請各組員確定已經利用學號作為代號, 擁用各系統的擷取帳號. (問題: 如何呈現階段性的設計實習成果?)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;請各組員確認已經會在 Solvespace 與 Onshape 中完成四連桿機構的組立, 並且輸出 stl 格式檔案後, 輸入 V-rep 中. (課程終極目標: 本課程將嘗試從電腦輔助機械設計進入運動模擬, 納入簡單的機電整合與傳動, 最後期望每班協同模擬並列印組立出兩台四足行走機構)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本學期每週上課結束前, 各組均必須直接在 Github Page 中以 Reveal.js 格式, 完成各週的協同實習簡報檔, 其中包含各學員與各組任務執行進度與自評.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;請根據上述網際繪圖程式架構, 以 Brython 完成下列四連桿機構的示意繪圖:&lt;/p&gt;
&lt;p&gt;其中旋轉軸點為 A 座標為 (x1, y1), 旋轉軸端點為 B 座標為 (x2, y2), 第2連桿端點為 C 座標為 (x3, y3), 第3軸的固定端點則為 D 座標為 (x4, y4).&lt;/p&gt;
&lt;p&gt;另外, 以 A 點為起點的主動旋轉桿長為 d1, BC 連桿長為 d2, CD 桿長度為 d3, AD 桿長為 d4, BC 連桿上與旋轉路徑目標點 E 對應的點為 F, 與 B 點的距離為 d5, 與 E 點垂直距離為 d6, 主動旋轉軸的逆時鐘旋轉角度則為 t.&lt;/p&gt;
&lt;p&gt;此一平面四連桿的輸入為 x1, y1, x4, y4, d1, d2, d3, d5, d6, 以及 t, 輸出則為 E 點的運動路徑.&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/planar_fourbar_triangle.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;利用 &lt;a href="http://www.sympy.org/"&gt;Sympy&lt;/a&gt; 求解:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from sympy import *
'''
已知四連桿四個關鍵點座標分別為 A (x1, y1), B (x2, y2), C (x3, y3) 與 D (x4, y4)
且 E (x5, y5) 點相關參考x 座標距離為 d5, 而 y座標距離為 d6, 以及輸入角度逆時鐘轉 t 度
以 (x1, y1), (x4, y4), d1, d2, d3, d5, d6 及 t 等 10 個參數作為輸入, 
求 E 點座標 (x5, y5)
假設 AB 連桿長度為 d1, BC 連桿長度為 d2, CD 連桿長度為 d3, AD 距離為 d4
'''
x1, x2, x3, x4, x5 = symbols('x1 x2 x3 x4 x5')
y1, y2, y3, y4, y5 = symbols('y1 y2 y3 y4 y5')
d1, d2, d3, d4, d5, d6, t, t3 = symbols('d1 d2 d3 d4 d5 d6 t t3')
ah, bh, aj, dj, bd, hj, dk, bk = symbols('ah bh aj dj bd hj dk bk')
# angle daj defined as daj
daj, adj, bad, bcd, bdc, bdk = symbols('daj adj bad bcd bdc bdk')
# degree factor
degree, pi = symbols('degree pi')
degree = pi/180.0
# 假設 B 點的絕對 y 座標方向投影點為 H
d1 = sqrt((x1-x2)**2+(y1-y2)**2)
#print(d1)
d2 = sqrt((x2-x3)**2+(y2-y3)**2)
d3 = sqrt((x3-x4)**2+(y3-y4)**2)
d4 = sqrt((x1-x4)**2+(y1-y4)**2)
ah = d1*cos(t)
bh = sqrt(d1**2 - ah**2)
aj = Abs(x4-x1)
dj = Abs(y4-y1)
dk = aj - ah
bk =  bh - dj
t3 = bdc + bdk
# for daj, dj**2 = d4**2+aj**2 -2*d4*aj*cos(daj)
pos = 1
if pos == 1:
    daj = solve(-dj**2+d4**2+aj**2 -2*d4*aj*cos(daj), daj)[0]
else:
    daj = solve(-dj**2+d4**2+aj**2 -2*d4*aj*cos(daj), daj)[1]
#print(daj)
# for adj, aj**2=d4**2+dj**2-2*d4*aj*cos(adj)
if pos == 1:
    adj = solve(-aj**2+d4**2+dj**2-2*d4*aj*cos(adj), adj)[0]
else:
    adj = solve(-aj**2+d4**2+dj**2-2*d4*aj*cos(adj), adj)[0]
#print(adj)
bad = t*degree - daj
# according triangle tad find bd
#bd**2 = d1**2+d4**2-2*d1*d4*cos(bad)
if pos == 1:
    bd = solve(-bd**2+d1**2+d4**2-2*d1*d4*cos(bad), bd)[0]
else:
    bd = solve(-bd**2+d1**2+d4**2-2*d1*d4*cos(bad), bd)[1]
print(bd)

if pos == 1:
    bcd = solve(-bd**2+d2**2+d3**2-2*d2*d3*cos(bcd), bcd)[0]
else:
    bcd = solve(-bd**2+d2**2+d3**2-2*d2*d3*cos(bcd), bcd)[1]

if pos == 1:
    bdk = solve(-bk**2+bd**2+dk**2-2*bd*dk*cos(bdk), bdk)[0]
else:
    bdk = solve(-bk**2+bd**2+dk**2-2*bd*dk*cos(bdk), bdk)[1]

if pos == 1:
    bdc = solve(-d2**2+d3**2+bd**2-2*d3*bd*cos(bdc), bdc)[0]
else:
    bdc = solve(-d2**2+d3**2+bd**2-2*d3*bd*cos(bdc), bdc)[1]
print(t3)
&lt;/pre&gt;

&lt;h3&gt;PLAP 三角形符號運算&lt;/h3&gt;
&lt;p&gt;已知 Point a, Lengeh ac, Angle cab, Point b, 求 c 點座標.&lt;/p&gt;
&lt;p&gt;利用 &lt;a href="http://solvespace.com/"&gt;Solvespace&lt;/a&gt; 繪製 2D 圖:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/fourbar_plap_solvespace.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;利用 &lt;a href="https://github.com/jupyterhub/jupyterhub"&gt;Jupyterhub&lt;/a&gt; 執行網際符號 (Symbolic) 與數值 (Numerical) 分析運算:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://fossies.org/linux/misc/sympy-docs-pdf-1.0.pdf"&gt;Sympy 1.0 手冊.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/fourbar_plap_sympy.png" width="800" /&gt;&lt;/p&gt;
&lt;h2&gt;PLAP 方程式推導&lt;/h2&gt;
&lt;p&gt;已知 Point a, Length ac, Angle bac 與 Point b, 求 c 點座標.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sympy.org/"&gt;Sympy&lt;/a&gt; 符號運算程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#PLAP
from sympy import symbols, sqrt, solve, cos, sin, Abs

# inputs
ax, ay, bx, by, bac, ac = symbols('ax ay bx by bac ac')
# intermediate variables
ab, dab = symbols('ab dab')
ad, bd = symbols('ad bd')
# outputs
cx, cy = symbols('cx cy')
# 從 a, b 點座標求 ab, ad 與 bd
ab = sqrt((ax-bx)**2+(ay-by)**2)
ad = Abs(bx-ax)
bd = Abs(by-ay)
data = solve(-bd**2+ad**2+ab**2-2*ad*ab*cos(dab), dab)
# 第1組解
dab = data[0]
cx = ax+ac*cos(dab+bac)
cy = ay+ac*sin(dab+bac)
print("cx=", cx, "cy=", cy)
# 第二組解
dab = data[1]
cx = ax+ac*cos(dab+bac)
cy = ay+ac*sin(dab+bac)
print("cx=", cx, "cy=", cy)
&lt;/pre&gt;

&lt;h2&gt;PLLP 方程式推導&lt;/h2&gt;
&lt;p&gt;已知 Point a, Length ac, Length cb 與 Point b, 求 c 點座標.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#PLLP
from sympy import symbols, sqrt, solve, cos, sin, Abs

# inputs
ax, ay, bx, by, ac, cb = symbols('ax ay bx by ac cb')
# intermediate variables
ab, dab, bac, degree= symbols('ab dab bac degree')
ad, bd = symbols('ad bd')
# outputs
cx, cy = symbols('cx cy')
# 從 a, b 點座標求 ab
ab = sqrt((ax-bx)**2+(ay-by)**2)
#從三角形已知三邊長, 求解 cx, cy
data = solve([ac**2-((ax-cx)**2+(ay-cy)**2), cb**2-((cx-bx)**2+(cy-by)**2)], [cx, cy])
# 第1組解
print("cx = ", data[0][0])
print("cy = ", data[0][1])
# 第2組解
print("cx = ", data[1][0])
print("cy = ", data[1][1])
&lt;/pre&gt;

&lt;p&gt;數值分析驗證程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from math import pi, cos, sin, sqrt, acos

radian = 180/pi
degree = pi/180

#PLAP
def plap(ax, ay, ac, bac, bx, by, pos):
    if pos == 0:
        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    else:
        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    return cx, cy

#PLLP
def pllp(ax, ay, ac, cb, bx, by, pos):
    if pos == 0:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    else:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    return cx, cy

ax = -60
ay = 0
bx = 0
by = 0
bac = 50*degree
ac = 30
cd = 50
db = 60
ce = 50
ed = 50
cx, cy = plap(ax, ay, ac, bac, bx, by, 0)
print("cx=", cx, "cy=", cy)
dx, dy = pllp(cx, cy, cd, db, bx, by, 0)
print("dx=", dx, "dy=", dy)
ex, ey = pllp(cx, cy, ce, ed, dx, dy, 0)
print("ex=", ex, "ey=", ey)
&lt;/pre&gt;

&lt;p&gt;結果:&lt;/p&gt;
&lt;p&gt;cx= -40.716371709403816 cy= 22.98133329356934&lt;/p&gt;
&lt;p&gt;dx= -6.698073034033397 dy= 59.62495968661744&lt;/p&gt;
&lt;p&gt;ex= -55.44153371488418 ey= 70.76385733649067&lt;/p&gt;
&lt;p&gt;上述符號運算式推導之方程式, 透過數值分析運算與下列圖解法進行比對驗證:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/fourbar_numerical.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://service.mde.tw/download/?type=files&amp;filename=fourbar_solvespace_numerical.7z"&gt;數值分析對應之 Solvespace 圖檔.7z&lt;/a&gt; (或 &lt;a href="./../data/fourbar_numerical_solvespace.7z"&gt;fourbar_numerical_solvespace.7z&lt;/a&gt;)&lt;/p&gt;
&lt;h2&gt;曲柄滑塊機構&lt;/h2&gt;
&lt;p&gt;曲柄滑塊機構:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/plpp_crank_slider.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;曲柄滑塊數值分析驗證:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/plpp_crank_slider_numerical.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;sol 0 符合上述曲柄滑塊圖中的 e 點座標.&lt;/p&gt;
&lt;h2&gt;PLPP 方程式推導&lt;/h2&gt;
&lt;p&gt;利用 sympy 推導 PLPP 方程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#PLPP
from sympy import symbols, sqrt, solve

# inputs
bx, by, be, cx, cy, dx, dy = symbols('bx by be cx cy dx dy')
# intermediate variables
cd, m= symbols('cd m')
# outputs
ex, ey = symbols('ex ey')
# e on line cd
cd = sqrt((cx-dx)**2+(cy-dy)**2)
m = (dx-cx)/(dy-cy)
data = solve([be-sqrt((bx-ex)**2+(by-ey)**2), ex-cx-m*(ey-cy)] ,  [ex, ey])
print(data)
&lt;/pre&gt;

&lt;p&gt;PLPP 數值分析驗證:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#plpp numerical
from math import sqrt

def plpp(bx, by, be, cx, cy, dx, dy, sol):
    data = [(((cx - dx)*(bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (-cy + dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2)) - (cx*dy - cy*dx)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2))/((cy - dy)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2)), (bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (-cy + dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2))/(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2)), (((cx - dx)*(bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (cy - dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2)) - (cx*dy - cy*dx)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2))/((cy - dy)*(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2)), (bx*cx*cy - bx*cx*dy - bx*cy*dx + bx*dx*dy + by*cy**2 - 2*by*cy*dy + by*dy**2 + cx**2*dy - cx*cy*dx - cx*dx*dy + cy*dx**2 + (cy - dy)*sqrt(be**2*cx**2 - 2*be**2*cx*dx + be**2*cy**2 - 2*be**2*cy*dy + be**2*dx**2 + be**2*dy**2 - bx**2*cy**2 + 2*bx**2*cy*dy - bx**2*dy**2 + 2*bx*by*cx*cy - 2*bx*by*cx*dy - 2*bx*by*cy*dx + 2*bx*by*dx*dy - 2*bx*cx*cy*dy + 2*bx*cx*dy**2 + 2*bx*cy**2*dx - 2*bx*cy*dx*dy - by**2*cx**2 + 2*by**2*cx*dx - by**2*dx**2 + 2*by*cx**2*dy - 2*by*cx*cy*dx - 2*by*cx*dx*dy + 2*by*cy*dx**2 - cx**2*dy**2 + 2*cx*cy*dx*dy - cy**2*dx**2))/(cx**2 - 2*cx*dx + cy**2 - 2*cy*dy + dx**2 + dy**2))]
    return data[sol]
for i in range(2):
    ex, ey = plpp(bx=-34.71, by=28.18, be=40, cx=0, cy=12, dx=10, dy=30, sol=i)
    print("sol", i, ": ex=", ex, "ey=", ey)
&lt;/pre&gt;

&lt;h2&gt;Jansen 多連桿機構運動模擬&lt;/h2&gt;
&lt;p&gt;下列多連桿機構 k 點座標可以利用上述 PLAP 與 PLLP 方程式疊代求得:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/jansen_sympy.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;數值分析求得:&lt;/p&gt;
&lt;p&gt;kx= -30.806349547073083 ky= -84.02289073817713&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/jansen_sympy_jypyter.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;Jansen 多連桿機構數值分析驗證程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from math import pi, cos, sin, sqrt, acos

radian = 180/pi
degree = pi/180

#PLAP
def plap(ax, ay, ac, bac, bx, by, ccw):
    if ccw == 1:
        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    else:
        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    return cx, cy

#PLLP
def pllp(ax, ay, ac, cb, bx, by, cw):
    if cw == 1:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    else:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    return cx, cy

ax = -38
ay = 0
# b 為原點
bx = 0
by = 0
cx = 0
cy = 7.8
# m 為配合 PLAP 新增固定點
mx = 30
my = 7.8
# dcm ccw 方向角度
dcm = 30*degree
cd = 15
# 三角形 dcm 為 ccw plap d=(a, cd, dcm, m)
dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1)
print("dx=", dx, "dy=", dy)
# 三角形 aed 為 cw pllp e=(a, ae, ed, d)
ae = 41.5
ed = 50
ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1)
print("ex=", ex, "ey=", ey)
# 三角形 afe 為 cw pllp f=(a, af, fe, e)
af = 40.1
fe = 55.8
fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1)
print("fx=", fx, "fy=", fy)
# 三角形 dha 為 cw pllp h=(d, dh, ha, a)
dh = 61.9
ha = 39.3
hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1)
print("hx=", hx, "hy=", hy)
# 三角形 hgf 為 cw pllp g=(h, hg, gf, f)
hg = 36.7
gf = 39.4
gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1)
print("gx=", gx, "gy=", gy)
# 三角形 hkg 為 cw pllp k=(h, hk, kg, g)
hk = 49
kg = 65.7
kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1)
print("kx=", kx, "ky=", ky)
&lt;/pre&gt;</summary><category term="brython"></category><category term="w1"></category></entry><entry><title>Fossil SCM 簡介</title><link href="./intro-fossil-scm.html" rel="alternate"></link><published>2017-02-17T11:00:00+08:00</published><updated>2017-02-17T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-02-17:./intro-fossil-scm.html</id><summary type="html">&lt;p&gt;Fossil SCM 是一套軟體配置管理 (Software Configuration Management) 系統, 其中包含分散式版次控管 (DVC, Distributed Version Control) 、&lt;a href="http://fossil-scm.org/xfer/doc/trunk/www/wikitheory.wiki"&gt;Wiki&lt;/a&gt; 、&lt;a href="http://fossil-scm.org/xfer/doc/trunk/www/bugtheory.wiki"&gt;Bug Tracking&lt;/a&gt; 與 &lt;a href="http://fossil-scm.org/xfer/doc/trunk/www/event.wiki"&gt;Technote&lt;/a&gt; 等功能, 可以用來控制及追蹤軟體開發專案, 並且紀錄專案開發歷程, 在協同產品設計實習課程中, 我們除了使用 git、github 與 bitbucket 之外, 將要在區域網路與系上主幹中, 配置每班兩台的 Fossil SCM 實習主機.&lt;/p&gt;


&lt;h2&gt;採用 git, github, bitbucket 與 fossil 原因&lt;/h2&gt;
&lt;p&gt;使用 git 原因 - git 是目前使用最廣泛的分散式版次管理工具.&lt;/p&gt;
&lt;p&gt;使用 github 原因 - github 是目前主流 git 網際服務系統, 允許無協同人數限制的免費倉儲協同, 提供 github pages 可以伺服 html 與 javascript 網頁.&lt;/p&gt;
&lt;p&gt;使用 bitbucket 原因 - bitbucket 允許使用者免費建立非公開型倉儲, 可採用 git 進行分散式版次管理.&lt;/p&gt;
&lt;p&gt;使用 fossil scm 原因 - fossil 工具精簡, 適合用於小團隊分散式版次管理, 提供網際 wiki, ticket, technote 等實用功能.&lt;/p&gt;
&lt;h2&gt;Fossil SCM&lt;/h2&gt;
&lt;h3&gt;Fossil Concepts&lt;/h3&gt;
&lt;p&gt;check-in - 簽入版本: 對所開發的軟體進行改版後, 簽入倉儲的版本, 稱為簽入版本.&lt;/p&gt;
&lt;p&gt;repository - 倉儲: 包含開發專案歷程中, 所有簽入版本檔案的資料庫, 稱為倉儲.&lt;/p&gt;
&lt;h3&gt;建立新倉儲&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;a href="http://fossil-scm.org/index.html/help?cmd=new"&gt;fossil new&lt;/a&gt; 或 &lt;a href="http://fossil-scm.org/index.html/help?cmd=init"&gt;fossil init&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建議使用 fossil init 建立新倉儲:&lt;/p&gt;
&lt;p&gt;fossil init foo.fossil&lt;/p&gt;
&lt;p&gt;表示建立一個新的倉儲專案, 且倉儲檔案名稱為 foo.fossil, 在 fossil SCM 中建立新專案時, 登入用戶名稱會成為內定的倉儲管理者, 若要指定管理者名稱, 可以附加 -A USERNAME 或 --admin-user USERNAME, 新增的倉儲就會以 USERNAME 作為管理者名稱, 且指定對應的密碼 (有關 &lt;a href="http://fossil-scm.org/xfer/doc/trunk/www/password.wiki"&gt;fossil 密碼管理&lt;/a&gt;), 當使用者在近端以網際模式啟動該倉儲時 (以 &lt;a href="http://fossil-scm.org/index.html/help?cmd=ui"&gt;fossil ui&lt;/a&gt; 指令) fossil SCM 會直接以管理者身份登入, 無需輸入管理者密碼.&lt;/p&gt;
&lt;h3&gt;以 sqlite3 擷取 .fossil 檔案內容&lt;/h3&gt;
&lt;p&gt;由於 fossil SCM 的倉儲格式為 Sqlite3 資料庫檔案, 因此利用 fossil init foo.fossil 建立倉儲後, 可以利用 sqlite3 工具查驗資料庫中的欄位資料.&lt;/p&gt;
&lt;p&gt;首先以 sqlite3 工具指令開啟 foo.fossil 資料庫檔案, 進入 sql 指令環境:&lt;/p&gt;
&lt;p&gt;sqlite3 foo.fossil&lt;/p&gt;
&lt;p&gt;接著以 .schema user 查詢 user 資料表的欄位名稱, 然後直接讀取資料表中 login, pw 與 info 欄位中的資料:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
.schema user
select login, pw, info from user;
&lt;/pre&gt;

&lt;p&gt;其中可以發現 fossil SCM 已經使用 SHA1 hash 編碼使用者帳號對應的登入密碼, 但是當使用者 &lt;a href="http://fossil-scm.org/index.html/help?cmd=clone"&gt;fossil clone&lt;/a&gt; 遠端倉儲到近端時, fossil SCM 會自動以明碼設定倉儲原管理者對應的管理密碼, 且在 fossil clone 結束後, 直接顯示在命令列視窗中 .&lt;/p&gt;
&lt;h3&gt;以 fossil sql 指令擷取 .fossil 檔案內容&lt;/h3&gt;
&lt;p&gt;使用者以 fossil init foo.fossil 建立倉儲檔案後, 除了使用 sqlite3 命令檢視 fossil 倉儲內容外, 也可以利用 fossil 指令查驗倉儲資料庫檔案的內容.&lt;/p&gt;
&lt;p&gt;fossil sql -R foo.fossil&lt;/p&gt;
&lt;p&gt;進入 sqlite 指令環境後, 可以利用 .schema user 查驗 user 資料表的欄位設計.&lt;/p&gt;
&lt;p&gt;以 select login, pw, cap from user;&lt;/p&gt;
&lt;p&gt;可以查詢目前 foo.fossil 檔案中 user 資料表 login, pw 與 cap 等3個欄位的資料內容.&lt;/p&gt;
&lt;p&gt;若要更改特定 login 登入帳號的 pw 或 cap 可以使用下列 sqlite3 SQL 語法:&lt;/p&gt;
&lt;p&gt;update user set pw='mynewpassword' where login='myloginaccount';&lt;/p&gt;
&lt;p&gt;update user set cap='s' where login='myloginaccount';&lt;/p&gt;
&lt;h3&gt;clone&lt;/h3&gt;
&lt;pre class="brush: jscript"&gt;
$ fossil clone http://your_domain_name ~/fossils/yourdb.fossil
$ fossil open ~/fossils/foo.fossil
&lt;/pre&gt;

&lt;p&gt;上述 fossil 指令表示要從 http://your_domain_name fossil 伺服器中, clone 倉儲檔案, 然後存在近端的 ~/fossils/yourdb.fossil 檔案中.&lt;/p&gt;
&lt;p&gt;接下來則可以選擇適當的目錄, 以 fossil open 將 .fossil 檔案解開, 此所在目錄即為該 .fossil 倉儲的 近端工作目錄.&lt;/p&gt;
&lt;h3&gt;add a file&lt;/h3&gt;
&lt;pre class="brush: jscript"&gt;
$ fossil add yourfile.txt
&lt;/pre&gt;

&lt;p&gt;在上述解開的 .fossil 倉儲對應工作目錄中, 一旦完成 yourfile.txt 的編輯, 可以利用 fossil add 將此檔案納入版次管理.&lt;/p&gt;
&lt;p&gt;另外, 使用者必須注意的是, Fossil SCM 設定中, 內定的 autosync 為 on, 表示使用者一旦在工作目錄中 fossil add 與 fossil commit 之後, Fossil 會自動執行後續 fossil push 的動作, 而且此一推送會同時將改版資料送到近端與工作目錄對應的 .fossil 檔案倉儲外, 也會同時將改版資料推送到 .fossil 對應的遠端倉儲中.&lt;/p&gt;
&lt;p&gt;換言之, Fossil SCM 針對從 fossil clone 開始的一連串指令執行, 會因為  settings 的差異而有不同的新增, 提交與推送流程, 假如 fossil clone 之後, 在近端以 fossil open 解開到近端工作目錄後, 並非以原 fossil 倉儲內建 autosync 綁定的使用者進行提交推送時, 必須透過 fossil remote-url off 切斷內建倉儲與工作目錄綁定的內建用戶資料, 然後在提交後, 以手動執行 fossil push.&lt;/p&gt;
&lt;p&gt;fossil push https://usesid@fossil_server_url&lt;/p&gt;
&lt;p&gt;git 分支流程模型&lt;/p&gt;
&lt;p&gt;&lt;a href="http://nvie.com/posts/a-successful-git-branching-model/"&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Fossil SCM concept&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.fossil-scm.org/xfer/doc/tip/www/concepts.wiki"&gt;https://www.fossil-scm.org/xfer/doc/tip/www/concepts.wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Why Fossil SCM?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;單一檔案工具與單一檔案倉儲上的簡單便捷&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版本倉儲 (repository) 可以不在工作目錄 (working directory) 中, 因此使用者可以從同一個版本倉儲, 在不同目錄中, 簽出多個版本的工作空間, 因此具有伺服器版本控制系統 (server vcs) 與分散式版次控制系統 (dvcs) 的彈性與優點.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;開發歷程不可變更 (因為不提供 rebase 功能), 是優點, 也是許多人認為的缺點.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小團隊更適合使用 Fossil SCM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;內建網際伺服器支援團隊間的協同合作, 不僅內建提供 wiki, blog, issue tracking, 而且可以在近端修改這些工具所管理的內容後, 提交推送到遠端.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺乏 submodule (而是採 nested path 呈現), rebase 與 code review 整合功能&lt;/p&gt;
&lt;h3&gt;git to fossil:&lt;/h3&gt;
&lt;pre class="brush: jscript"&gt;
cd git-repo
git fast-export --all | fossil import --git new-repo.fossil
&lt;/pre&gt;

&lt;h3&gt;fossil to git:&lt;/h3&gt;
&lt;pre class="brush: jscript"&gt;
git init new-repo
cd new-repo
fossil export --git ../repo.fossil | git fast-import
&lt;/pre&gt;

&lt;h3&gt;fossil 與 git 雙向同步:&lt;/h3&gt;
&lt;p&gt;Bidirectional Synchronization&lt;/p&gt;
&lt;p&gt;Fossil also has the ability to synchronize with a Git repository via repeated imports and/or exports. To do this, it uses marks files to store a record of artifacts which are known by both Git and Fossil to exist at a given point in time.&lt;/p&gt;
&lt;p&gt;To illustrate, consider the example of a remote Fossil repository that a user wants to import into a local Git repository. First, the user would clone the remote repository and import it into a new Git repository:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
fossil clone /path/to/remote/repo.fossil repo.fossil
mkdir repo
cd repo
fossil open ../repo.fossil
mkdir ../repo.git
cd ../repo.git
git init .
fossil export --git --export-marks ../repo/fossil.marks  \
       ../repo.fossil | git fast-import                  \
       --export-marks=../repo/git.marks
&lt;/pre&gt;

&lt;p&gt;Once the import has completed, the user would need to git checkout trunk. At any point after this, new changes can be imported from the remote Fossil repository:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
cd ../repo
fossil pull
cd ../repo.git
fossil export --git --import-marks ../repo/fossil.marks  \
       --export-marks ../repo/fossil.marks               \
       ../repo.fossil | git fast-import                  \
       --import-marks=../repo/git.marks                  \
       --export-marks=../repo/git.marks
&lt;/pre&gt;

&lt;p&gt;Changes in the Git repository can be exported to the Fossil repository and then pushed to the remote:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
git fast-export --import-marks=../repo/git.marks                  \
    --export-marks=../repo/git.marks --all | fossil import --git  \
    --incremental --import-marks ../repo/fossil.marks             \
    --export-marks ../repo/fossil.marks ../repo.fossil
cd ../repo
fossil push
&lt;/pre&gt;

&lt;h2&gt;Fossil SCM 一般操作&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.gaia-gis.it/gaia-sins/about-fossil.html"&gt;http://www.gaia-gis.it/gaia-sins/about-fossil.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;fossil clone https://www.gaia-gis.it/fossil/librasterlite \
    librasterlite.fossil&lt;/p&gt;
&lt;p&gt;或者 &lt;/p&gt;
&lt;p&gt;fossil clone https://user:password@www.gaia-gis.it/fossil/librasterlite \
    librasterlite.fossil&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;將倉儲內容開啟, 放入工作目錄中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="brush: jscript"&gt;
$ mkdir librasterlite
$ cd librasterlite
$ fossil open ../librasterlite.fossil
&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;對工作目錄中的檔案改版後, 查詢改版情形&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;fossil status&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;選擇編輯器, 提交版本至遠端倉儲後關閉&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="brush: jscript"&gt;
$ export "EDITOR=vi"
$ fossil commit
$ fossil close
&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;其他 Fossil SCM 指令: &lt;a href="http://fossil-scm.org/index.html/help"&gt;http://fossil-scm.org/index.html/help&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Fossil SCM 特色:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Integrated Bug Tracking, Wiki, and Technotes&lt;/li&gt;
&lt;li&gt;Built-In Web Interface&lt;/li&gt;
&lt;li&gt;Self-Contained&lt;/li&gt;
&lt;li&gt;Simple Networking&lt;/li&gt;
&lt;li&gt;CGI/SCGI Enabled&lt;/li&gt;
&lt;li&gt;Autosync&lt;/li&gt;
&lt;li&gt;Robust &amp;amp; Reliable&lt;/li&gt;
&lt;li&gt;Free and Open-Source&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Fossil (4 MB) 只需要 zlib 與 stunnel (4MB), 就可以充分使用, 但是 git 則需要許多程式庫與套件才能執行 (200 MB)&lt;/p&gt;
&lt;h2&gt;參考資料&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.fredshack.com/docs/fossil.html"&gt;http://www.fredshack.com/docs/fossil.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Fossil SCM 與 Stunnel 啟動整合&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://service.mde.tw/public/tiny2017_1GB.7z"&gt;下載&lt;/a&gt; tiny2017 可攜程式系統之後, 可以利用下列 start.bat, 在 Windows 環境中自動擷取電腦連外 IP, 自動設定 stunnel.conf 後, 以 https 協定啟動 Fossil SCM 伺服器.&lt;/p&gt;
&lt;p&gt;利用下列 start.bat 所啟動的 fossil server 位於 y:\tmp\fossil_repo\vcp.fossil 倉儲:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
REM tiny2017 主要針對初學 Python3 與 C 學員所建立
REM 近端使用 fossil 管理資料版本, 並且定時轉為 git 格式後上傳到 github
@echo off
REM 設定 y 硬碟代號與 data 目錄對應
set Disk=y
subst %Disk%: "data"
REM 設定 leo 相關對應 Home 位置
set HomePath=%Disk%:\home
set HomeDrive=%Disk%:\home
set Home=%Disk%:\home
REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"
REM 將後續的指令執行, 以 %Disk% 為主
%Disk%:
REM 設定 PYTHONPATH
set PYTHONPATH=%Disk%:\python-3.5.3-embed-amd64
REM 設定 Leo 所用的編輯器
set LEO_EDITOR=%Disk%:\wscite\SciTE.exe
REM for fossil https 連線設定
set HTTPS=on
REM 指令搜尋路徑設定
set path1=%PATH%;%Disk%:;%Disk%:\python-3.5.3-embed-amd64;%Disk%:\git\bin;%Disk%:\stunnel\bin;%Disk%:\sqlite-tools;%Disk%:\python-3.5.3-embed-amd64\Scripts;%Disk%:\portablegit\bin;
set path2=c:\Windows\Microsoft.NET\Framework\v3.5;%Disk%:\python-3.5.3-embed-amd64\Lib\site-packages;
set path3="C:\Program Files (x86)\Google\Chrome\Application"
path=%path%;%path1%;%path2%;%path3%
start /MIN %Disk%:\wscite\SciTE.exe
start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe
REM 啟動 Leo 編輯器
REM %Disk%:\Miniconda3\python.exe %Disk%:\apps\launchLeo.py
REM 啟動 stunnel
start /MIN fossil.exe server -P 127.0.0.1:8080 %Disk%:\tmp\fossil_repo\vcp.fossil
REM 取得電腦 IP, 然後設定 %Disk%:/stunnel/config/stunnel.conf
for /f "delims=[] tokens=2" %%a in ('ping -4 -n 1 %ComputerName% ^| findstr [') do set NetworkIP=%%a
REM echo Network IP: %NetworkIP%
REM Saved in %Disk%:\stunnel\config\stunnel.conf
@echo off
REM 建立 stunnel.conf
@echo [https] &gt; %Disk%:\stunnel\config\stunnel.conf
REM 附加資料
@echo accept = %NetworkIP%:443 &gt;&gt; %Disk%:\stunnel\config\stunnel.conf
@echo connect = 127.0.0.1:8080 &gt;&gt; %Disk%:\stunnel\config\stunnel.conf
@echo TIMEOUTclose = 0 &gt;&gt; %Disk%:\stunnel\config\stunnel.conf
@echo cert = %Disk%:\stunnel\config\localhost.crt &gt;&gt; %Disk%:\stunnel\config\stunnel.conf
@echo key = %Disk%:\stunnel\config\localhost.key &gt;&gt; %Disk%:\stunnel\config\stunnel.conf
REM 啟動 stunnel
start /MIN stunnel.exe
REM set proxy
REG IMPORT setup_proxy.reg
REM 以 chrome 連線到 https://%NetworkIP%:443
REM chrome  --proxy-server="140.130.17.17:3128" --proxy-bypass-list="192.168.1.*;*.edu.tw" https://%NetworkIP%
chrome https://%NetworkIP% http://mde.tw https://mde2a1.kmol.info https://mde2a2.kmol.info https://vimeo.com/user24079973 http://mde.tw/2017springcd/blog/ http://mde.tw/2017springwcm/blog/ http://mde.tw/2017springvcp/blog/ http://service.mde.tw
Exit
&lt;/pre&gt;

&lt;p&gt;setup_proxy.reg 設定  Windows proxy 組態檔案:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings] 
"MigrateProxy"=dword:00000001 
"ProxyEnable"=dword:00000001 
"ProxyHttp1.1"=dword:00000000 
"ProxyServer"="http://140.130.17.17:3128" 
"ProxyOverride"="192.168.1.*;*.edu.tw"
&lt;/pre&gt;

&lt;p&gt;disable_proxy.reg 去除 Windows proxy 設定組態檔案:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings] 
"ProxyEnable"=dword:00000000
&lt;/pre&gt;

&lt;p&gt;與上述設定對應的 stop.bat:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
@echo off
set Disk=y
REM 關閉 SciTE
taskkill /IM SciTE.exe /F
REM 關閉 python
taskkill /IM python.exe /F
REM 關閉 stunnel
taskkill /IM stunnel.exe /F
REM 關閉 fossil
taskkill /IM fossil.exe /F
REM 關閉 cmd 指令視窗
taskkill /IM cmd.exe /F
REM disable proxy
%Disk%:
REG IMPORT disable_proxy.reg
REM 清除 log 資料
path=%PATH%;
REM del /Q /F  V:\tmp\*.*
REM 終止虛擬硬碟與目錄的對應
subst %Disk%: /D
REM taskkill /IM mingw32 /F
EXIT
&lt;/pre&gt;

&lt;h2&gt;編譯 sqlite3&lt;/h2&gt;
&lt;p&gt;cc -O3 -DSQLITE_THREADSAFE=0 sqlite3.c shell.c -ldl -o sqlite3&lt;/p&gt;
&lt;h2&gt;fossil clone 指令&lt;/h2&gt;
&lt;p&gt;fossil clone https://userid@mde2a2.kmol.info/cdag1 cdag1.fossil&lt;/p&gt;
&lt;p&gt;接著輸入與 userid 對應的密碼&lt;/p&gt;
&lt;p&gt;If you already have a username and password on the remote repository, you may introduce it in the URL:&lt;/p&gt;
&lt;p&gt;$ fossil clone https://userid:password@mde2a2.kmol.info/cdag1  cdag1.fossil&lt;/p&gt;
&lt;h2&gt;fossil push 指令&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.fossil-scm.org/xfer/help?cmd=remote-url"&gt;fossil remote-url off&lt;/a&gt; 之後, 或 autosync&lt;/p&gt;
&lt;p&gt;fossil push https://userid@mde2a2.kmol.info/cdag1&lt;/p&gt;
&lt;p&gt;接著輸入與 userid 對應的密碼&lt;/p&gt;
&lt;p&gt;&lt;a href="http://brandon.invergo.net/news/2013-07-11-A-quick-introduction-to-version-control-with-Fossil.html"&gt;http://brandon.invergo.net/news/2013-07-11-A-quick-introduction-to-version-control-with-Fossil.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;實際利用 cmsimfly 倉儲操作&lt;/h2&gt;
&lt;p&gt;fossil clone https://mde2a2.kmol.info/cmsimfly/ cmsimfly.fossil&lt;/p&gt;
&lt;p&gt;cd wd&lt;/p&gt;
&lt;p&gt;fossil open ./../cmsimfly.fossil&lt;/p&gt;
&lt;p&gt;利用 Leo Editor, 進行內容改版.&lt;/p&gt;
&lt;p&gt;以遞迴方式納入全部的變更.&lt;/p&gt;
&lt;p&gt;fossil add .&lt;/p&gt;
&lt;p&gt;假如 fossil clone 後綁定 scrum1 以外的用戶帳號, 利用 fossil remote-url off 切斷此一綁定.&lt;/p&gt;
&lt;p&gt;fossil remote-url off&lt;/p&gt;
&lt;p&gt;以 fossil commit 進行提交, 並確認綁定 scrum1 帳號.&lt;/p&gt;
&lt;p&gt;fossil commit --user-override scrum1  -m "commit message" &lt;/p&gt;
&lt;p&gt;內容 fossil commit 將會同時 fossil push 版本到 remote url.&lt;/p&gt;
&lt;p&gt;假如 autosync 設為 off, 則以下列指令進行 fossil push.&lt;/p&gt;
&lt;p&gt;fossil push https://scrum1@mde2a2.kmol.info/cmsimfly&lt;/p&gt;
&lt;p&gt;輸入 scrum1 的對應密碼後完成版本推送.&lt;/p&gt;
&lt;p&gt;在 Fossil SCM 系統上的 &lt;a href="https://mde2a2.kmol.info/cmsimfly/dir?ci=tip"&gt;CMSimfly 倉儲&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;實際操作範例&lt;/h2&gt;
&lt;h3&gt;從遠端 clone 倉儲&lt;/h3&gt;
&lt;p&gt;fossil clone https://userid:password@mde2a2.kmol.info/cmsimfly cmsimfly.fossil&lt;/p&gt;
&lt;p&gt;在當下目錄中解開最新的 cmsimfly.fossil 倉儲版本, fossil 仍會指定近端對應帳號的密碼&lt;/p&gt;
&lt;h3&gt;在近端建立工作目錄&lt;/h3&gt;
&lt;p&gt;fossil open cmsimfly.fossil&lt;/p&gt;
&lt;p&gt;對 cmsimfly 倉儲中的內容改版後, 納入所有的變更&lt;/p&gt;
&lt;p&gt;fossil add .&lt;/p&gt;
&lt;p&gt;若 autosync 仍為 on, 則 fossil commit -m 後, 會同時 fossil push&lt;/p&gt;
&lt;p&gt;fossil commit -m "message"&lt;/p&gt;
&lt;p&gt;假如近端工作目錄需要從 remote url 中取下近端沒有的改版內容, 使用 fossil update&lt;/p&gt;
&lt;p&gt;fossil update&lt;/p&gt;
&lt;h3&gt;fossil 改版工作流程&lt;/h3&gt;
&lt;p&gt;若以 fossil clone https://userid@mde2a2.kmol.info/cmsimfly cmsimfly.fossil&lt;/p&gt;
&lt;p&gt;輸入 userid 在 https://mde2a2.kmol.info/cmsimfly 倉儲中的對應密碼.&lt;/p&gt;
&lt;p&gt;則隨後都將以 userid 為主體進行改版, 若密碼存在近端, 則可以直接改版後 fossil commim -m, 讓 autosync 將內容 push 到遠端&lt;/p&gt;
&lt;p&gt;若在 fossil clone 時沒有指定帳號密碼, 則將取得第一個內建管理者帳號對應之工作環境, 若之後要採用其他帳號提交, 必須先以 fossil remote-url off 切斷目前的連結, 當 fossil commit --user-override another_userid -m 之後, 以手動進行 fossil push https://another_userid@mde2a2.kmol.info/cmsimfly&lt;/p&gt;
&lt;p&gt;輸入 another_userid 在 https://mde2a2.kmol.info/cmsimfly 倉儲中的對應密碼後, 即可完成改版推送.&lt;/p&gt;
&lt;h3&gt;fossil branch&lt;/h3&gt;
&lt;p&gt;[http://fossil-scm.org/xfer/doc/trunk/www/branching.wiki]&lt;/p&gt;
&lt;h3&gt;衝突處理&lt;/h3&gt;
&lt;p&gt;當使用者利用 autosync on 且以 fossil commit -m 進行改版提交時, fossil 會回復 would fork. "update first or use --alow-fork&lt;/p&gt;
&lt;p&gt;表示使用者有兩個選擇, 可以在提交後面加上 --alow-fork 從上一個版本長出另外一個 leaf, 也就是建立 fork 版本, 而讓原本產生衝突的版本成為另外一個 leaf.&lt;/p&gt;
&lt;p&gt;或者可以使用 fossil update 拉回遠端的版本. 接著 fossil 發現版本內容有衝突, 會顯示&lt;/p&gt;
&lt;p&gt;WARNing: 1 merge conflicts. 並且說明可以用 fossil undo 除去 fossil update 所拉回的版本內容.&lt;/p&gt;
&lt;p&gt;以下為 README.md 檔案中註記衝突的範例:&lt;/p&gt;
&lt;pre class="brush:jscript"&gt;
# cmsimfly
CMSimfly is a simple CMS in Flask

此一版本以 Fossil SCM 進行管理

透過 Wiindows 7 進行改版
&lt;&lt;&lt;&lt;&lt;&lt;&lt; BEGIN MERGE CONFLICT: local copy shown first &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

故意造成衝突
======= COMMON ANCESTOR content follows ============================
======= MERGED IN content follows ==================================

在 Windows 10 中改版&gt;&gt;&gt;&gt;&gt;&gt;&gt; END MERGE CONFLICT &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&lt;/pre&gt;

&lt;p&gt;操作者必須手動決定要保留兩個版本內容, 或者取其中一版的內容.&lt;/p&gt;
&lt;p&gt;因為衝突產生時, fossil update 拉回衝突內容時會同時新增 -original -baseline -merge 等3個檔案, 若希望使用 fossil add . 新增所有改版內容, 但不要納入某些目錄中的檔案, 可以在 web 介面中的 settings 中的 ignore-glob 中進行註記, 若設定 ignore-glob 後仍希望新增所有改版內容 (包括 ignore-glob 中的註記檔), 則使用 fossil add &lt;em&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Fossil SCM Server 基本設定&lt;/h2&gt;
&lt;p&gt;當在 Windows 中以 fossil server, Ubuntu 中以 fossil http 啟動伺服器之後, 首先要在網際介面中以管理者登入, 並在 Admin-Configuration 或 setup_config 中設定 Project Name.&lt;/p&gt;
&lt;p&gt;接著則在 Wiki 中建立與 Project Name 相同名稱的首頁 wiki.&lt;/p&gt;
&lt;p&gt;之後利用 Admin-Users 建立其他用戶.&lt;/p&gt;
&lt;p&gt;假如要修改 Fossil Server 的整體外觀, 利用  Admin-Skins, 可以透過其中的 Headers 增加客製化的內容連結表單.&lt;/p&gt;
&lt;p&gt;假如要在 Wiki 頁面中使用較為保守安全的超連結, 編輯時選用 Fossil Wiki 格式, 若要納入 iframe 標註, 則可以改用 Markdown 格式, 若確認各用戶對於網際架構安全有一定認知, 則可以透過 Admin-Configuration 中, 勾選 Use HTML as wiki markup language, 則可以支援全部的 html 語法內容, 包括各式的 Javascript 內容.&lt;/p&gt;
&lt;h3&gt;純 IPv6 環境下的 Fossil Server&lt;/h3&gt;
&lt;p&gt;針對只採用 IPv6 協定上網的電腦中啟動 Fossil Server, 使用者可以使用 ssh 協定執行 &lt;a href="https://www.fossil-scm.org/xfer/help/clone"&gt;fossil clone&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;例如: ipv6.only.server domain 所屬的伺服器, 其操作系統僅啟用 IPv6 協定上網, 建立 Fossil Server 的模式與 IPv4 上網的伺服器相同, 但是, fossil clone 的指令則可採用 ssh 協定下的絕對倉儲路徑或相對倉儲路徑擷取遠端的倉儲檔案:&lt;/p&gt;
&lt;p&gt;以絕對倉儲路徑 fossil clone:&lt;/p&gt;
&lt;p&gt;假設 IPv6 主機上的 target.fossil 倉儲檔案位於 /home/account/repository/target.fossil, 則使用者可以利用:&lt;/p&gt;
&lt;p&gt;fossil clone ssh://account@your_ipv6_only_server_url//home/account/repository/target.fossil cloned.fossil&lt;/p&gt;
&lt;p&gt;將遠端的 target.fossil 複製到近端存為 cloned.fossil 檔案, 其中特別注意到絕對路徑在 server_url 後面必須有兩個斜線.&lt;/p&gt;
&lt;p&gt;以相對倉儲路徑 fossil clone:&lt;/p&gt;
&lt;p&gt;此時假設 Fossil Server 是以 /home/account 用戶啟動, 則使用者可以利用:&lt;/p&gt;
&lt;p&gt;fossil clone ssh://account@your_ipv6_only_server_url/repository/target.fossil cloned.fossil&lt;/p&gt;
&lt;p&gt;將遠端的 target.fossil 複製到近端存為 cloned.fossil 檔案, 其中特別注意到, 相對路徑除了在 server_url 後只需一個斜線, 且是以 /home/account 目錄作為相對目錄的根目錄, 使用者必須加入 /repository/target.fossil, 才能正確擷取到倉儲檔案.&lt;/p&gt;
&lt;p&gt;上述兩種 fossil clone 指令執行後, 系統會要求輸入與 account 用戶對應的 Fossil Server 密碼, 完成後就可以將遠端的倉儲檔複製到近端.&lt;/p&gt;
&lt;p&gt;附帶說明: 截至 fossil 2.2 版, 以 ssh 協定可以 fossil clone 遠端純 IPv6 主機上的倉儲, 但是卻無法以 fossil autosync 或 fossil push 將近端的版本提交推送到遠端. 因此目前的 Fossil Server 仍建議採用 IPv4/IPv6 並存的方式建立.&lt;/p&gt;</summary><category term="fossil-scm"></category><category term="w2"></category></entry><entry><title>V-rep 簡介</title><link href="./vrep-introduction.html" rel="alternate"></link><published>2017-02-09T11:00:00+08:00</published><updated>2017-02-09T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-02-09:./vrep-introduction.html</id><summary type="html">&lt;p&gt;V-rep (Virtual robot experimentation platform)&lt;/p&gt;


&lt;h2&gt;V-rep Overview&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/assets/v-repoverviewpresentation.pdf"&gt;http://www.coppeliarobotics.com/assets/v-repoverviewpresentation.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;V-rep Licenses&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/assets/v-replicensingoverview.pdf"&gt;http://www.coppeliarobotics.com/assets/v-replicensingoverview.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;User Settings:&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/settings.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/settings.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Scene&lt;/h2&gt;
&lt;p&gt;.ttt&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/scenes.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/scenes.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Each scene in V-REP has eight freely configurable pages. Individual pages can be accessed (i.e. displayed) through the page selector toolbar button:&lt;/p&gt;
&lt;h2&gt;Model&lt;/h2&gt;
&lt;p&gt;.ttm&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/models.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/models.htm&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Build clean model&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Shapes:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/shapes.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/shapes.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Object common properties:&lt;/p&gt;
&lt;p&gt;Selectable: indicates whether the object can be selected in the scene. Objects can always be selected in the scene hierarchy. Refer also to the simSetObjectProperty function.&lt;/p&gt;
&lt;p&gt;Invisible during selection: when enabled, then the object will be invisible for the selection process (i.e. you will be able to select through the object).&lt;/p&gt;
&lt;p&gt;Ignored by depth pass: when enabled, then the object will be ignored during the depth rendering pass. The depth rendering pass is used to correctly position the red sphere for camera movements.&lt;/p&gt;
&lt;p&gt;Select base of model instead: if enabled, then selecting the object in the scene will select its first parented object marked as object is model base instead (see further down). This property is convenient when protecting a model from faulty manipulations, allowing it to be manipulated as a single entity together with other objects. Refer to the section on models and also to the simSetObjectProperty function. &lt;/p&gt;
&lt;p&gt;Don't show as inside model selection: when selected, and the object is part of a model, then the model bounding box (i.e. model selection bounding box) will not encompass that object. This is useful for invisible objects that might make the model bounding box appear too big. This property has no functional effect. Refer also to the simSetObjectProperty function.&lt;/p&gt;
&lt;p&gt;Size factor: every object can be scaled (resized) at any time, also during simulation. The size factor will be scaled in a similar way and can be accessed programmatically in order to adjust a code's behavior (e.g. child script). Imagine a 2-wheeled kinematic robot whose movement is controlled in a simple way through a &lt;/p&gt;
&lt;p&gt;child script: the child script will calculate the new position of the robot according to several parameters (wheel rotation velocity, wheel diameter and distance between the two wheels). If the user scales the robot, the child script should adjust its calculation according to the new size parameters (wheel diameter and distance between the two wheels). It can do that by using the simGetObjectSizeFactor API function.&lt;/p&gt;
&lt;p&gt;Ignored for view-fitting: objects with this item selected will not be taken into account when fitting a scene to a view while no object is selected. Usually floors and similar will be tagged as such. Refer also to the view fitting toolbar button and to the simCameraFitToView api function.&lt;/p&gt;
&lt;p&gt;Extension string: a string that describes additional object properties, mainly used by extension plugins (see also the simGetExtensionString API function).&lt;/p&gt;
&lt;p&gt;Camera visibility layers: each object in V-REP can be assigned to one or several visibility layers. If there is at least one visibility layer that matches the layer selection dialog layers, then the object will be visible when seen from a camera. By default, a shape is assigned to the first layer, a joint to the second layer, a dummy to the third layer, etc.&lt;/p&gt;
&lt;p&gt;Can be seen by: allows to specify a camera or vision sensor (or a collection containing cameras or vision sensors) that will be the only one able to see the object.&lt;/p&gt;
&lt;p&gt;Collidable: allows enabling or disabling collision detection capability for the selected collidable object.&lt;/p&gt;
&lt;p&gt;Measurable: allows enabling or disabling minimum distance calculation capability for the selected measurable object.&lt;/p&gt;
&lt;p&gt;Detectable: allows enabling or disabling proximity sensor detection capability for the selected detectable object. Clicking details allows you to edit the detectable details.
Renderable: allows enabling or disabling the vision sensor detection capability for the selected renderable object.&lt;/p&gt;
&lt;p&gt;Cuttable: allows enabling or disabling the mill cutting capability for the selected cuttable object.&lt;/p&gt;
&lt;p&gt;Object is model base: indicates whether the object should act as the base of a model. An object flagged as base of model has special properties (e.g. saving or copying the object will also automatically save/copy all its children and children's children, etc.). Additionally, when such an object is selected, the selection bounding box is displayed as thick stippled lines, encompassing the whole model. Refer to models, and to the select base of model instead item above.&lt;/p&gt;
&lt;p&gt;Edit model properties: allows opening the model dialog.
Object / model can transfer or accept DNA: when this feature is enabled for an object or a model, then it will share a same identifier with all of its copies. An Object or model can then transfer its DNA (i.e. copy an instance of itself) to all of its siblings (i.e. objects/models with the same identifier), via the transfer DNA toolbar button. Imagine having 100 same robots in your scene that you want to modify in a similar way: simply modify one of them, select it, then click the transfer DNA toolbar button. This item should almost always be checked for a model base (see further up), to facilitate model re-instanciation.&lt;/p&gt;
&lt;p&gt;Main script:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/mainScript.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/mainScript.htm&lt;/a&gt;editor&lt;/p&gt;
&lt;p&gt;Child scripts:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/childScripts.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/childScripts.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Joints&lt;/h2&gt;
&lt;p&gt;Dynamically enabled joints are joints that are in force or torque mode or that operate in hybrid fashion, and that have a shape as parent object and exactly one child object which must be a non-static shape. In addition, it is possible to involve a joint in a loop closure configuration. In that case the joint has to connect to the two shapes through a dummy-dummy link (where the link type has to be Dynamics, overlap constraint). &lt;/p&gt;
&lt;p&gt;Joint properties:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/jointProperties.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/jointProperties.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Joint dynamic properties:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/jointDynamicsProperties.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/jointDynamicsProperties.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Joint control callback functions:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/jointCtrlCallbackScripts.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/jointCtrlCallbackScripts.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用 Python remote API 設定 Joints 變數:&lt;/p&gt;
&lt;p&gt;For the simxSetJointPosition function to work, the joint should not be in force/torque mode. If the joint is in force/torque mode, the motor enabled, and the position control enabled, then use the simxSetJointTargetPosition instead. Also make sure the joint is dynamically enabled.&lt;/p&gt;
&lt;p&gt;參考程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
try:
    import vrep
except:
    print ('--------------------------------------------------------------')

import time


def connectVREP():
  vrep.simxFinish(-1) # just in case, close all opened connections
  clientID=vrep.simxStart('127.0.0.1',19999,True,True,5000,5) # Connect to V-REP
  if clientID!=-1:
    print ('Connected Remote Api')
    vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot_wait)

    vrep.simxSynchronous(clientID,True)
    return clientID
  else:
    print ('ERROR! Error connecting Remote Api')
    sys.exit(0);

def startSim(clientID):
  vrep.simxStartSimulation(clientID,vrep.simx_opmode_oneshot)

def stopSim(clientID):
  vrep.simxStopSimulation(clientID,vrep.simx_opmode_oneshot_wait)

def disconnectVREP(clientID):
  # Now close the connection to V-REP:
  vrep.simxFinish(clientID)
  print('Connection finished')


clientID=connectVREP()


ret,joint1_handler = vrep.simxGetObjectHandle(\
  clientID,"redundantRob_joint1",vrep.simx_opmode_oneshot_wait)
ret,joint1 = vrep.simxGetJointPosition(\
  clientID,joint1_handler,vrep.simx_opmode_streaming)

ret,joint2_handler = vrep.simxGetObjectHandle(\
  clientID,"redundantRob_joint2",vrep.simx_opmode_oneshot_wait)
ret,joint2 = vrep.simxGetJointPosition(\
  clientID,joint2_handler,vrep.simx_opmode_streaming)

startSim(clientID)

ret,joint1 = vrep.simxGetJointPosition(\
  clientID,joint1_handler,vrep.simx_opmode_buffer)
print joint1  #Get position joint 1
ret,joint2 = vrep.simxGetJointPosition(\
  clientID,joint2_handler,vrep.simx_opmode_buffer)
print joint2 #Get position joint 2

ret = vrep.simxSetJointPosition(\
  clientID,joint1_handler,pi/2,vrep.simx_opmode_oneshot)  #Set pi/2 to joint 1

time.sleep(2)

stopSim(clientID)

time.sleep(1)

disconnectVREP(clientID)       
&lt;/pre&gt;

&lt;p&gt;利用 remote API 執行緒程式設定 Joint 變數:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import threading
import time
import sys
import traceback

sys.path.insert(0, 'C:\\Program Files\\V-REP3\\V-REP_PRO_EDU\\programming\\Python')
import vrep

class Joint(threading.Thread):
    def __init__(self, joint_name, port):
        threading.Thread.__init__(self)
        self.client_id = -1
        self.port = port
        self.joint_name = joint_name

    def run(self):
        try:
            # connect to V-REP server
            self.client_id = vrep.simxStart("127.0.0.1", self.port, False, True, 5000, 5)
            if self.client_id == -1:
                raise Exception('Failed to connect V-REP remote API server.')

            # get handle
            res, p = vrep.simxGetObjectHandle(self.client_id, self.joint_name.encode(), vrep.simx_opmode_oneshot_wait)
            if res == vrep.simx_error_noerror:
                print('[Joint %s] handle= %s' % (self.joint_name, p))
            else:
                raise Exception('Error in getting joint handles.')

        except Exception as e:
            print('[Joint %s] %s' % (self.joint_name, e.args[0]))
            traceback.print_exc()

        finally:
            # disconnect with V-REP server
            vrep.simxFinish(self.client_id)

if __name__ == "__main__":
    joints = [Joint("joint1", 19999), Joint("joint2", 19998)]
    for joint in joints:
        joint.start()
        time.sleep(0.1)
    time.sleep(1)
    for joint in joints:
        joint.join()
    print("Done")
&lt;/pre&gt;

&lt;p&gt;Dummy properties:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/dummyPropertiesDialog.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/dummyPropertiesDialog.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dummy functions:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/dummiesDescription.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/dummiesDescription.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Loop closure:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://www.coppeliarobotics.com/helpFiles/en/images/dynamicsDesign6.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Dynamic simulations:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#staticAndRespondable"&gt;http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#staticAndRespondable&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Motion planning:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/motionPlanningModule.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/motionPlanningModule.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Means of communication:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/meansOfCommunication.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/meansOfCommunication.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;V-rep API&lt;/h2&gt;
&lt;p&gt;Embedded scripts:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/scripts.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/scripts.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lua crash course:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/luaCrashCourse.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/luaCrashCourse.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.lua.org/pil/contents.html"&gt;http://www.lua.org/pil/contents.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Access objects:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/accessingGeneralObjects.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/accessingGeneralObjects.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;V-rep API 函式列表:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;V-rep 外部控制方法:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;V-rep remote API 範例&lt;/h2&gt;
&lt;p&gt;根據 &lt;a href="http://www.coppeliarobotics.com/helpFiles/en/remoteApiServerSide.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/remoteApiServerSide.htm&lt;/a&gt; 中的說明.&lt;/p&gt;
&lt;p&gt;V-rep 啟動時, 會根據系統目錄下 remoteApiConnections.txt 檔案中的設定, 啟動  rempte api 功能.&lt;/p&gt;
&lt;p&gt;以下為 one-link robot 的 V-rep remote API 程式範例:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import vrep
import sys
# child threaded script: 
# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入
#simExtRemoteApiStart(19999)

vrep.simxFinish(-1)

clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')

errorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,'Revolute_joint',vrep.simx_opmode_oneshot_wait)

if errorCode == -1:
    print('Can not find left or right motor')
    sys.exit()

errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)

while True:
    choice = input("(e to exit, p to pause and enter to exec)&gt;")
    if choice == "e":
        print("exiting")
        vrep.simxStopSimulation(clientID, vrep.simx_opmode_oneshot_wait)
        break
    elif choice == "p":
        vrep.simxPauseSimulation(clientID, vrep.simx_opmode_oneshot_wait)
    else:
        vrep.simxStartSimulation(clientID, vrep.simx_opmode_oneshot_wait)
&lt;/pre&gt;

&lt;h2&gt;V-rep Remote API 呼叫模式&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/remoteApiModusOperandi.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/remoteApiModusOperandi.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;當 V-rep remote API 需要送出資料讓三軸同動時:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
simxPauseCommunication(clientID,1);
simxSetJointPosition(clientID,joint1Handle,joint1Value,simx_opmode_oneshot);
simxSetJointPosition(clientID,joint2Handle,joint2Value,simx_opmode_oneshot);
simxSetJointPosition(clientID,joint3Handle,joint3Value,simx_opmode_oneshot);
simxPauseCommunication(clientID,0);

// Above's 3 joints will be received and set on the V-REP side at the same time
&lt;/pre&gt;

&lt;p&gt;在 V-rep 端設定變數值:&lt;/p&gt;
&lt;p&gt;simSetIntegerSignal("mySignalName",42)&lt;/p&gt;
&lt;p&gt;之後, 可以從 client 端, 以 remote API streaming 模式取得該變數值:&lt;/p&gt;
&lt;p&gt;res,signalValue=simxGetIntegerSignal(clientId,"mySignalName", vrep.simx_opmode_streaming)&lt;/p&gt;
&lt;p&gt;當然, 也可以反方向, 從 V-rep 端取得 client 端的變數值.&lt;/p&gt;
&lt;p&gt;參考範例:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# Make sure to have the server side running in V-REP: 
# in a child script of a V-REP scene, add following command
# to be executed just once, at simulation start:
#
# simExtRemoteApiStart(19999)
#
# then start simulation, and run this program.
#
# IMPORTANT: for each successful call to simxStart, there
# should be a corresponding call to simxFinish at the end!

try:
    import vrep
except:
    print '--------------------------------------------------------------'
    print '"vrep.py" could not be imported. This means very probably that'
    print 'either "vrep.py" or the remoteApi library could not be found.'
    print 'Make sure both are in the same folder as this file,'
    print 'or appropriately adjust the file "vrep.py"'
    print '--------------------------------------------------------------'
    print ''

import time   

print ('Program started')
vrep.simxFinish(-1) # just in case, close all opened connections
clientID=vrep.simxStart('127.0.0.1',19999,True,True,5000,5) # Connect to V-REP
if clientID!=-1:
    print ('Connected to remote API server')

    # Now try to retrieve data in a blocking fashion (i.e. a service call):
    res,objs=vrep.simxGetObjects(clientID,vrep.sim_handle_all,vrep.simx_opmode_oneshot_wait)
    if res==vrep.simx_return_ok:
        print ('Number of objects in the scene: ',len(objs))
    else:
        print ('Remote API function call returned with error code: ',res)

    time.sleep(2)

    # Now retrieve streaming data (i.e. in a non-blocking fashion):
    startTime=time.time()   
    vrep.simxGetIntegerParameter(clientID,vrep.sim_intparam_mouse_x,vrep.simx_opmode_streaming) # Initialize streaming
    while time.time()-startTime &lt; 5:   
        returnCode,data=vrep.simxGetIntegerParameter(clientID,vrep.sim_intparam_mouse_x,vrep.simx_opmode_streaming) # Try to retrieve the streamed data
        if returnCode==vrep.simx_return_ok: # After initialization of streaming, it will take a few ms before the first value arrives, so check the return code
            print ('Mouse position x: ',data) # Mouse position x is actualized when the cursor is over V-REP's window

    # Now send some data to V-REP in a non-blocking fashion:
    vrep.simxAddStatusbarMessage(clientID,'Hello V-REP!',vrep.simx_opmode_oneshot)

    # Before closing the connection to V-REP, make sure that the last command sent out had time to arrive. You can guarantee this with (for example):
    vrep.simxGetPingTime(clientID)

    # Now close the connection to V-REP:   
    vrep.simxFinish(clientID)
else:
    print ('Failed connecting to remote API server')
print ('Program ended')
&lt;/pre&gt;

&lt;p&gt;V-rep Remote API 函式列表:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionListCategory.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionListCategory.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;V-rep 的 remote API 是以 V-rep plugin (動態連結程式庫) 的方式完成, 程式專案位於 programming/v_repExtRemoteApi 目錄中.&lt;/p&gt;
&lt;p&gt;V-rep remote API 可以進一步在 embedded script 程式中利用 Lua 程式進行延伸:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
myFunctionName=function(inInts,inFloats,inStrings,inBuffer)
    -- inInts, inFloats and inStrings are tables
    -- inBuffer is a string

    -- Perform any type of operation here.

    -- Always return 3 tables and a string, e.g.:
    return {},{},{},''
end
&lt;/pre&gt;

&lt;p&gt;然後利用下列外部的 Python 程式進行呼叫:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
inputInts=[1,2,3]
inputFloats=[53.21,17.39]
inputStrings=['Hello','world!']
inputBuffer=bytearray()
inputBuffer.append(78)
inputBuffer.append(42)
res,retInts,retFloats,retStrings,retBuffer=vrep.simxCallScriptFunction(clientID,'objectName',vrep.sim_scripttype_childscript,
                'myFunctionName',inputInts,inputFloats,inputStrings,inputBuffer,vrep.simx_opmode_blocking)
if res==vrep.simx_return_ok:
    print (retInts)
    print (retFloats)
    print (retStrings)
    print (retBuffer)
&lt;/pre&gt;

&lt;h3&gt;以 remote API 取 camera 影像&lt;/h3&gt;
&lt;pre class="brush: python"&gt;
from PIL import Image
import array

res, v0 = vrep.simxGetObjectHandle(clientID,'NAO_vision1',vrep.simx_opmode_oneshot_wait)

res, resolution, image = vrep.simxGetVisionSensorImage(clientID,v0,0,vrep.simx_opmode_streaming)

image_byte_array = array.array('b',image)
# image resolution is 256x144
im = Image.frombuffer("RGB", (256,144), image_byte_array, "raw", "RGB", 0, 1)
im.show()
&lt;/pre&gt;

&lt;p&gt;取影片:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import vrep,time,sys
import matplotlib.pyplot as plt
from PIL import Image
import array

def streamVisionSensor(visionSensorName,clientID,pause=0.0001):
    #Get the handle of the vision sensor
    res1,visionSensorHandle=vrep.simxGetObjectHandle(clientID,visionSensorName,vrep.simx_opmode_oneshot_wait)
    print(visionSensorHandle)
    #Get the image
    res2,resolution,image=vrep.simxGetVisionSensorImage(clientID,visionSensorHandle,0,vrep.simx_opmode_streaming)
    print(res2, res1)
    #Allow the display to be refreshed
    plt.ion()
    #Initialiazation of the figure
    time.sleep(0.5)
    res,resolution,image=vrep.simxGetVisionSensorImage(clientID,visionSensorHandle,0,vrep.simx_opmode_buffer)
    im = Image.new("RGB", (resolution[0], resolution[1]), "white")
    #Give a title to the figure
    fig = plt.figure(1)    
    fig.canvas.set_window_title(visionSensorName)
    #inverse the picture
    plotimg = plt.imshow(im,origin='lower')
    #Let some time to Vrep in order to let him send the first image, otherwise the loop will start with an empty image and will crash
    time.sleep(1)
    while (vrep.simxGetConnectionId(clientID)!=-1): 
        #Get the image of the vision sensor
        res,resolution,image=vrep.simxGetVisionSensorImage(clientID,visionSensorHandle,0,vrep.simx_opmode_buffer)
        #Transform the image so it can be displayed using pyplot
        image_byte_array = array.array('b',image)
        im = Image.frombuffer("RGB", (resolution[0],resolution[1]), image_byte_array, "raw", "RGB", 0, 1)
        #Update the image
        plotimg.set_data(im)
        #Refresh the display
        plt.draw()
        #The mandatory pause ! (or it'll not work)
        plt.pause(pause)
    print('End of Simulation')

if __name__ == '__main__':
    vrep.simxFinish(-1)
    clientID=vrep.simxStart('127.0.0.2',19999,True,True,5000,5)
    if clientID!=-1:
        print('Connected to remote API server')
        streamVisionSensor('NAO_vision1',clientID,0.0001)

    else:
        print('Connection non successful')
        sys.exit('Could not connect')
    &lt;/pre&gt;

&lt;h3&gt;Execute Complex Commands&lt;/h3&gt;
&lt;pre class="brush: python"&gt;
# This example illustrates how to execute complex commands from
# a remote API client. You can also use a similar construct for
# commands that are not directly supported by the remote API.
#
# Load the demo scene 'remoteApiCommandServerExample.ttt' in V-REP, then 
# start the simulation and run this program.
#
# IMPORTANT: for each successful call to simxStart, there
# should be a corresponding call to simxFinish at the end!
#
# When running Python 3.x, add a 'b' prefix to strings, e.g.:
# 'hello world' becomes b'hello world'

def getCmdString(id,cnt,data):
    l=12+len(data)
    retData=vrep.simxPackInts([id,cnt,l])
    return retData+data

def waitForCmdReply(cnt):
    while True:
        result,string=vrep.simxReadStringStream(clientID,'repliesToRemoteApiClient',vrep.simx_opmode_streaming)
        if result==vrep.simx_return_ok:
            while len(string)!=0:
                headerPacked=string[0:12]
                header=vrep.simxUnpackInts(headerPacked)
                if cnt==header[1]:
                    replyData=''
                    if header[2]&gt;12:
                        replyData=string[12:header[2]]
                    return replyData
                string=string[header[2]:len(string)]
try:
    import vrep
except:
    print ('--------------------------------------------------------------')
    print ('"vrep.py" could not be imported. This means very probably that')
    print ('either "vrep.py" or the remoteApi library could not be found.')
    print ('Make sure both are in the same folder as this file,')
    print ('or appropriately adjust the file "vrep.py"')
    print ('--------------------------------------------------------------')
    print ('')

import ctypes
print ('Program started')
vrep.simxFinish(-1) # just in case, close all opened connections
clientID=vrep.simxStart('127.0.0.1',19999,True,True,5000,5) # Connect to V-REP
if clientID!=-1:
    print ('Connected to remote API server')

    # Commands are send via the string signal 'commandsFromRemoteApiClient'.
    # Commands are simply appended to that string signal
    # Each command is coded in following way:
    # 1. Command ID (integer, 4 chars)
    # 2. Command counter (integer, 4 chars). Simply start with 0 and increment for each command you send
    # 3. Command length (integer, includes the command ID, the command counter, the command length, and the additional data (i.e. command data))
    # 4. Command data (chars, can be of any length, depending on the command)
    #
    # Replies are coded in a same way. An executed command should reply with the same command counter.
    # 
    # Above simple protocol is just an example: you could use your own protocol! (but it has to be the same on the V-REP side)

    # 1. First send a command to display a specific message in a dialog box:
    cmdID=1 # this command id means: 'display a text in a message box'
    cmdCnt=0
    cmdData='Hello world!'
    stringToSend=getCmdString(cmdID,cmdCnt,cmdData)
    raw_ubytes = (ctypes.c_ubyte * len(stringToSend)).from_buffer_copy(stringToSend)
    vrep.simxWriteStringStream(clientID,'commandsFromRemoteApiClient',raw_ubytes,vrep.simx_opmode_oneshot)
    print ('Return string: ',waitForCmdReply(cmdCnt)) # display the reply from V-REP (in this case, just a string)

    # 2. Now create a dummy object at coordinate 0.1,0.2,0.3:
    cmdID=2 # this command id means: 'create a dummy at a specific coordinate with a specific name'
    cmdCnt=cmdCnt+1
    cmdData='MyDummyName'+vrep.simxPackFloats([0.1,0.2,0.3])
    stringToSend=getCmdString(cmdID,cmdCnt,cmdData)
    raw_ubytes = (ctypes.c_ubyte * len(stringToSend)).from_buffer_copy(stringToSend)
    vrep.simxWriteStringStream(clientID,'commandsFromRemoteApiClient',raw_ubytes,vrep.simx_opmode_oneshot)
    replyData=waitForCmdReply(cmdCnt)
    print ('Dummy handle: ',vrep.simxUnpackInts(replyData)[0]) # display the reply from V-REP (in this case, the handle of the created dummy)

    # Now close the connection to V-REP:   
    vrep.simxFinish(clientID)
else:
    print ('Failed connecting to remote API server')
print ('Program ended')
&lt;/pre&gt;

&lt;p&gt;與上述 Client 端程式配合的  V-rep non-threaded child 程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if (sim_call_type==sim_childscriptcall_initialization) then
   simExtRemoteApiStart(19999)
end

if (sim_call_type==sim_childscriptcall_actuation) then
   local commands=simGetStringSignal('commandsFromRemoteApiClient') -- Read commands sent from a remote API client
   if commands then
      simClearStringSignal('commandsFromRemoteApiClient') -- Clear the signal
      -- Process the commands in following loop:
      while #commands&gt;0 do
         local cmdID=simUnpackInts(commands,0,1)[1]
         local cmdCounter=simUnpackInts(commands,1,1)[1]
         local cmdLength=simUnpackInts(commands,2,1)[1]
         local cmdData=''
         if cmdLength&gt;12 then
            cmdData=string.sub(commands,13,13+cmdLength-12)
         end
         commands=string.sub(commands,cmdLength+1) -- this contains the next commands

         -- Now process the command, and prepare a reply string signal:
         local reply=''
         if cmdID==1 then
            -- We have to process the command with ID 1, in this example, simply display a dialog box that prints the text stored in cmdData:
            simDisplayDialog('Message from the remote API client',cmdData,sim_dlgstyle_ok,false)
            reply='message was displayed'
         end
         if cmdID==2 then
            -- We have to process the command with ID 2, in this example, create a dummy object at coordinates specified in cmdData:
            local dummyHandle=simCreateDummy(0.05)
            local dummyNameSize=#cmdData-12 -- cmdData should contain the dummy name, plus the x/y/z coordinates
            local position=simUnpackFloats(cmdData,0,0,dummyNameSize)
            if dummyNameSize&gt;0 then
               local errorReportMode=simGetIntegerParameter(sim_intparam_error_report_mode)
               simSetIntegerParameter(sim_intparam_error_report_mode,0) -- temporarily suppress error output (because we are not allowed to have two times the same object name)
               simSetObjectName(dummyHandle,string.sub(cmdData,1,dummyNameSize))
               simSetIntegerParameter(sim_intparam_error_report_mode,errorReportMode) -- restore the original error report mode
            end
            simSetObjectPosition(dummyHandle,-1,position)
            reply=simPackInts({dummyHandle})
         end
         if cmdID==3 then
            -- You can add as many commands as needed
         end

         -- Now, before setting up the reply string, append the cmdID, and a reply length:
         local replyLength=12+#reply
         local replyFromOtherCommands=simGetStringSignal('repliesToRemoteApiClient')
         if not replyFromOtherCommands then
            replyFromOtherCommands=''
         end
         local totalReplySignal=replyFromOtherCommands..simPackInts({cmdID})..simPackInts({cmdCounter})..simPackInts({replyLength})..reply
         simSetStringSignal('repliesToRemoteApiClient',totalReplySignal) -- update the reply signal
      end
   end
end
&lt;/pre&gt;

&lt;h2&gt;Qt based custom UIs&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/customUIPlugin.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/customUIPlugin.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;V-rep Tutorials:&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Inverse Kinematics Tutorial&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/inverseKinematicsTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/inverseKinematicsTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/hexapodTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/hexapodTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/conveyorBeltTutorial.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/conveyorBeltTutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Compiling V-rep&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/compilingVrep.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/compilingVrep.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;V-rep Other Interfaces&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/otherInterfaces.htm"&gt;http://www.coppeliarobotics.com/helpFiles/en/otherInterfaces.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Extra contributions:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/contributions/"&gt;http://www.coppeliarobotics.com/contributions/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;V-rep Forum&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.forum.coppeliarobotics.com/"&gt;http://www.forum.coppeliarobotics.com/&lt;/a&gt;&lt;/p&gt;</summary><category term="v-rep"></category><category term="w2"></category></entry><entry><title>網際 Brython 程式執行環境</title><link href="./brython-editor.html" rel="alternate"></link><published>2017-02-07T11:00:00+08:00</published><updated>2017-02-07T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-02-07:./brython-editor.html</id><summary type="html">&lt;p&gt;Brython 程式環境可以用來練習許多 Python3 的簡單語法, 也可以納入 Javascript 程式庫, 利用 Ajax 模式結合網際瀏覽器與伺服器上的資源解決協同產品設計流程上的問題.&lt;/p&gt;


&lt;!-- 導入 FileSaver 與 filereader --&gt;

&lt;script type="text/javascript" src="./../ace/FileSaver.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../ace/filereader.js"&gt;&lt;/script&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;!--&lt;script type="text/javascript" src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;--&gt;

&lt;!-- 為了讓 import script1 可以正確運行, 停留在 Brython 3.2.9 版 --&gt;

&lt;script type="text/javascript" src="https://cdn.rawgit.com/brython-dev/brython/3.2.9/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;p&gt;列出 2017 Spring 協同產品設計實習課程日期之 Python 程式碼如下:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
&lt;div id="cal2"&gt;&lt;/div&gt;
&lt;script type="text/python3"&gt;
from browser import document, html
import calendar
import locale

cal2 = document["cal2"]

def getClassdate(year=2017, startM=2, startD=20, w=0, note=""):
    # w=0 表示課程排在星期一
    # startM 表示開學月份, startD 表示開學日
    # note 為課程初始告示
    # default calendar MONDAY is the first day of the week
    # 每學期共有 18 週
    totalW = 18
    count = 0
    # output = "2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: "
    output = note + html.BR()
    # 若必須全年搜尋則 7 改為 12, 但是因為只有 18 週, 因此邏輯要修改讓程式較快結束
    for month in range(startM, 7):
        monthArray = calendar.monthcalendar(2017, month)
        for week in range(len(monthArray)):
            weekArray = monthArray[week]
            # 只需要列出星期 (w+1)
            if weekArray[w] != 0:
                if month == startM:
                    if weekArray[startM] &gt; startD:
                        count += 1
                        if count &lt;= totalW:
                            if month == 3 and weekArray[w] == 31:
                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "
                            else:
                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
                else:
                    count += 1
                    if count &lt;=  totalW:
                        if month == 3 and weekArray[w] == 31:
                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "
                        else:
                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
    cal2 &lt;= output

# 2b 協同產品設計實習 (三 w=2)
getClassdate(year=2017, startM=2, startD=20, w=2, note="2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 2a 協同產品設計實習 (四 w=3)
getClassdate(year=2017, startM=2, startD=20, w=3, note="2017 Spring 2aCD (四) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring 1aWCM (五) 13:20-16:10 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# VE1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring VE1aCP (五) 18:30-20:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
&lt;/script&gt;
&lt;/pre&gt;

&lt;h3&gt;利用伺服器執行 Python3 程式&lt;/h3&gt;
&lt;p&gt;Jupyterhub: &lt;a href="https://8888.kmol.info:9443"&gt;https://8888.kmol.info:9443&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;利用以下的編輯器執行 Python3 程式&lt;/h3&gt;
&lt;p&gt;在 Firefox 中, 以 Preferences - General - Downloads 選擇"Always ask me where to save files"&lt;/p&gt;
&lt;p&gt;在 Chrome 中, 以 Settings - Advanced - Downloads 選擇 Ask where to save each file before downloading&lt;/p&gt;
&lt;script src="./../ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;

&lt;script type="text/javascript"&gt;
function doSave(){
    var blob = new Blob([localStorage["py_src"]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById('filename').value
    saveAs(blob, filename+".py");
}
&lt;/script&gt;

&lt;script type="text/python3" id="script1"&gt;
import sys
import time
import traceback
import javascript

from browser import document as doc, window, alert

has_ace = True
try:
    editor = window.ace.edit("editor")
    session = editor.getSession()
    session.setMode("ace/mode/python")

    editor.setOptions({
     'enableLiveAutocompletion': True,
     'enableSnippets': True,
     'highlightActiveLine': False,
     'highlightSelectedWord': True
    })
except:
    from browser import html
    editor = html.TEXTAREA(rows=20, cols=70)
    doc["editor"] &lt;= editor
    def get_value(): return editor.value
    def set_value(x):editor.value = x
    editor.getValue = get_value
    editor.setValue = set_value
    has_ace = False

if hasattr(window, 'localStorage'):
    from browser.local_storage import storage
else:
    storage = None

def reset_src():
    if storage is not None and "py_src" in storage:
        editor.setValue(storage["py_src"])
    else:
        editor.setValue('for i in range(10):\n\tprint(i)')
    editor.scrollToRow(0)
    editor.gotoLine(0)

def reset_src_area():
    if storage and "py_src" in storage:
        editor.value = storage["py_src"]
    else:
        editor.value = 'for i in range(10):\n\tprint(i)'

class cOutput:

    def __init__(self,target):
        self.target = doc[target]
    def write(self,data):
        self.target.value += str(data)


#if "console" in doc:
sys.stdout = cOutput("console")
sys.stderr = cOutput("console")

def to_str(xx):
    return str(xx)

info = sys.implementation.version
doc['version'].text = 'Brython %s.%s.%s' % (info.major, info.minor, info.micro)

output = ''

def show_console(ev):
    doc["console"].value = output
    doc["console"].cols = 60
    doc["console"].rows = 10

# load a Python script
def load_script(evt):
    _name = evt.target.value + '?foo=%s' % time.time()
    editor.setValue(open(_name).read())

# run a script, in global namespace if in_globals is True
def run(*args):
    global output
    doc["console"].value = ''
    src = editor.getValue()
    if storage is not None:
       storage["py_src"] = src

    t0 = time.perf_counter()
    try:
        #ns = {'__name__':'__main__'}
        ns = {'__name__':'editor'}
        exec(src, ns)
        state = 1
    except Exception as exc:
        traceback.print_exc(file=sys.stderr)
        state = 0
    output = doc["console"].value

    print('&lt;completed in %6.2f ms&gt;' % ((time.perf_counter() - t0) * 1000.0))
    return state

if has_ace:
    reset_src()
else:
    reset_src_area()

def clear_console(ev):
    doc["console"].value = ""

doc['run'].bind('click',run)
doc['show_console'].bind('click',show_console)
doc['clear_console'].bind('click',clear_console)
&lt;/script&gt;

&lt;div id="version"&gt;&lt;/div&gt;

&lt;div id="editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave();"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="run"&gt;Run&lt;/button&gt;
&lt;button id="show_console"&gt;Output&lt;/button&gt;
&lt;button id="clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="common"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex1(ev):
    script1.editor.setValue('''#ex1 簡單的 for 迴圈範例
    for i in range(10):
        print(i)
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex1'].bind('click',ex1)
&lt;/script&gt;

&lt;p&gt;&lt;a id="ex1"&gt;ex1&lt;/a&gt;-for 迴圈&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex2(ev):
    script1.editor.setValue('''#溫度轉換程式
from browser import document as doc

# 因為此函式與滑鼠互動, 需要 event 當作輸入
def convTemp():
    mystring = ""
    cdegree = input("請輸入攝氏溫度:")
    fdegree = float(cdegree)*9/5 + 32
    output_string = "攝氏 " + str(cdegree) + "度=華氏 " + str(fdegree) + "度" 
    # 利用 print() 將轉換結果送到 console 區
    print(output_string)

#直接呼叫 convTemp() 執行
convTemp()
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex2'].bind('click',ex2)
&lt;/script&gt;

&lt;p&gt;&lt;a id="ex2"&gt;ex2&lt;/a&gt;-溫度換算&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_file(e):
    data = open("./../python_ex/for1.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)

document["get"].bind("click", get_file)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_temp1(e):
    data = open("./../python_ex/temp1.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)

document["get_temp1"].bind("click", get_temp1)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_ver_and_kw(e):
    data = open("./../python_ex/ver_and_kw.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)

document["get_ver_and_kw"].bind("click", get_ver_and_kw)
&lt;/script&gt;

&lt;p&gt;&lt;button id="get"&gt;for1.py&lt;/button&gt;&lt;button id="get_temp1"&gt;temp1.py&lt;/button&gt;&lt;button id="get_ver_and_kw"&gt;ver_and_kw.py&lt;/button&gt;&lt;/p&gt;</summary><category term="brython"></category><category term="w1"></category></entry><entry><title>2017Spring 協同產品設計實習</title><link href="./2017spring-cd.html" rel="alternate"></link><published>2017-01-08T11:00:00+08:00</published><updated>2017-01-08T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-01-08:./2017spring-cd.html</id><summary type="html">&lt;p&gt;協同產品設計實習在銜接計算機程式、電腦輔助設計實習課程, 讓學員以分組協同的方式進行產品設計實習.&lt;/p&gt;


&lt;h2&gt;歷年協同產品設計實習課程&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://chiamingyen.github.io/kmolab/blog/tag/xie-tong-chan-pin-she-ji-shi-xi.html"&gt;2016 Spring 協同產品設計實習&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cd-cadp.rhcloud.com"&gt;2015 Spring 協同產品設計實習&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wiki.mde.tw/doku.php?id=%E5%8D%94%E5%90%8C%E7%94%A2%E5%93%81%E8%A8%AD%E8%A8%88:%E5%AF%A6%E7%BF%92%E7%9B%AE%E6%A8%99"&gt;2014 Spring 協同產品設計實習&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;協同產品設計實習課程規劃&lt;/h2&gt;
&lt;p&gt;分組規劃: 每班自選組員, 分為 8 組, 每四組分配一台 8GB Ram/500GB HD 電腦作為廣域網路伺服器. 各組成員必須利用自建網站與 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 進行協同歷程簡報、網誌與操作流程影片 (分別放在 Youtube 與 &lt;a href="https://vimeo.com/"&gt;Vimeo&lt;/a&gt;, 並冠上學員學號、系所名稱與課程名稱) 展示.&lt;/p&gt;
&lt;p&gt;協同實習專案: &lt;/p&gt;
&lt;p&gt;(一) &lt;a href="http://solvespace.com/linkage.pl"&gt;多連桿機構&lt;/a&gt;由 &lt;a href="http://solvespace.com"&gt;Solvespace&lt;/a&gt; 與 &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 完成組立後, &lt;/p&gt;
&lt;p&gt;(二) 以程式套件取得特定點的迴轉軌跡後, &lt;/p&gt;
&lt;p&gt;(三) 利用各組自行編寫的 Python3 + C 程式進行軌跡點座標進行驗證. &lt;/p&gt;
&lt;p&gt;(四) 之後將各連桿機構 (包括單桿、四連桿與多連桿單一自由度系統) 轉入 &lt;a href="http://www.coppeliarobotics.com/"&gt;V-rep&lt;/a&gt; 進行驅動模擬後, &lt;/p&gt;
&lt;p&gt;(五) 轉由 remote API 模式, 以區域網路或廣域網路之 Python3 程式進行 &lt;a href="http://www.coppeliarobotics.com/"&gt;V-rep&lt;/a&gt; 連桿機構之驅動模擬控制. 確定可以利用各連桿尺寸調控目標端點的迴轉路徑後, &lt;/p&gt;
&lt;p&gt;(六) 接著在 &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 中, 以協同模式完成多連桿機構的細部組立設計後, &lt;/p&gt;
&lt;p&gt;(七) 再根據多連桿機構的設計材料表, 進行備料, 此階段並導入 Arduino 直流馬達控制系統, 並以 Delta 3D Printer 印出多連桿系統的實體零件後, 進行多連桿機構系統的實體組立與運動控制.&lt;/p&gt;
&lt;p&gt;(八) 最後, 每四組各自利用所完成的&lt;a href="http://solvespace.com/linkage.pl"&gt;多連桿機構&lt;/a&gt;, 組成一四足行走機構, 在 &lt;a href="http://www.coppeliarobotics.com/"&gt;V-rep&lt;/a&gt; 中完成運動模擬後, 每班所完成的兩具行走機構, 分別在 &lt;a href="http://www.coppeliarobotics.com/"&gt;V-rep&lt;/a&gt; 虛擬環境與實體環境中進行運動模擬與行走測試.&lt;/p&gt;
&lt;h2&gt;協同產品設計實習評分標準:&lt;/h2&gt;
&lt;p&gt;(一) 各參與協同學員是否按步就班利用網際簡報、網誌與操作影片呈現細節內容 (50%) - 各組學員根據實際完成內容自評成績後 * 老師認可百分比&lt;/p&gt;
&lt;p&gt;(二) 各組學員在產品設計實習過程是否互助砥礪完成既定工作任務 (分組成員互評) (20%) - 各組學員根據實際內容舉證互評成績平均, 參考系統: &lt;a href="https://pygroup-ag100.rhcloud.com"&gt;https://pygroup-ag100.rhcloud.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(三) 上課出席與表現 (各學員根據實際內容舉證自評成績 * 老師認可百分比) (30%)&lt;/p&gt;
&lt;h2&gt;協同產品設計實習各週上課日期&lt;/h2&gt;
&lt;p&gt;2017 Spring  08:10-12:00 各週上課日期:&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w1&lt;/span&gt;-2/22 2b (三) &amp;amp; 2/23 2a (四) - 請每人準備一個隨身碟, &lt;span style="background-color: #55ff55"&gt;&lt;a href="http://service.mde.tw/public/tiny2017_1GB.7z"&gt;下載&lt;/a&gt;&lt;/span&gt;可攜程式系統 (1GB). 接著請&lt;span style="background-color: #55ff55"&gt;&lt;a href="http://service.mde.tw/public/Onshape_help.pdf"&gt;下載&lt;/a&gt;&lt;/span&gt; Onshape_help.pdf (17.2 MB), 了解如何利用 &lt;a href="http://solvespace.com"&gt;Solvespace&lt;/a&gt; 與 &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 組立單軸旋轉連桿系統、四連桿系統與&lt;a href="http://solvespace.com/linkage.pl"&gt;多連桿系統&lt;/a&gt;. &lt;button onClick="lity('https://player.vimeo.com/video/205152670')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; W1影片&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w2&lt;/span&gt;-3/1 2b (三) &amp;amp; 3/2 2a (四) - 每班分為八組, 每四組分配一台 8GB Ram/500GB HD 電腦作為 IPv4/IPv6 伺服器, 了解如何利用 IPv4 與 IPv6 網路連線傳輸設計檔案. 各組 CMSimfly 區域網站的應用. 各組以協同模式完成&lt;a href="http://solvespace.com"&gt;Solvespace&lt;/a&gt; 與 &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 單軸旋轉連桿系統與四連桿系統. &lt;button onClick="lity('https://player.vimeo.com/video/206173941')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; 建立分組程式&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/206332375')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; 啟動 Stunnel&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/206175405')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; 四連桿組立&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/206342459')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; 四連桿組立(2a)&lt;/button&gt; &lt;button onClick="location.href='http://service.mde.tw/public/fourbarlinkage_w_pin_base.7z'"&gt;&lt;span class="glyphicon glyphicon-file"&gt;&lt;/span&gt; 四連桿組立檔&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w3&lt;/span&gt;-3/8 2b (三) &amp;amp; 3/9 2a (四) - 各組以協同模式完成 &lt;a href="http://solvespace.com"&gt;Solvespace&lt;/a&gt; 與 &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 之 &lt;a href="http://solvespace.com/linkage.pl"&gt;多連桿系統&lt;/a&gt;組立. 各組完成廣域網路與 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 網頁與簡報呈現各組學員與分組協同工作流程細節. &lt;button onClick="lity('https://player.vimeo.com/video/207229473')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks1&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/207229488')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks2&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/207229503')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks3&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/207229515')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks4&lt;/button&gt; &lt;button onClick="location.href='http://www.altairuniversity.com/get-the-free-hyperworks-14-0-student-edition/'"&gt;&lt;span class="glyphicon glyphicon-file"&gt;&lt;/span&gt; Hyperworks 14 學生版&lt;/button&gt; &lt;button onClick="location.href='https://link.springer.com/book/10.1007/978-94-007-1156-3'"&gt;&lt;span class="glyphicon glyphicon-file"&gt;&lt;/span&gt; Kinematics of Machinery Through HyperWorks&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/207239262')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks 14-1&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/207239448')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks 14-2&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/207239288')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks 14-3&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/207239276')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks 14-4&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/207239300')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks 14-5&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/207240382')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Hyperworks 14-6&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w4&lt;/span&gt;-3/15 2b (三) &amp;amp; 3/14 2a (四) - 單連桿與四連桿機構轉入 V-rep 進行運動模擬 &lt;button onClick="lity('https://player.vimeo.com/video/203463280')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; 單連桿&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/208590475')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; start.bat 設定1&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/208590505')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; start.bat 設定2&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/208590490')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; 建立各組倉儲&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/208592954')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; 設定 fossil server&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/208595022')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; fossil sql 指令&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/208595072')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; 管理 fossil server&lt;/button&gt; &lt;button onClick="lity('https://player.vimeo.com/video/208596647')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; one-link robot 轉進 V-rep&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w5&lt;/span&gt;-3/22 2b (三) &amp;amp; 3/23 2a (四) - 單連桿與四連桿機構轉入 V-rep 進行運動模擬 &lt;button onClick="lity('https://player.vimeo.com/video/209501967')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; Fossil 首頁設定與 one-link V-rep 模擬&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w6&lt;/span&gt;-3/29 2b (三) &amp;amp; 3/30 2a (四) - 多連桿機構轉入 V-rep 進行運動模擬 &lt;button onClick="lity('https://player.vimeo.com/video/203155380')"&gt;&lt;span class="glyphicon glyphicon-facetime-video"&gt;&lt;/span&gt; 多連桿&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w7&lt;/span&gt;-4/5 2b (三) &amp;amp; 4/6 2a (四) - 多連桿機構轉入 V-rep 進行運動模擬&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w8&lt;/span&gt;-4/12 2b (三) &amp;amp; 4/13 2a (四) - 各組期中簡報 (含影片拍攝與上傳) 與評分&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w9&lt;/span&gt;-4/19 2b (三) &amp;amp; 4/20 2a (四) - V-rep remote API 運動控制&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w10&lt;/span&gt;-4/26 2b (三) &amp;amp; 4/27 2a (四) - V-rep remote API 運動控制&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w11&lt;/span&gt;-5/3 2b (三) &amp;amp; 5/4 2a (四) - Arduino 直流馬達控制&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w12&lt;/span&gt;-5/10 2b (三) &amp;amp; 5/11 2a (四) - Arduino 直流馬達控制&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w13&lt;/span&gt;-5/17 2b (三) &amp;amp; 5/18 2a (四) - Onshape 行走機構細部設計 (含齒輪傳動)&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w14&lt;/span&gt;-5/24 2b (三) &amp;amp; 5/25 2a (四) - Onshape 行走機構細部設計 (含齒輪傳動)&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w15&lt;/span&gt;-5/31 2b (三) &amp;amp; 6/1 2a (四) - V-rep 行走機構模擬與零件列印組立測試&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w16&lt;/span&gt;-6/7 2b (三) &amp;amp; 6/8 2a (四) - V-rep 行走機構模擬與零件列印組立測試&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w17&lt;/span&gt;-6/14 2b (三) &amp;amp; 6/15 2a (四) - V-rep 行走機構模擬與零件列印組立測試&lt;/p&gt;
&lt;p&gt;&lt;span style="background-color: #ffff00"&gt;w18&lt;/span&gt;-6/21 2b (三) &amp;amp; 6/22 2a (四) - 各組期末簡報  (含影片拍攝與上傳) 與評分&lt;/p&gt;
&lt;h2&gt;參考資料:&lt;/h2&gt;
&lt;p&gt;&lt;img src="./../data/jansen_solvespace_1.png" width="560" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/jansen_solvespace_2.png" width="560" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/jansen_solvespace_3.png" width="560" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/eight_bar_solvespace_vrep_1.png" width="560" /&gt;&lt;/p&gt;
&lt;iframe src="https://player.vimeo.com/video/203155380" width="560" height="315" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/203155380"&gt;機械設計工程系-協同產品設計實習課程: cd v-rep 8bar simulation&lt;/a&gt; from &lt;a href="https://vimeo.com/user24079973"&gt;虎尾科大機械設計工程&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/kKSDgIhc8GI" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/4Pj-WLAVL7M" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://github.com/spacether/pycalculix"&gt;https://github.com/spacether/pycalculix&lt;/a&gt;&lt;/p&gt;</summary><category term="syllabus"></category><category term="w1"></category></entry></feed>