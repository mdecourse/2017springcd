<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="yen.20170108171605.1"><vh>@settings</vh>
<v t="yen.20170108171605.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="yen.20170108171605.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="yen.20170108171622.1"><vh>有關 2017springcd</vh></v>
<v t="yen.20170108171733.1" a="E"><vh>@path ../</vh>
<v t="yen.20170108171733.2"><vh>@button pelican-blog</vh></v>
<v t="yen.20170108171733.3"><vh>@edit README.md</vh></v>
<v t="yen.20170108171733.4"><vh>@edit .gitignore</vh></v>
<v t="yen.20170108171733.5"><vh>Pelican 設定</vh>
<v t="yen.20170108171733.6"><vh>@edit local_publishconf.py</vh></v>
<v t="yen.20170108171733.7"><vh>@edit pelicanconf.py</vh></v>
</v>
<v t="yen.20170215103217.1"><vh>編輯 template</vh>
<v t="yen.20170215103228.1"><vh>@path theme/pelican-bootstrap3_local/templates</vh>
<v t="yen.20170215103332.1"><vh>@edit base.html</vh></v>
</v>
</v>
<v t="yen.20170120110024.1"><vh>@clean index.html</vh>
<v t="yen.20170120110024.2"><vh>html</vh>
<v t="yen.20170120110024.3"><vh>head</vh></v>
<v t="yen.20170120110024.4"><vh>body</vh>
<v t="yen.20170120110024.5"><vh>reveal div</vh>
<v t="yen.20170120110024.6"><vh>slides div</vh>
<v t="yen.20170120110024.7"><vh>封面投影片</vh>
<v t="yen.20170120110024.8"><vh>封面投影片內容</vh></v>
</v>
<v t="yen.20170120110024.9"><vh>快捷鍵</vh>
<v t="yen.20170120110024.10"><vh>投影片快捷鍵</vh></v>
</v>
<v t="yen.20170120110024.11"><vh>各式內容引用範例</vh>
<v t="yen.20170120110024.12"><vh>導入數學符號與方程式</vh>
<v t="yen.20170120110024.13"><vh>LaTeX 格式方程式</vh></v>
</v>
<v t="yen.20170120110024.14"><vh>導入縮排程式碼</vh>
<v t="yen.20170120110024.15"><vh>引用程式碼</vh></v>
</v>
<v t="yen.20170120110024.16"><vh>導入影片</vh>
<v t="yen.20170120110024.17"><vh>iframe 導入影片</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="yen.20170508001342.1"><vh>@path data</vh>
<v t="yen.20170508001351.1"><vh>@path py</vh>
<v t="yen.20170508001359.1"><vh>@clean plt.py</vh>
<v t="yen.20170508011028.1"><vh>Declarations</vh></v>
<v t="yen.20170508011028.2"><vh>class Coord</vh>
<v t="yen.20170508011028.3"><vh>__init__</vh></v>
<v t="yen.20170508011028.4"><vh>__sub__</vh></v>
<v t="yen.20170508011028.5"><vh>__repr__</vh></v>
<v t="yen.20170508011028.6"><vh>length</vh></v>
<v t="yen.20170508011028.7"><vh>angle</vh></v>
</v>
<v t="yen.20170508011028.8"><vh>normalize</vh></v>
<v t="yen.20170508011028.9"><vh>perpendicular</vh></v>
<v t="yen.20170508011028.10"><vh>class Point</vh>
<v t="yen.20170508011028.11"><vh>__init__</vh></v>
<v t="yen.20170508011028.12"><vh>drawMe</vh></v>
<v t="yen.20170508011028.13"><vh>Eq</vh></v>
<v t="yen.20170508011028.14"><vh>setPoint</vh></v>
<v t="yen.20170508011028.15"><vh>distance</vh></v>
<v t="yen.20170508011028.16"><vh>tag</vh></v>
</v>
<v t="yen.20170508011028.17"><vh>class Line</vh>
<v t="yen.20170508011028.18"><vh>__init__</vh></v>
<v t="yen.20170508011028.19"><vh>setPP</vh></v>
<v t="yen.20170508011028.20"><vh>setRT</vh></v>
<v t="yen.20170508011028.21"><vh>getR</vh></v>
<v t="yen.20170508011028.22"><vh>getT</vh></v>
<v t="yen.20170508011028.23"><vh>setTail</vh></v>
<v t="yen.20170508011028.24"><vh>getHead</vh></v>
<v t="yen.20170508011028.25"><vh>getTail</vh></v>
<v t="yen.20170508011028.26"><vh>drawMe</vh></v>
<v t="yen.20170508011028.27"><vh>test</vh></v>
</v>
<v t="yen.20170508011028.28"><vh>class Link</vh>
<v t="yen.20170508011028.29"><vh>__init__</vh></v>
<v t="yen.20170508011028.30"><vh>drawMe</vh></v>
</v>
<v t="yen.20170508011028.31"><vh>class Triangle</vh>
<v t="yen.20170508011028.32"><vh>__init__</vh></v>
<v t="yen.20170508011028.33"><vh>getLenp3</vh></v>
<v t="yen.20170508011028.34"><vh>getLenp1</vh></v>
<v t="yen.20170508011028.35"><vh>getLenp2</vh></v>
<v t="yen.20170508011028.36"><vh>getAp1</vh></v>
<v t="yen.20170508011028.37"><vh>getAp2</vh></v>
<v t="yen.20170508011028.38"><vh>getAp3</vh></v>
<v t="yen.20170508011028.39"><vh>drawMe</vh></v>
<v t="yen.20170508011028.40"><vh>setSSS</vh></v>
<v t="yen.20170508011028.41"><vh>setSAS</vh></v>
<v t="yen.20170508011028.42"><vh>setSaSS</vh></v>
<v t="yen.20170508011028.43"><vh>getSSS</vh></v>
<v t="yen.20170508011028.44"><vh>getAAA</vh></v>
<v t="yen.20170508011028.45"><vh>getASASAS</vh></v>
<v t="yen.20170508011028.46"><vh>setPPSS</vh></v>
</v>
</v>
<v t="yen.20170508010952.1"><vh>@clean fourbar.py</vh>
<v t="yen.20170508011005.1"><vh>Declarations</vh></v>
<v t="yen.20170508011005.2"><vh>plap</vh></v>
<v t="yen.20170508011005.3"><vh>pllp</vh></v>
<v t="yen.20170508011005.4"><vh>class fourbar</vh>
<v t="yen.20170508011005.5"><vh>__init__</vh></v>
<v t="yen.20170508011005.6"><vh>cx</vh></v>
<v t="yen.20170508011005.7"><vh>cy</vh></v>
<v t="yen.20170508011005.8"><vh>dx</vh></v>
<v t="yen.20170508011005.9"><vh>dy</vh></v>
<v t="yen.20170508011005.10"><vh>ex</vh></v>
<v t="yen.20170508011005.11"><vh>ey</vh></v>
</v>
</v>
<v t="yen.20170508011515.1"><vh>@edit gcs.py</vh></v>
</v>
</v>
<v t="yen.20170108171733.71" a="E"><vh>@path content</vh>
<v t="yen.20170123225841.1"><vh>@edit 20170108.md</vh></v>
<v t="yen.20170207091131.1"><vh>@clean 20170207.md</vh>
<v t="yen.20170207091131.2"><vh>ex1 - for 迴圈</vh></v>
<v t="yen.20170207091131.3"><vh>ex2 - input 與單位換算</vh></v>
<v t="yen.20170207091131.4"><vh>filereader</vh></v>
</v>
<v t="yen.20170209092319.1"><vh>@edit 20170209.md</vh></v>
<v t="yen.20170314213339.1"><vh>@edit 20170217.md</vh></v>
<v t="yen.20170221100209.1"><vh>@edit 20170222.md</vh></v>
<v t="yen.20170314213424.1"><vh>@clean 20170314.md</vh>
<v t="yen.20170314213424.2"><vh>ex1 - for 迴圈</vh></v>
<v t="yen.20170314213424.3"><vh>ex2 - input 與單位換算</vh></v>
<v t="yen.20170314214818.1"><vh>ex3 - jansen 多連桿機構</vh></v>
<v t="yen.20170314213424.4"><vh>filereader</vh></v>
</v>
<v t="yen.20170315204017.1"><vh>@edit 20170315.md</vh></v>
<v t="yen.20170321092635.1"><vh>@edit 20170321.md</vh></v>
<v t="yen.20170415223959.1"><vh>@edit 20170415.md</vh></v>
<v t="leo.20170427102200.1"><vh>@edit 20170427.md</vh></v>
<v t="yen.20170502163600.1"><vh>@edit 20170502.md</vh></v>
<v t="leo.20170503094705.1"><vh>@edit 20170503.md</vh></v>
<v t="yen.20170503182604.1"><vh>@edit 20170503-1.md</vh></v>
<v t="yen.20170504200728.1"><vh>@edit 20170504.md </vh></v>
<v t="yen.20170507171712.1"><vh>@edit 20170507.md</vh></v>
<v t="yen.20170511155847.1"><vh>@edit 20170511.md</vh></v>
<v t="yen.20170529225045.1"><vh>@edit 20170530.md</vh></v>
<v t="yen.20170613205037.1"><vh>@edit 20170614.md</vh></v>
<v t="yen.20170618204408.1"><vh>@edit 20170618.md</vh></v>
<v t="yen.20170622172255.1"><vh>@edit 20170622.md</vh></v>
<v t="yen.20170108171733.81"><vh>@path pages</vh>
<v t="yen.20170108171733.82"><vh>@edit pages_1.md</vh></v>
</v>
</v>
<v t="yen.20170108171733.83"><vh>產生 .key 與 .crt</vh></v>
</v>
<v t="yen.20170108171930.1"><vh>@button https server</vh></v>
<v t="yen.20170108171939.1"><vh>@button ipv6 https server</vh></v>
<v t="yen.20170120212350.1"><vh>programs</vh>
<v t="leo.20170503093805.1"><vh>W11</vh>
<v t="leo.20170503093813.1"><vh>spur</vh></v>
<v t="leo.20170503094123.1"><vh>Cango javascript</vh></v>
<v t="leo.20170503094328.1"><vh>fillet intersection</vh></v>
<v t="yen.20170503173014.1"><vh>Involute Javascript</vh></v>
<v t="yen.20170503210042.1"><vh>animation script</vh></v>
</v>
<v t="leo.20170426085813.1"><vh>Brython</vh>
<v t="leo.20170426085831.1"><vh>@path ../data/py</vh>
<v t="leo.20170426085849.1"><vh>@clean script1.py</vh>
<v t="leo.20170426085920.1"><vh>script1 declarations</vh></v>
<v t="leo.20170426085920.2"><vh>reset_src</vh></v>
<v t="leo.20170426085920.3"><vh>reset_src_area</vh></v>
<v t="leo.20170426085920.4"><vh>class cOutput</vh>
<v t="leo.20170426085920.5"><vh>__init__</vh></v>
<v t="leo.20170426085920.6"><vh>write</vh></v>
</v>
<v t="leo.20170426085920.7"><vh>to_str</vh></v>
<v t="leo.20170426085920.8"><vh>show_console</vh></v>
<v t="leo.20170426085920.9"><vh>load_script</vh></v>
<v t="leo.20170426085920.10"><vh>run</vh></v>
<v t="leo.20170426085920.11"><vh>clear_console</vh></v>
</v>
<v t="leo.20170426085944.1"><vh>@edit fourbar.py</vh></v>
</v>
</v>
<v t="yen.20170210153828.1"><vh>v-rep rempte api</vh>
<v t="yen.20170210202015.1"><vh>Python remote API</vh></v>
<v t="yen.20170210170248.1"><vh>line tracer</vh></v>
<v t="yen.20170210222733.1"><vh>line tracer2</vh></v>
<v t="yen.20170210172100.1"><vh>three-link robot</vh></v>
<v t="yen.20170210221519.1"><vh>bubble</vh></v>
</v>
<v t="yen.20170120212354.1"><vh>calendar ex1</vh></v>
<v t="yen.20170120212520.1"><vh>calendar ex2</vh></v>
<v t="yen.20170120232548.1"><vh>calendar example</vh></v>
<v t="yen.20170123204227.1"><vh>印出月曆以及各課程上課日期</vh></v>
<v t="yen.20170207092354.1"><vh>協同程式參考</vh></v>
<v t="yen.20170124102405.1"><vh>chat</vh>
<v t="yen.20170124102433.1"><vh>index.html</vh></v>
</v>
</v>
<v t="yen.20170209024032.1"><vh>reference</vh></v>
<v t="leo.20170503103809.1"><vh>kmol2018</vh>
<v t="leo.20170504105248.1"><vh>問題</vh></v>
<v t="yen.20170508020303.1"><vh>draw</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20170426085813.1"></t>
<t tx="leo.20170426085831.1"></t>
<t tx="leo.20170426085849.1">@language python
@tabwidth -4
@others
doc['run'].bind('click',run)
doc['show_console'].bind('click',show_console)
doc['clear_console'].bind('click',clear_console)
</t>
<t tx="leo.20170426085920.1">import sys
import time
import traceback
import javascript

from browser import document as doc, window, alert

has_ace = True
try:
    editor = window.ace.edit("editor")
    session = editor.getSession()
    session.setMode("ace/mode/python")

    editor.setOptions({
     'enableLiveAutocompletion': True,
     'enableSnippets': True,
     'highlightActiveLine': False,
     'highlightSelectedWord': True
    })
except:
    from browser import html
    editor = html.TEXTAREA(rows=20, cols=70)
    doc["editor"] &lt;= editor
    def get_value(): return editor.value
    def set_value(x):editor.value = x
    editor.getValue = get_value
    editor.setValue = set_value
    has_ace = False

if hasattr(window, 'localStorage'):
    from browser.local_storage import storage
else:
    storage = None

</t>
<t tx="leo.20170426085920.10"># run a script, in global namespace if in_globals is True
def run(*args):
    global output
    doc["console"].value = ''
    src = editor.getValue()
    if storage is not None:
       storage["py_src"] = src

    t0 = time.perf_counter()
    try:
        #ns = {'__name__':'__main__'}
        ns = {'__name__':'editor'}
        exec(src, ns)
        state = 1
    except Exception as exc:
        traceback.print_exc(file=sys.stderr)
        state = 0
    output = doc["console"].value

    print('&lt;completed in %6.2f ms&gt;' % ((time.perf_counter() - t0) * 1000.0))
    return state

</t>
<t tx="leo.20170426085920.11">if has_ace:
    reset_src()
else:
    reset_src_area()
    
def clear_console(ev):
    doc["console"].value = ""

</t>
<t tx="leo.20170426085920.2">def reset_src():
    if storage is not None and "py_src" in storage:
        editor.setValue(storage["py_src"])
    else:
        editor.setValue('for i in range(10):\n\tprint(i)')
    editor.scrollToRow(0)
    editor.gotoLine(0)

</t>
<t tx="leo.20170426085920.3">def reset_src_area():
    if storage and "py_src" in storage:
        editor.value = storage["py_src"]
    else:
        editor.value = 'for i in range(10):\n\tprint(i)'

</t>
<t tx="leo.20170426085920.4">class cOutput:
    @others
</t>
<t tx="leo.20170426085920.5">
def __init__(self,target):
    self.target = doc[target]
</t>
<t tx="leo.20170426085920.6">def write(self,data):
    self.target.value += str(data)
    

</t>
<t tx="leo.20170426085920.7">#if "console" in doc:
sys.stdout = cOutput("console")
sys.stderr = cOutput("console")

def to_str(xx):
    return str(xx)

</t>
<t tx="leo.20170426085920.8">info = sys.implementation.version
doc['version'].text = 'Brython %s.%s.%s' % (info.major, info.minor, info.micro)

output = ''

def show_console(ev):
    doc["console"].value = output
    doc["console"].cols = 60
    doc["console"].rows = 10

</t>
<t tx="leo.20170426085920.9"># load a Python script
def load_script(evt):
    _name = evt.target.value + '?foo=%s' % time.time()
    editor.setValue(open(_name).read())

</t>
<t tx="leo.20170503093805.1"></t>
<t tx="leo.20170503093813.1">&lt;canvas id='gear2' width='800' height='700'&gt;&lt;/canvas&gt;
 
&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx
 
    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
 
# 準備在 id="gear2" 的 canvas 中繪圖
canvas = doc["gear2"]
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.width/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&lt;/script&gt;</t>
<t tx="leo.20170503094123.1">&lt;canvas id='gear1' width='800' height='750'&gt;&lt;/canvas&gt;
 
&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math
 
# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)
 
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")
 
######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)
 
# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True
 
# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&lt;/script&gt;</t>
<t tx="leo.20170503094328.1">#https://github.com/utlco/tcnc/blob/master/tcnc/geom/fillet.py
#-----------------------------------------------------------------------------
# Copyright 2012-2016 Claude Zervas
# email: claude@utlco.com
#-----------------------------------------------------------------------------
"""
Connect Line/Arc segments with a fillet arc.
"""
# Python 3 compatibility boilerplate
from __future__ import (absolute_import, division,
                        print_function, unicode_literals)
from future_builtins import *

import math

# For debugging:
import logging
logger = logging.getLogger(__name__)

from . import debug
from . import const
from .line import Line
from .arc import Arc

def fillet_path(path, radius, fillet_close=True):
    """Attempt to insert a circular arc of the specified radius
    to connect adjacent path segments.

    Args:
        path: A list of Line or Arc segments.
        radius: The radius of the fillet arc.
        fillet_close: If True and the path is closed then
            add a terminating fillet. Default is False.

    Returns:
        A new path with fillet arcs. If no fillets are created then
        the original path will be returned.
    """
    if radius &lt; const.EPSILON or len(path) &lt; 2:
        return path
    new_path = []
    seg1 = path[0]
    for seg2 in path[1:]:
        new_segs = insert_fillet(seg1, seg2, radius)
        if new_segs:
            new_path.extend(new_segs[:-1])
            seg2 = new_segs[-1]
        else:
            new_path.append(seg1)
        seg1 = seg2
    new_path.append(seg1)
    # Close the path with a fillet
    if fillet_close and len(path) &gt; 2 and path[0].p1 == path[-1].p2:
        new_segs = insert_fillet(new_path[-1], new_path[0], radius)
        if new_segs:
            new_path[-1] = new_segs[0]
            new_path.append(new_segs[1])
            new_path[0] = new_segs[2]
    # Discard the path copy if no fillets were created...
    return new_path if len(new_path) &gt; len(path) else path


def fillet_polygon(poly, radius, fillet_close=True):
    """Attempt to insert a circular arc of the specified radius
    connecting adjacent polygon segments.

    Args:
        poly: A list of polygon vertices.
        radius: The radius of the fillet arc.
        fillet_close: If True and the path is closed then
            add a terminating fillet. Default is True.

    Returns:
        A new path with fillet arcs as a list of Line and Arc segments.
        If no fillets are created then the original path will be returned.
    """
    if len(poly) &lt; 2:
        return ()
    seg1 = Line(poly[0], poly[1])
    if len(poly) == 2:
        return (seg1,)
    path = []
    for p in poly[2:]:
        seg2 = Line(seg1.p2, p)
        new_segs = insert_fillet(seg1, seg2, radius)
        if new_segs:
            path.append(new_segs[0])
            path.append(new_segs[1])
            seg1 = new_segs[2]
        else:
            path.append(seg1)
            seg1 = seg2
    path.append(seg1)
    if fillet_close and len(path) &gt; 2 and path[0].p1 == path[-1].p2:
        new_segs = insert_fillet(path[-1], path[0], radius)
        if new_segs:
            path[-1] = new_segs[0]
            path.append(new_segs[1])
            path[0] = new_segs[2]
    return path


def insert_fillet(seg1, seg2, radius):
    """Try to create a fillet between two segments.
    Any GCode rendering hints attached to the segments will
    be preserved.

    Args:
        seg1: First segment, an Arc or a Line.
        seg2: Second segment, an Arc or a Line.
        radius: Fillet radius.

    Returns:
        A tuple containing the adjusted segments and fillet arc:
        (seg1, fillet_arc, seg2)
        Returns an empty tuple if the segments cannot be connected
        with a fillet arc (either they are too small
        or somehow degenerate.)
    """
    farc = create_fillet_arc(seg1, seg2, radius)
    if farc is None:
        return ()
    return connect_fillet(seg1, farc, seg2)


def connect_fillet(seg1, farc, seg2):
    """Connect two segments with a fillet arc.
    This will adjust the lengths of the segments to
    accommodate the fillet."""
    if isinstance(seg1, Line):
        new_seg1 = Line(seg1.p1, farc.p1)
        if isinstance(seg2, Line):
            # Connect Line-&gt;Fillet-&gt;Line
            new_seg2 = Line(farc.p2, seg2.p2)
        else:
            # Connect Line-&gt;Fillet-&gt;Arc
            new_angle = seg2.angle - seg2.center.angle2(seg2.p1, farc.p2)
            new_seg2 = Arc(farc.p2, seg2.p2, seg2.radius, new_angle,
                                seg2.center)
    else:
        new_angle = seg1.angle - seg1.center.angle2(farc.p1, seg1.p2)
        new_seg1 = Arc(seg1.p1, farc.p1, seg1.radius, new_angle,
                            seg1.center)
        if isinstance(seg2, Line):
            # Connect Arc-&gt;Fillet-&gt;Line
            new_seg2 = Line(farc.p2, seg2.p2)
        else:
            # Connect Arc-&gt;Fillet-&gt;Arc
            new_angle = seg2.angle - seg2.center.angle2(seg2.p1, farc.p2)
            new_seg2 = Arc(farc.p2, seg2.p2, seg2.radius, new_angle,
                                seg2.center)
    return (new_seg1, farc, new_seg2)


def create_fillet_arc(seg1, seg2, radius):
    """Try to create a fillet between two segments.

    Args:
        seg1: First segment, an Arc or a Line.
        seg2: Second segment, an Arc or a Line.
        radius: Fillet radius.

    Returns:
        A fillet arc or None if the segments cannot be connected
        with a fillet arc (either they are too small, already G1
        continuous, or are somehow degenerate.)
    """
    farc = None
    if isinstance(seg1, Line):
        if isinstance(seg2, Line):
            farc = fillet_line_line(seg1, seg2, radius)
        elif isinstance(seg2, Arc):
            farc = fillet_line_arc(seg1, seg2, radius)
    elif isinstance(seg1, Arc):
        if isinstance(seg2, Line):
            farc = fillet_line_arc(seg2, seg1, radius)
        elif isinstance(seg2, Arc):
            farc = fillet_arc_arc(seg1, seg2, radius)
    return farc


def fillet_line_line(line1, line2, fillet_radius):
    """Create a fillet arc between two line segments.

    Args:
        line1: A Line.
        line2: A Line connected to line1.
        fillet_radius: The radius of the fillet.

    Returns:
        An Arc, or None if the fillet radius is too big to fit or
        if the two segments are not connected.
    """
    fillet_arc = None # default return value
    lineside = line1.which_side(line2.p2)
    offset = fillet_radius * lineside
    offset_line1 = line1.offset(offset)
    offset_line2 = line2.offset(offset)
    fillet_center = offset_line1.intersection(offset_line2)
    if fillet_center is not None:
        fp1 = line1.normal_projection_point(fillet_center, segment=True)
        fp2 = line2.normal_projection_point(fillet_center, segment=True)
        # Test for fillet fit
        if (fp1 is not None and fp2 is not None and fp1 != fp2
                and const.float_eq(fp1.distance(fillet_center), fillet_radius)
                and const.float_eq(fp2.distance(fillet_center), fillet_radius)):
            fillet_arc = Arc.from_two_points_and_center(fp1, fp2,
                                                       fillet_center)
    return fillet_arc


def fillet_arc_arc(arc1, arc2, fillet_radius):
    """Create a fillet arc between two connected arcs.

    Args:
        arc1: First arc.
        arc2: Second arc.
        fillet_radius: The radius of the fillet.

    Returns:
        An Arc,
        or None if the fillet radius is too big to fit or
        if the two segments are not connected.
    """
    fillet_arc = None # default return value
    arc2_side = arc1.which_side_angle(arc2.start_tangent_angle())
    cw1 = 1 if arc1.is_clockwise() else -1
    cw2 = 1 if arc2.is_clockwise() else -1
    offset_arc1 = arc1.offset(fillet_radius * arc2_side * cw1)
    offset_arc2 = arc2.offset(fillet_radius * arc2_side * cw2)
    # The intersection of the two offset arcs is the fillet arc center.
    offset_intersections = offset_arc1.intersect_arc(offset_arc2, on_arc=True)
    if offset_intersections:
        fillet_center = offset_intersections[0]
        # Find points normal from fillet center to arc segments
        fline1 = Line(fillet_center, arc1.center)
        fline2 = Line(fillet_center, arc2.center)
        ix1 = arc1.intersect_line(fline1, on_arc=True)
        ix2 = arc2.intersect_line(fline2, on_arc=True)
        if ix1 and ix2:
            fillet_arc = Arc.from_two_points_and_center(ix1[0], ix2[0],
                                                        fillet_center)
    return fillet_arc


def fillet_line_arc(line, arc, fillet_radius):
    """Create a fillet arc between a line segment and a connected arc.
    The fillet arc end point order will match the line-arc order.

    Args:
        line: A Line.
        arc: An Arc.
        fillet_radius: The radius of the fillet.

    Returns:
        An Arc,
        or None if the fillet radius is too big to fit or
        if the two segments are not connected.
    """
    debug.draw_arc(arc, verbose=True)
    # TODO: Maybe replace this novel approach with the more usual
    # offset intersection method..
    fillet_arc = None # default return value

    # If the direction is arc-&gt;line then reverse both
    # to make things simpler.
    is_reversed = False
    if const.float_eq(arc.p2, line.p1):
        # The two segments are connected but in reverse order.
        line = line.reversed()
        arc = arc.reversed()
        is_reversed = True

    arc_side = line.which_side_angle(arc.start_tangent_angle())
    if ((arc_side &gt; 0 and arc.is_clockwise()) or
        (arc_side &lt; 0 and not arc.is_clockwise())):
        h = arc.radius + fillet_radius
        alpha1 = line.angle() + math.pi
    else:
        h = arc.radius - fillet_radius
        alpha1 = line.angle()
    line3 = line.offset(fillet_radius * arc_side)
    p5 = line3.normal_projection_point(arc.center)
    b = p5.distance(arc.center)
    a2 = h*h - b*b
    if a2 &lt; 0:
        return
    a = math.sqrt(a2)
    line4 = Line.from_polar(p5, a, alpha1)
    fillet_center = line4.p2
    alpha2 = abs(arc.center.angle2(arc.p1, fillet_center))
    fp1 = line.normal_projection_point(fillet_center, segment=True)
    fp2 = arc.point_at_angle(alpha2, segment=True)
    if (fp1 is not None and fp2 is not None and fp1 != fp2 and
        const.float_eq(fillet_center.distance(fp1),
                      fillet_center.distance(fp2))):
        if is_reversed:
            fillet_arc = Arc.from_two_points_and_center(fp2, fp1,
                                                             fillet_center)
        else:
            fillet_arc = Arc.from_two_points_and_center(fp1, fp2,
                                                             fillet_center)
    return fillet_arc</t>
<t tx="leo.20170503103809.1">在基本的 Python 3.6.1 與 PyQt5 環境下, 需要安裝 pelican, Markdown 與 bs4 才能使用 pelican-blog 按鈕

python -m pip install pelican
python -m pip install bs4
python -m pip install Markdown

加上 portable git</t>
<t tx="leo.20170504105248.1">確定在 Python 3.6.1 才會發生下列錯誤:

DISPLAY_PAGES_ON_MENU 無法運作

Brython Windows 無法正確判斷字串</t>
<t tx="yen.20170108171605.1"></t>
<t tx="yen.20170108171605.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="yen.20170108171605.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="yen.20170108171622.1">2017 Spring CD 機械設計工程系協同產品設計實習

倉儲位置: https://github.com/mdecourse/2017springcd

每一協同成員都應該要在 users 目錄下有一個 Leo 檔案

</t>
<t tx="yen.20170108171733.1"></t>
<t tx="yen.20170108171733.2">@language python
import os
#os.system("pelican content -o output -s local_publishconf.py -t theme/pelican-bootstrap3")
os.system("pelican content -o blog -s local_publishconf.py")
g.es("admin pelican 近端執行完畢")


</t>
<t tx="yen.20170108171733.5"></t>
<t tx="yen.20170108171733.71"></t>
<t tx="yen.20170108171733.81"></t>
<t tx="yen.20170108171733.83">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt

</t>
<t tx="yen.20170108171930.1">@language python
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 7443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("7443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20170108171939.1">@language python
import os
import subprocess
import threading
import socket
import http.server, ssl

class HTTPServerV6(http.server.HTTPServer):
    address_family = socket.AF_INET6
  
def domake():
    # build directory
    os.chdir("./../")
    ipv6_address = '::1'
    server_address = (ipv6_address, 6443)
    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("6443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20170120110024.1">@language xml
@tabwidth -4
@others

</t>
<t tx="yen.20170120110024.10"># 投影片快捷鍵

* 利用箭頭上下前後換頁
* 按 f 鍵進入全螢幕模式 (full screen)
* 按 s 鍵可以顯示投影片筆記 (show)
* 按 o 鍵可以切換單張或全域檢視 (overview)
* 按 b 或 . 鍵可以切換螢幕黑屏 (black)
* 按 Esc 可以退出全螢幕或全域檢視 (Escape)

</t>
<t tx="yen.20170120110024.11">&lt;section&gt;
@others
&lt;/section&gt;</t>
<t tx="yen.20170120110024.12">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="yen.20170120110024.13"># 數學符號與方程式

Inline math equations go in like so: $\omega = d\phi / dt$. Display
math should get its own line and be put in in double-dollarsigns:

$$I = \int \rho R^{2} dV$$
</t>
<t tx="yen.20170120110024.14">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="yen.20170120110024.15">## 利用 Markdown 寫投影片
以下利用 Markdown 格式展示 Python 程式碼:
```
@language python
# use threading and subprocess to threading the make process
import os
import subprocess
import threading

def domake():
    
    path = "../exposed/api/exposed"
    ubuntu = "../Ubuntu"
    
    # create obj path
    
    if not os.path.exists(path+"/../obj"):
        os.makedirs(path+"/../obj")
    
    subprocess.call(["make", "clean"], cwd=path)
    subprocess.call("make", cwd=path)
    subprocess.call(["cp", "{libslvs.so, _slvs.so, slvs.py}", ubuntu], cwd=path)
    subprocess.call(["python3", "circle_ex.py"], cwd=path+"/"+ubuntu)
    
make = threading.Thread(target=domake)
make.start()
```
</t>
<t tx="yen.20170120110024.16">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="yen.20170120110024.17">## 使用 iframe 導入影片

### 導入影片 template

&lt;iframe src="https://player.vimeo.com/video/183950627" width="640" height="492" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
</t>
<t tx="yen.20170120110024.2">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
@others
&lt;/html&gt;
</t>
<t tx="yen.20170120110024.3">&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
&lt;title&gt;
2017 Spring 機械設計工程系協同產品設計實習
&lt;/title&gt;
    &lt;meta name="description" content="A framework for easily creating beautiful presentations using HTML"&gt;
    &lt;meta name="author" content="Hakim El Hattab"&gt;
    
    &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;
    &lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"&gt;
    
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;
    
    &lt;link rel="stylesheet" href="https://cad-lab.github.io/cadlab_data/reveal/css/reveal.css"&gt;
    &lt;link rel="stylesheet" href="https://cad-lab.github.io/cadlab_data/reveal/css/theme/black.css" id="theme"&gt;
    
    &lt;!-- Theme used for syntax highlighting of code --&gt;
    &lt;link rel="stylesheet" href="https://cad-lab.github.io/cadlab_data/reveal/lib/css/zenburn.css"&gt;

    &lt;!-- Printing and PDF exports --&gt;
    &lt;script&gt;
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://cad-lab.github.io/cadlab_data/reveal/css/print/pdf.css' : 'https://cad-lab.github.io/cadlab_data/reveal/css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    &lt;/script&gt;

    &lt;!--[if lt IE 9]&gt;
    &lt;script src="https://cad-lab.github.io/cadlab_data/reveal/lib/js/html5shiv.js"&gt;&lt;/script&gt;
    &lt;![endif]--&gt;
&lt;/head&gt;

</t>
<t tx="yen.20170120110024.4">&lt;body&gt;
@others
&lt;script src="https://cad-lab.github.io/cadlab_data/reveal/lib/js/head.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cad-lab.github.io/cadlab_data/reveal/js/reveal.js"&gt;&lt;/script&gt;
&lt;script&gt;
        // More info https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            transition: 'slide', // none/fade/slide/convex/concave/zoom

            // More info https://github.com/hakimel/reveal.js#dependencies
            dependencies: [
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/zoom-js/zoom.js', async: true },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/notes/notes.js', async: true },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/math/math.js', async: true }
            ]
        });
&lt;/script&gt;
&lt;/body&gt;
</t>
<t tx="yen.20170120110024.5">&lt;div class="reveal"&gt;
@others
&lt;/div&gt;

</t>
<t tx="yen.20170120110024.6">&lt;!-- Any section element inside of this container is displayed as a slide --&gt;
&lt;div class="slides"&gt;
@others
&lt;/div&gt;

</t>
<t tx="yen.20170120110024.7">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="yen.20170120110024.8">## 2017Spring 協同產品設計實習

### 虎科大機械設計工程系

&lt;small&gt;
Created by [KMOLab](http://chiamingyen.github.io/kmolab/blog/)
&lt;/small&gt;

[協同產品設計實習課程網誌](blog/index.html)


</t>
<t tx="yen.20170120110024.9">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="yen.20170120212350.1"></t>
<t tx="yen.20170120212354.1">@language python
import calendar

#calendar.setfirstweekday(calendar.SUNDAY)
# 設每週第1天為星期日
cal = calendar.TextCalendar(calendar.SUNDAY)
# 直接印出文字月曆
#cal.prmonth(2017, 7)

try:
    g.es(cal.formatyear(2017, 2, 1, 1, 3))
except:
    print(cal.formatyear(2017, 2, 1, 1, 3))</t>
<t tx="yen.20170120212520.1">import calendar
import pprint

cal = calendar.Calendar(calendar.SUNDAY)

cal_data = cal.yeardays2calendar(2017, 3)
print('len(cal_data)      :', len(cal_data))

top_months = cal_data[0]
print('len(top_months)    :', len(top_months))

first_month = top_months[0]
print('len(first_month)   :', len(first_month))

print('first_month:')
pprint.pprint(first_month, width=65)</t>
<t tx="yen.20170120232548.1">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt; 
&lt;head&gt;
&lt;title&gt;Brython - 15-puzzle demo&lt;/title&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;

&lt;script type="text/javascript"
    src="/src/brython_dist.js"&gt;
&lt;/script&gt;


&lt;style type="text/css" media="screen"&gt;
  body { 
    font: 12px/15px Calibri, Verdana;
    margin: 0px;
    background:#ddd;
    padding: 0px;
  }
#container{
    position: absolute;
    border-width:1px;
    border-radius: 10px;
    border-style: solid;
    border-color: #000;
    background-color: #333;
}
#zone {
    position: absolute;
    background-color:#666;
    color: #fff;
    font-size: 16px;
    line-height:20px;
    padding: 0px;
}
.square{
    position: absolute;
    color: #000; 
    background: #fcfff4; /* old browsers */
    background: linear-gradient(to bottom, #fcfff4 0%,#dfe5d7 40%,#b3bead 100%);
    /* background-color: orange; */
    border-width: 1px;
    border-style: solid;
    border-radius: 5px;
    border-color: #200;
    text-align: center;
}
&lt;/style&gt;

&lt;meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;"/&gt;
&lt;/head&gt;   
&lt;body onload="brython(1)"&gt;

&lt;script type="text/python"&gt;
from browser import window, document, alert, html
import datetime
import calendar
import locale

w_height = window.innerHeight
w_width = window.innerWidth

locale.setlocale(locale.LC_ALL, '')

today = datetime.date.today()
year, month = today.year, today.month

zone = document["zone"]
c_width = w_width//7
c_height = w_height//6

cal = calendar.Calendar()

month_head = html.DIV('%s %s' %(calendar.month_name[month], year),
    style=dict(left=0, width=7*c_width),
    Class="square"
    )
zone &lt;= month_head

for dnum, day in enumerate(calendar.day_name):
    cell = html.DIV(day, 
        style=dict(left=dnum*c_width, top=20,
                   width=c_width, height=20),
        Class="square")
    zone &lt;= cell

for wnum, week in enumerate(cal.monthdatescalendar(year, month)):
    for dnum, day in enumerate(week):
        cell = html.DIV(day.day, 
            style=dict(left=dnum*c_width, top=40+wnum*c_height,
                       width=c_width, height=c_height,
                       lineHeight='%spx' %c_height),
            Class="square")
        if day.month == month:
            cell.style.color = "#000"
        else:
            cell.style.color = "#999"
        if day == today:
            cell.style.background = "linear-gradient(to bottom, #dcfff4 0%,#bfe5d7 40%,#93bead 100%)"
        zone &lt;= cell
&lt;/script&gt;

&lt;div id="container"&gt;
    &lt;div id="zone"&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</t>
<t tx="yen.20170123204227.1">&lt;style  type="text/css"&gt;
table{
    border: 1px solid black;
    table-layout: fixed;
    width: 100%;
    text-align: center;
}

th, td {
    width: 14%;
    text-align: center;
}
&lt;/style&gt;
&lt;div id="cal1"&gt;&lt;/div&gt;
&lt;script type="text/python3"&gt;
from browser import document, html
import calendar
import locale

z = html.DIV()
z.style = {"padding": "5px", 
               "backgroundColor": "#ADD8E6",
               "width": "50%"}
cal = calendar.HTMLCalendar(calendar.SUNDAY)
for i in range(1, 5):
    z.html += cal.formatmonth(2017, i)
document["cal1"] &lt;= z
&lt;/script&gt;

&lt;div id="cal2"&gt;&lt;/div&gt;
&lt;script type="text/python3"&gt;
from browser import document, html
import calendar
import locale

cal2 = document["cal2"]
'''
# default calendar MONDAY is the first day of the week
count = 0
output = "2017 2bCD (三) 08:10-12:00 各週上課日期: "
for month in range(2, 7):
    monthArray = calendar.monthcalendar(2017, month)
    for week in range(len(monthArray)):
        weekArray = monthArray[week]
        # 只需要列出星期三
        if weekArray[2] != 0:
            if month == 2:
                if weekArray[2] &gt; 20:
                    count += 1
                    if count &lt;= 18:
                        output += "W"+str(count)+"-"+ str(month)+ "/" + str(weekArray[2]) + ","
            else:
                count += 1
                if count &lt;= 18:
                    output += "W"+str(count)+"-"+ str(month)+ "/" + str(weekArray[2]) + ","
cal2 &lt;= output
'''

def getClassdate(year=2017, startM=2, startD=20, w=0, note=""):
    # w=0 表示課程排在星期一
    # startM 表示開學月份, startD 表示開學日
    # note 為課程初始告示
    # default calendar MONDAY is the first day of the week
    # 每學期共有 18 週
    totalW = 18
    count = 0
    # output = "2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: "
    output = note + html.BR()
    # 若必須全年搜尋則 7 改為 12, 但是因為只有 18 週, 因此邏輯要修改讓程式較快結束
    for month in range(startM, 7):
        monthArray = calendar.monthcalendar(2017, month)
        for week in range(len(monthArray)):
            weekArray = monthArray[week]
            # 只需要列出星期 (w+1)
            if weekArray[w] != 0:
                if month == startM:
                    if weekArray[startM] &gt; startD:
                        count += 1
                        if count &lt;= totalW:
                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
                else:
                    count += 1
                    if count &lt;=  totalW:
                        output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
    cal2 &lt;= output

# 2b 協同產品設計實習 (三 w=2)
getClassdate(year=2017, startM=2, startD=20, w=2, note="2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 2a 協同產品設計實習 (四 w=3)
getClassdate(year=2017, startM=2, startD=20, w=3, note="2017 Spring 2aCD (四) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring 1aWCM (五) 13:20-16:10 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# VE1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring VE1aCP (五) 18:30-20:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
&lt;/script&gt;</t>
<t tx="yen.20170124102405.1">from flask import Flask 
from flask_socketio import SocketIO, send

app = Flask(__name__)
app.config['SECRET_KEY'] = 'mysecret'
socketio = SocketIO(app)

@socketio.on('message')
def handleMessage(msg):
	print('Message: ' + msg)
	send(msg, broadcast=True)

if __name__ == '__main__':
	socketio.run(app)</t>
<t tx="yen.20170124102433.1">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Chat Room&lt;/title&gt;
&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.min.js"&gt;&lt;/script&gt;
&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="text/javascript"&gt;
$(document).ready(function() {

	var socket = io.connect('http://127.0.0.1:5000');

	socket.on('connect', function() {
		socket.send('User has connected!');
	});

	socket.on('message', function(msg) {
		$("#messages").append('&lt;li&gt;'+msg+'&lt;/li&gt;');
		console.log('Received message');
	});

	$('#sendbutton').on('click', function() {
		socket.send($('#myMessage').val());
		$('#myMessage').val('');
	});

});
&lt;/script&gt;
&lt;ul id="messages"&gt;&lt;/ul&gt;
&lt;input type="text" id="myMessage"&gt;
&lt;button id="sendbutton"&gt;Send&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</t>
<t tx="yen.20170207091131.1">@language md
Title: 網際 Brython 程式執行環境
Date: 2017-02-07 11:00
Category: Course
Tags: brython, w1
Slug: brython-editor
Author: yen

Brython 程式環境可以用來練習許多 Python3 的簡單語法, 也可以納入 Javascript 程式庫, 利用 Ajax 模式結合網際瀏覽器與伺服器上的資源解決協同產品設計流程上的問題.

&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;!-- 導入 FileSaver 與 filereader --&gt;
&lt;script type="text/javascript" src="./../ace/FileSaver.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="./../ace/filereader.js"&gt;&lt;/script&gt;

&lt;!-- 導入 Brython 標準程式庫 --&gt;
&lt;!--&lt;script type="text/javascript" src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;--&gt;

&lt;!-- 為了讓 import script1 可以正確運行, 停留在 Brython 3.2.9 版 --&gt;

&lt;script type="text/javascript" src="https://cdn.rawgit.com/brython-dev/brython/3.2.9/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

列出 2017 Spring 協同產品設計實習課程日期之 Python 程式碼如下:

&lt;pre class="brush: python"&gt;
&lt;div id="cal2"&gt;&lt;/div&gt;
&lt;script type="text/python3"&gt;
from browser import document, html
import calendar
import locale

cal2 = document["cal2"]

def getClassdate(year=2017, startM=2, startD=20, w=0, note=""):
    # w=0 表示課程排在星期一
    # startM 表示開學月份, startD 表示開學日
    # note 為課程初始告示
    # default calendar MONDAY is the first day of the week
    # 每學期共有 18 週
    totalW = 18
    count = 0
    # output = "2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: "
    output = note + html.BR()
    # 若必須全年搜尋則 7 改為 12, 但是因為只有 18 週, 因此邏輯要修改讓程式較快結束
    for month in range(startM, 7):
        monthArray = calendar.monthcalendar(2017, month)
        for week in range(len(monthArray)):
            weekArray = monthArray[week]
            # 只需要列出星期 (w+1)
            if weekArray[w] != 0:
                if month == startM:
                    if weekArray[startM] &gt; startD:
                        count += 1
                        if count &lt;= totalW:
                            if month == 3 and weekArray[w] == 31:
                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "
                            else:
                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
                else:
                    count += 1
                    if count &lt;=  totalW:
                        if month == 3 and weekArray[w] == 31:
                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "
                        else:
                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
    cal2 &lt;= output

# 2b 協同產品設計實習 (三 w=2)
getClassdate(year=2017, startM=2, startD=20, w=2, note="2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 2a 協同產品設計實習 (四 w=3)
getClassdate(year=2017, startM=2, startD=20, w=3, note="2017 Spring 2aCD (四) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring 1aWCM (五) 13:20-16:10 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# VE1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring VE1aCP (五) 18:30-20:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
&lt;/script&gt;
&lt;/pre&gt;

### 利用伺服器執行 Python3 程式

Jupyterhub: &lt;a href="https://8888.kmol.info:9443"&gt;https://8888.kmol.info:9443&lt;/a&gt;

### 利用以下的編輯器執行 Python3 程式

在 Firefox 中, 以 Preferences - General - Downloads 選擇"Always ask me where to save files"

在 Chrome 中, 以 Settings - Advanced - Downloads 選擇 Ask where to save each file before downloading

&lt;script src="./../ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="./../ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="./../ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="./../ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;
&lt;script type="text/javascript"&gt;
function doSave(){
    var blob = new Blob([localStorage["py_src"]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById('filename').value
    saveAs(blob, filename+".py");
}
&lt;/script&gt;

&lt;script type="text/python3" id="script1"&gt;
import sys
import time
import traceback
import javascript

from browser import document as doc, window, alert

has_ace = True
try:
    editor = window.ace.edit("editor")
    session = editor.getSession()
    session.setMode("ace/mode/python")

    editor.setOptions({
     'enableLiveAutocompletion': True,
     'enableSnippets': True,
     'highlightActiveLine': False,
     'highlightSelectedWord': True
    })
except:
    from browser import html
    editor = html.TEXTAREA(rows=20, cols=70)
    doc["editor"] &lt;= editor
    def get_value(): return editor.value
    def set_value(x):editor.value = x
    editor.getValue = get_value
    editor.setValue = set_value
    has_ace = False

if hasattr(window, 'localStorage'):
    from browser.local_storage import storage
else:
    storage = None

def reset_src():
    if storage is not None and "py_src" in storage:
        editor.setValue(storage["py_src"])
    else:
        editor.setValue('for i in range(10):\n\tprint(i)')
    editor.scrollToRow(0)
    editor.gotoLine(0)

def reset_src_area():
    if storage and "py_src" in storage:
        editor.value = storage["py_src"]
    else:
        editor.value = 'for i in range(10):\n\tprint(i)'

class cOutput:

    def __init__(self,target):
        self.target = doc[target]
    def write(self,data):
        self.target.value += str(data)
        

#if "console" in doc:
sys.stdout = cOutput("console")
sys.stderr = cOutput("console")

def to_str(xx):
    return str(xx)

info = sys.implementation.version
doc['version'].text = 'Brython %s.%s.%s' % (info.major, info.minor, info.micro)

output = ''

def show_console(ev):
    doc["console"].value = output
    doc["console"].cols = 60
    doc["console"].rows = 10

# load a Python script
def load_script(evt):
    _name = evt.target.value + '?foo=%s' % time.time()
    editor.setValue(open(_name).read())

# run a script, in global namespace if in_globals is True
def run(*args):
    global output
    doc["console"].value = ''
    src = editor.getValue()
    if storage is not None:
       storage["py_src"] = src

    t0 = time.perf_counter()
    try:
        #ns = {'__name__':'__main__'}
        ns = {'__name__':'editor'}
        exec(src, ns)
        state = 1
    except Exception as exc:
        traceback.print_exc(file=sys.stderr)
        state = 0
    output = doc["console"].value

    print('&lt;completed in %6.2f ms&gt;' % ((time.perf_counter() - t0) * 1000.0))
    return state

if has_ace:
    reset_src()
else:
    reset_src_area()
    
def clear_console(ev):
    doc["console"].value = ""

doc['run'].bind('click',run)
doc['show_console'].bind('click',show_console)
doc['clear_console'].bind('click',clear_console)
&lt;/script&gt;

&lt;div id="version"&gt;&lt;/div&gt;
&lt;div id="editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave();"/&gt;
&lt;/form&gt;
&lt;button id="run"&gt;Run&lt;/button&gt;
&lt;button id="show_console"&gt;Output&lt;/button&gt;
&lt;button id="clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="common"&gt;&lt;/div&gt;
@others</t>
<t tx="yen.20170207091131.2">
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex1(ev):
    script1.editor.setValue('''#ex1 簡單的 for 迴圈範例
    for i in range(10):
        print(i)
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex1'].bind('click',ex1)
&lt;/script&gt;&lt;a id="ex1"&gt;ex1&lt;/a&gt;-for 迴圈
</t>
<t tx="yen.20170207091131.3">
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex2(ev):
    script1.editor.setValue('''#溫度轉換程式
from browser import document as doc

# 因為此函式與滑鼠互動, 需要 event 當作輸入
def convTemp():
    mystring = ""
    cdegree = input("請輸入攝氏溫度:")
    fdegree = float(cdegree)*9/5 + 32
    output_string = "攝氏 " + str(cdegree) + "度=華氏 " + str(fdegree) + "度" 
    # 利用 print() 將轉換結果送到 console 區
    print(output_string)

#直接呼叫 convTemp() 執行
convTemp()
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex2'].bind('click',ex2)
&lt;/script&gt;&lt;a id="ex2"&gt;ex2&lt;/a&gt;-溫度換算</t>
<t tx="yen.20170207091131.4">
&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_file(e):
    data = open("./../python_ex/for1.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
    
document["get"].bind("click", get_file)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_temp1(e):
    data = open("./../python_ex/temp1.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
    
document["get_temp1"].bind("click", get_temp1)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_ver_and_kw(e):
    data = open("./../python_ex/ver_and_kw.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
    
document["get_ver_and_kw"].bind("click", get_ver_and_kw)
&lt;/script&gt;

&lt;button id="get"&gt;for1.py&lt;/button&gt;&lt;button id="get_temp1"&gt;temp1.py&lt;/button&gt;&lt;button id="get_ver_and_kw"&gt;ver_and_kw.py&lt;/button&gt;
</t>
<t tx="yen.20170207092354.1">##利用 IPv6 網路傳輸設計檔案

&lt;pre class="brush: python"&gt;
import socket
from http.server import HTTPServer, SimpleHTTPRequestHandler

class MyHandler(SimpleHTTPRequestHandler):
  def do_GET(self):
    if self.path == '/ip':
      self.send_response(200)
      self.send_header('Content-type', 'text/html')
      self.end_headers()
      self.wfile.write('Your IP address is %s' % self.client_address[0])
      return
    else:
      return SimpleHTTPRequestHandler.do_GET(self)

class HTTPServerV6(HTTPServer):
  address_family = socket.AF_INET6

def main():
  server = HTTPServerV6(('::', 8080), MyHandler)
  server.serve_forever()

if __name__ == '__main__':
  main()
&lt;/pre&gt;


##電腦的多重處理

&lt;a href="http://www.davekuhlman.org/python_multiprocessing_01.html"&gt;http://www.davekuhlman.org/python_multiprocessing_01.html&lt;/a&gt;

xmlrpc server:

&lt;pre class="brush: python"&gt;
from xmlrpc.server import SimpleXMLRPCServer
from xmlrpc.server import SimpleXMLRPCRequestHandler

# Restrict to a particular path.
class RequestHandler(SimpleXMLRPCRequestHandler):
    rpc_paths = ('/RPC2',)

# Create server
with SimpleXMLRPCServer(("localhost", 8000),
                        requestHandler=RequestHandler) as server:
    server.register_introspection_functions()

    # Register pow() function; this will use the value of
    # pow.__name__ as the name, which is just 'pow'.
    server.register_function(pow)

    # Register a function under a different name
    def adder_function(x,y):
        return x + y
    server.register_function(adder_function, 'add')

    # Register an instance; all the methods of the instance are
    # published as XML-RPC methods (in this case, just 'mul').
    class MyFuncs:
        def mul(self, x, y):
            return x * y

    server.register_instance(MyFuncs())

    # Run the server's main loop
    server.serve_forever()
&lt;/pre&gt;

xmlrpc client:

&lt;pre class="brush: python"&gt;
import xmlrpc.client

s = xmlrpc.client.ServerProxy('http://localhost:8000')
print(s.pow(2,3))  # Returns 2**3 = 8
print(s.add(2,3))  # Returns 5
print(s.mul(5,2))  # Returns 5*2 = 10

# Print list of available methods
print(s.system.listMethods())
&lt;/pre&gt;

Another xmlrpc server:

&lt;pre class="brush: python"&gt;
import datetime

class ExampleService:
    def getData(self):
        return '42'

    class currentTime:
        @staticmethod
        def getCurrentTime():
            return datetime.datetime.now()

with SimpleXMLRPCServer(("localhost", 8000)) as server:
    server.register_function(pow)
    server.register_function(lambda x,y: x+y, 'add')
    server.register_instance(ExampleService(), allow_dotted_names=True)
    server.register_multicall_functions()
    print('Serving XML-RPC on localhost port 8000')
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nKeyboard interrupt received, exiting.")
        sys.exit(0)
&lt;/pre&gt;

Another xmlrpc client:

&lt;pre class="brush: python"&gt;
import xmlrpc.client

server = xmlrpc.client.ServerProxy("http://localhost:8000")

try:
    print(server.currentTime.getCurrentTime())
except Error as v:
    print("ERROR", v)

multi = MultiCall(server)
multi.getData()
multi.pow(2,9)
multi.add(1,2)
try:
    for response in multi():
        print(response)
except Error as v:
    print("ERROR", v)
&lt;/pre&gt;

ssl xmlrpc:

&lt;pre class="brush: python"&gt;
"""Monkey patching standard xmlrpc.server.SimpleXMLRPCServer
to run over TLS (SSL)

Changes inspired on http://www.cs.technion.ac.il/~danken/SecureXMLRPCServer.py
"""
import socket
import socketserver
import ssl
from xmlrpc.server import SimpleXMLRPCServer, SimpleXMLRPCDispatcher, SimpleXMLRPCRequestHandler
try:
    import fcntl
except ImportError:
    fcntl = None


class SimpleXMLRPCServerTLS(SimpleXMLRPCServer):
    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None, bind_and_activate=True):
        """Overriding __init__ method of the SimpleXMLRPCServer

        The method is an exact copy, except the TCPServer __init__
        call, which is rewritten using TLS
        """
        self.logRequests = logRequests

        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)

        """This is the modified part. Original code was:

            socketserver.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)

        which executed:

            def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):
                BaseServer.__init__(self, server_address, RequestHandlerClass)
                self.socket = socket.socket(self.address_family,
                                            self.socket_type)
                if bind_and_activate:
                    self.server_bind()
                    self.server_activate()

        """
        socketserver.BaseServer.__init__(self, addr, requestHandler)
        self.socket = ssl.wrap_socket(
            socket.socket(self.address_family, self.socket_type),
            server_side=True,
            certfile='cert.pem',
            cert_reqs=ssl.CERT_NONE,
            ssl_version=ssl.PROTOCOL_SSLv23,
            )
        if bind_and_activate:
            self.server_bind()
            self.server_activate()

        """End of modified part"""

        # [Bug #1222790] If possible, set close-on-exec flag; if a
        # method spawns a subprocess, the subprocess shouldn't have
        # the listening socket open.
        if fcntl is not None and hasattr(fcntl, 'FD_CLOEXEC'):
            flags = fcntl.fcntl(self.fileno(), fcntl.F_GETFD)
            flags |= fcntl.FD_CLOEXEC
            fcntl.fcntl(self.fileno(), fcntl.F_SETFD, flags)
&lt;/pre&gt;

 Server端
 
 
&lt;pre class="brush: python"&gt;
#Python 2
#import SimpleXMLRPCServer
#Python 3
import xmlrpc.server

host = "127.0.0.1"
port = 1234

def handle(msg):
    #Python 2
    #print "Handle message: " + msg
    #Python 3
    print("Handle message: " + msg)

    ret = "Hello! I have received your message."
    return ret

def main():
    #Python 2
    #server = SimpleXMLRPCServer.SimpleXMLRPCServer((host, port))
    #Python 3
    server = xmlrpc.server.SimpleXMLRPCServer((host, port))

    server.register_function(handle)
    server.serve_forever()

if __name__ == "__main__":
    main()
&lt;/pre&gt;

Client端:

&lt;pre class="brush: python"&gt;
#Python 2
#import xmlrpclib
#Python 3
import xmlrpc.client

host = "http://127.0.0.1:1234"

def main():
    #Python 2
    #server = xmlrpclib.ServerProxy(hots)
    #Python 3
    server = xmlrpc.client.ServerProxy(host)

    result = server.handle("Welcome.")

    #Python 2
    #print result
    #Python 3
    print(result)

if __name__ == "__main__":
    main()
&lt;/pre&gt;


有一些地方要注意：

    Python 2 和Python 3 的 xmlrpc library不同，範例裡有用註解表示Python 2的寫法。
    
    Python 2 和Python 3 的print也不同。
    
    SimpleXMLRPCServer() 的參數是 tuple 型態，host 要給字串，port 要給整數。
    
    server的host設定為127.0.0.1，client就只能連線到127.0.0.1；換句話說，server的host若設定成192.168.1.1，client即使在本機，也不能透過127.0.0.1連線，只能連線到192.168.1.1。
    
    client端呼叫一次server端的handle()，socket連線即結束；要再次呼叫的話，要再執行一次ServerProxy()。
    
    server端可以一次註冊多個function。
    
    serve_forever()要放在最後面呼叫，因為呼叫完即進入server的main routine。
    
&lt;a href="https://github.com/etopian/python3-xmlrpc-ssl-basic-auth"&gt;https://github.com/etopian/python3-xmlrpc-ssl-basic-auth&lt;/a&gt;

&lt;pre class="brush: python"&gt;
'''
Created on Jun 20, 2011

XMLRPC server to run over HTTPS

@author: mraposa
'''
import socket
import socketserver
import ssl
import pickle
import xmlrpc.client
from xmlrpc.server import SimpleXMLRPCServer, SimpleXMLRPCDispatcher, SimpleXMLRPCRequestHandler
try:
    import fcntl
except ImportError:
    fcntl = None

#    Easiest way to create the key file pair was to use OpenSSL -- http://openssl.org/ Windows binaries are available
#    You can create a self-signed certificate easily "openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout privatekey.pem"
#    for more information --  http://docs.python.org/library/ssl.html#ssl-certificates
KEYFILE='c:\\delete\\privatekey.pem'    # Replace with your PEM formatted key file
CERTFILE='c:\\delete\\cert.pem'  # Replace with your PEM formatted certificate file

userPassDict = {"mraposa":"test123",
                "jsmith":"hellow"}
   
class SimpleXMLRPCServerTLS(SimpleXMLRPCServer):
    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None, bind_and_activate=True):
        """Overriding __init__ method of the SimpleXMLRPCServer

        The method is an exact copy, except the TCPServer __init__
        call, which is rewritten using TLS
        """
        self.logRequests = logRequests

        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)

        """This is the modified part. Original code was:

            socketserver.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)

        which executed:

            def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):
                BaseServer.__init__(self, server_address, RequestHandlerClass)
                self.socket = socket.socket(self.address_family,
                                            self.socket_type)
                if bind_and_activate:
                    self.server_bind()
                    self.server_activate()

        """
        class VerifyingRequestHandler(SimpleXMLRPCRequestHandler):
            '''
            Request Handler that verifies username and password passed to
            XML RPC server in HTTP URL sent by client.
            '''
            # this is the method we must override
            def parse_request(self):
                # first, call the original implementation which returns
                # True if all OK so far
                if SimpleXMLRPCRequestHandler.parse_request(self):
                    # next we authenticate
                    if self.authenticate(self.headers):
                        return True
                    else:
                        # if authentication fails, tell the client
                        self.send_error(401, 'Authentication failed')
                return False
           
            def authenticate(self, headers):
                from base64 import b64decode
                #    Confirm that Authorization header is set to Basic
                (basic, _, encoded) = headers.get('Authorization').partition(' ')
                assert basic == 'Basic', 'Only basic authentication supported'
               
                #    Encoded portion of the header is a string
                #    Need to convert to bytestring
                encodedByteString = encoded.encode()
                #    Decode Base64 byte String to a decoded Byte String
                decodedBytes = b64decode(encodedByteString)
                #    Convert from byte string to a regular String
                decodedString = decodedBytes.decode()
                #    Get the username and password from the string
                (username, _, password) = decodedString.partition(':')
                #    Check that username and password match internal global dictionary
                if username in userPassDict:
                    if userPassDict[username] == password:
                        return True
                return False
       
        #    Override the normal socket methods with an SSL socket
        socketserver.BaseServer.__init__(self, addr, VerifyingRequestHandler)
        self.socket = ssl.wrap_socket(
            socket.socket(self.address_family, self.socket_type),
            server_side=True,
            keyfile=KEYFILE,
            certfile=CERTFILE,
            cert_reqs=ssl.CERT_NONE,
            ssl_version=ssl.PROTOCOL_SSLv23,
            )
        if bind_and_activate:
            self.server_bind()
            self.server_activate()

        """End of modified part"""

        # [Bug #1222790] If possible, set close-on-exec flag; if a
        # method spawns a subprocess, the subprocess shouldn't have
        # the listening socket open.
        if fcntl is not None and hasattr(fcntl, 'FD_CLOEXEC'):
            flags = fcntl.fcntl(self.fileno(), fcntl.F_GETFD)
            flags |= fcntl.FD_CLOEXEC
            fcntl.fcntl(self.fileno(), fcntl.F_SETFD, flags)

# Restrict to a particular path.
class RequestHandler(SimpleXMLRPCRequestHandler):
    rpc_paths = ('/RPC2',)

def executeRpcServer():
    # Create server
    server = SimpleXMLRPCServerTLS(("localhost", 443), requestHandler=RequestHandler)
    server.register_introspection_functions()

    # Register pow() function; this will use the value of
    # pow.__name__ as the name, which is just 'pow'.
    server.register_function(pow)

    # Register a function under a different name
    def adder_function(x,y):
        return x + y
    server.register_function(adder_function, 'add')

    # Register an instance; all the methods of the instance are
    # published as XML-RPC methods (in this case, just 'div').
    class MyFuncs:
        def div(self, x, y):
            return x // y
       
        def enterUID(self, uid):
            print (uid)
            return "Got uid " + uid
       
        #    For this test pickle function I am assuming the pickled object is just a list
        def uploadPickle(self, pickleStringBinary):
            #    Get the binary data from the pickled string
            pickleData = pickleStringBinary.data
            #    Unpickle the data into an object
            pickObject = pickle.loads(pickleData)
            #    Print the object to test
            print (pickObject[-1])
            #    Modify the object to test
            pickObject.append("Server got pickled object")
            #    Pickle the object. Protocol=2 is required to support Python v2 clients
            newPickleString = pickle.dumps(pickObject, protocol=2)
            #    Label the string binary and send it back to the XML client
            return xmlrpc.client.Binary(newPickleString)

    server.register_instance(MyFuncs())

    # Run the server's main loop
    print("Starting XML RPC Server")
    server.serve_forever()


if __name__ == '__main__':  
    executeRpcServer()

 

The client code would look something like this:

def xmlRpcClient(pickableObject):
    '''
    Connects to RPC server for HTTPs. This is simply a demo function to showcase
    what can be done.
    @param pickleString:
    '''

    import pickle
    import xmlrpclib

    #    Connects to server
    #    Can only connect over HTTPS with HTTPS server
    #    Server supports passing username and password
    s = xmlrpclib.ServerProxy('https://mraposa:test123@localhost:443')
    #     Runs various functions on the remote server
    print s.pow(2,3)  # Returns 2**3 = 8
    print s.add(2,3)  # Returns 5
    print s.div(5,2)  # Returns 5//2 = 2
   
    #    Uploads a pickable object to XML RPC server.
    #    First pickles the object into a string -- Uses protocol=2 to enforce Python 2 vs 3 compatibility
    #    Then send the string as a binary over XMLRPC. Sending a string results in conversion errors from
    #    Python 2 to 3
    #    Server returns a binary pickled object back
    pickleString = pickle.dumps(pickableObject, protocol=2)
    newPickleStringBinary = s.uploadPickle(xmlrpclib.Binary(pickleString))
   
    #    gets Binary data from returned results
    newPickleString = newPickleStringBinary.data
    #    Load the new pickle data into a new object
    newPickleObject = pickle.loads(newPickleString)
    print ("Client got object: " + newPickleObject[-1])

    # Print list of available methods
    print s.system.listMethods()
&lt;/pre&gt;

Python dokuwiki:

&lt;a href="https://github.com/fmenabe/python-dokuwiki"&gt;https://github.com/fmenabe/python-dokuwiki&lt;/a&gt;

Qpython:

&lt;a href="http://qpython.com/"&gt;http://qpython.com/&lt;/a&gt;

Kivy:

&lt;a href="https://kivy.org/#home"&gt;https://kivy.org/#home&lt;/a&gt;

##Asynchronous JavaScript and XML

Ajax for Brython:

&lt;a href="http://stackoverflow.com/questions/26021672/how-to-use-ajax-in-brython"&gt;http://stackoverflow.com/questions/26021672/how-to-use-ajax-in-brython&lt;/a&gt;

##Chat 工具

建立一個 chat 工具:

&lt;a href=""https://github.com/PrettyPrinted/flask-socketio-chat&gt;https://github.com/PrettyPrinted/flask-socketio-chat&lt;/a&gt;

&lt;a href="https://blog.miguelgrinberg.com/post/easy-websockets-with-flask-and-gevent"&gt;https://blog.miguelgrinberg.com/post/easy-websockets-with-flask-and-gevent&lt;/a&gt;

&lt;a href="https://github.com/callmephilip/chatzilla"&gt;https://github.com/callmephilip/chatzilla&lt;/a&gt;

##雲端空間

&lt;a href="https://www.heroku.com/pricing"&gt;https://www.heroku.com/pricing&lt;/a&gt;

#計算機程式課程回顧

##電腦基本知識

###電腦基本軟硬體設定

操作系統

網路設定

###近端與與遠端檔案管理

可攜程式環境

robodk based programming 

glowscript based simulation

brython based simulation

git 與 github

計算機程式課程的目的, 在利用 Leo Editor 與 Brython 導入 Python3 單機與網際程式環境, 讓學員能夠利用 Python3 程式語法管理機械設計資料, 並且利用網際程式進行基本的機械設計工程分析.

##管理機械設計資料

##機械設計工程分析

#電腦輔助設計實習課程回顧

電腦輔助設計實習課程的目的, 在銜接計算機程式課程, 利用 3D 參數繪圖與設計軟體, 進一步導入較為具像的產品設計內容, 其中包括產品零件的設計與繪圖, 產品機構的運動分析, 產品功能的展示等.

四連桿 - Solvespace - V-rep - arduino stepper motor control

八連桿 - Solvespace - V-rep - arduino stepper motor control

#協同產品設計實習

2D 齒輪組傳動囓合設計繪圖

3D 齒輪組傳動囓合設計繪圖

Onshape featurescript

電腦輔助設計實習課程的目的, 在銜接計算機程式與電腦輔助設計實習課程, 主要利用 Onshape 與 Github 讓學員進行分組同步與非同步產品開發實習.

##Onshape 同步協同

同步協同原理

同步協同優缺點

##Github 非同步協同

非同步協同原理

非同步協同優缺點

##協同設計題目: 機械計時器(?)

機械計時器 (mechanical clock) 協同設計 (Jupyterlab, solvespace 與 onshape)、模擬 (V-rep)與製作 (delta printer)

以機械傳動顯示計時器之秒、分與時數, 協同設計佔 30%, 模擬佔 30%, 製作佔 40%.

協同設計 - 協同性、創新性、實用性, 所有資料都必須以 Leo Editor, Pelican 網誌與 Reveal 簡報展示.

系統模擬 - 必須以 Solvespace + Onshape 設計零組件, 並在 V-rep 中模擬, 並且以 Jupyterlab 執行運算分析.

### 利用伺服器執行 Python3 程式

Jupyterhub: &lt;a href="https://8888.kmol.info:9443"&gt;https://8888.kmol.info:9443&lt;/a&gt;</t>
<t tx="yen.20170209024032.1">https://studywolf.wordpress.com/

https://github.com/studywolf/blog/tree/master/VREP

https://www.youtube.com/channel/UCiK0J5wtnyX2jP-AiGbdhjg

V-rep

http://www.cnblogs.com/21207-iHome/tag/V-rep/</t>
<t tx="yen.20170210153828.1">根據 http://www.coppeliarobotics.com/helpFiles/en/remoteApiServerSide.htm 中的說明.

V-rep 啟動時, 會根據系統目錄下的 remoteApiConnections.txt 檔案中的設定, 啟動  rempte api 功能:

// This file defines all the continuous remote API server services (started at remote API plugin initialization, i.e. V-REP start-up)
//
// Each remote API server service requires following 3 entries:
//
// portIndex@_port = xxxx               // where xxxx is the desired port number (below 19997 are preferred for server services starting at V-REP start-up)
// portIndex@_debug = xxxx              // where xxxx is true or false
// portIndex@_syncSimTrigger = xxxx     // where xxxx is true or false. When true, then the service will be pre-enabled for synchronous operation.
//
// In above strings, @ can be any number starting with 1. If more than one server service is required, then numbers need to be consecutive and starting with 1

// Let's start a continuous remote API server service on port 19997:
portIndex1_port             = 19997
portIndex1_debug            = false
portIndex1_syncSimTrigger   = true

若要自行加入 rempte api 執行的 port 則在 server 的 child script 中設定:

Server 端:

simExtRemoteApiStart(19999)

Client 端:

clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5)

import vrep
import sys
# child threaded script: 
# 內建使用 port 19997 若要加入其他 port, 在  serve 端程式納入
#simExtRemoteApiStart(19999)
 
vrep.simxFinish(-1)
 
clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)
 
if clientID!= -1:
    print("Connected to remote server")
else:
    print('Connection not successful')
    sys.exit('Could not connect')
 
errorCode,Revolute_joint_handle=vrep.simxGetObjectHandle(clientID,'Revolute_joint',vrep.simx_opmode_oneshot_wait)
 
if errorCode == -1:
    print('Can not find left or right motor')
    sys.exit()
 
errorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint_handle,2, vrep.simx_opmode_oneshot_wait)

while True:
    choice = input("&gt;")
    if choice == "e":
        print("exiting")
        vrep.simxStopSimulation(clientID, vrep.simx_opmode_oneshot_wait)
        break
    elif choice == "p":
        vrep.simxPauseSimulation(clientID, vrep.simx_opmode_oneshot_wait)
    else:
        vrep.simxStartSimulation(clientID, vrep.simx_opmode_oneshot_wait)





</t>
<t tx="yen.20170210170248.1"># -*- coding: utf-8 -*-
try:
    import vrep
except:
    print ('--------------------------------------------------------------')
    print ('"vrep.py" could not be imported. This means very probably that')
    print ('either "vrep.py" or the remoteApi library could not be found.')
    print ('Make sure both are in the same folder as this file,')
    print ('or appropriately adjust the file "vrep.py"')
    print ('--------------------------------------------------------------')
    print ('')

import time
import sys
import ctypes

print ('Program started')
vrep.simxFinish(-1)
clientID=vrep.simxStart('127.0.0.1',19999,True,True,5000,5)

if clientID!=-1:
    print ('Connected to remote API server')
else:
    print ('Failed connecting to remote API server')
    sys.exit('Program Ended')

    
nominalLinearVelocity = 0.3
wheelRadius           = 0.027
interWheelDistance    = 0.119
    
res,objs=vrep.simxGetObjects(clientID, vrep.sim_handle_all,vrep.simx_opmode_blocking)
if res==vrep.simx_return_ok:
    print ('Number of objects in the scene: ',len(objs))
else:
    print ('Remote API function call returned with error code: ',res)

time.sleep(2)

startTime=time.time()
vrep.simxGetIntegerParameter(clientID,vrep.sim_intparam_mouse_x,vrep.simx_opmode_streaming)

res, display     = vrep.simxGetUIHandle(clientID, "sensorDisplay", vrep.simx_opmode_blocking)
res, leftSensor  = vrep.simxGetObjectHandle(clientID, "LeftSensor", vrep.simx_opmode_blocking)
res, middleSensor= vrep.simxGetObjectHandle(clientID, "MiddleSensor", vrep.simx_opmode_blocking)
res, rightSensor = vrep.simxGetObjectHandle(clientID, "RightSensor", vrep.simx_opmode_blocking)
res, leftJointDynamic  = vrep.simxGetObjectHandle(clientID, "DynamicLeftJoint" , vrep.simx_opmode_blocking)
res, rightJointDynamic = vrep.simxGetObjectHandle(clientID, "DynamicRightJoint", vrep.simx_opmode_blocking)

if res != vrep.simx_return_ok:
    print ('Failed to get sensor Handler')
    vrep.simxFinish(clientID)
    sys.exit('Program ended')

def setLeds(elHandle, left, middle, right):
    vrep.simxSetUIButtonProperty(clientID, elHandle,  8, 
        vrep.sim_buttonproperty_staydown, vrep.simx_opmode_oneshot)
    vrep.simxSetUIButtonProperty(clientID, elHandle, 16, 
        vrep.sim_buttonproperty_staydown, vrep.simx_opmode_oneshot)
    vrep.simxSetUIButtonProperty(clientID, elHandle, 24, 
        vrep.sim_buttonproperty_staydown, vrep.simx_opmode_oneshot)
    if left:
        vrep.simxSetUIButtonProperty(clientID, elHandle, 8, 
            vrep.sim_buttonproperty_staydown + vrep.sim_buttonproperty_isdown, vrep.simx_opmode_oneshot)
    if middle:
        vrep.simxSetUIButtonProperty(clientID, elHandle,16, 
            vrep.sim_buttonproperty_staydown + vrep.sim_buttonproperty_isdown, vrep.simx_opmode_oneshot)
    if right:
        vrep.simxSetUIButtonProperty(clientID, elHandle,24, 
            vrep.sim_buttonproperty_staydown + vrep.sim_buttonproperty_isdown, vrep.simx_opmode_oneshot)

sensorReading=[False, False, False]
sensorReading[0]=(vrep.simxReadVisionSensor(clientID, leftSensor,   vrep.simx_opmode_streaming )==1)
sensorReading[1]=(vrep.simxReadVisionSensor(clientID, middleSensor, vrep.simx_opmode_streaming )==1)
sensorReading[2]=(vrep.simxReadVisionSensor(clientID, rightSensor,  vrep.simx_opmode_streaming )==1)

while time.time() - startTime &lt; 50:
    returnCode,data=vrep.simxGetIntegerParameter(clientID,vrep.sim_intparam_mouse_x,vrep.simx_opmode_buffer) # Try to retrieve the streamed data
    
    # Read the sensors:

    sensorReading[0]=(vrep.simxReadVisionSensor(clientID, leftSensor,   vrep.simx_opmode_buffer)[1])
    sensorReading[1]=(vrep.simxReadVisionSensor(clientID, middleSensor, vrep.simx_opmode_buffer)[1])
    sensorReading[2]=(vrep.simxReadVisionSensor(clientID, rightSensor,  vrep.simx_opmode_buffer)[1])
    
    setLeds(display,sensorReading[0],sensorReading[1],sensorReading[2])

    # Decide about left and right velocities:
    s = 1.0
    linearVelocityLeft  = nominalLinearVelocity * s
    linearVelocityRight = nominalLinearVelocity * s

    if not sensorReading[0]:
        linearVelocityLeft  = linearVelocityLeft*0.3
    if not sensorReading[2]:
        linearVelocityRight = linearVelocityRight*0.3

    vrep.simxSetJointTargetVelocity(clientID, leftJointDynamic, linearVelocityLeft/(s*wheelRadius), vrep.simx_opmode_oneshot)
    vrep.simxSetJointTargetVelocity(clientID, rightJointDynamic,linearVelocityRight/(s*wheelRadius), vrep.simx_opmode_oneshot)
    
    time.sleep(0.005)</t>
<t tx="yen.20170210172100.1"># -*- coding: utf-8 -*-
# http://www.cnblogs.com/21207-iHome/p/5955535.html
import vrep             # V-rep library
import sys      
import time
import math  

# This function will convert an angle to the equivalent rotation in the range [-pi,pi]
def ConfineAngle(angle):
    angle = angle % (2.0 * math.pi)
    if( angle &lt; -math.pi ):
        angle += (2.0 * math.pi)
    if( angle &gt; math.pi ):
        angle -= (2.0 * math.pi)
    return angle


def CalcIK():
    id = linkNum - 1
    while id &gt;= 0:
        retcode, J_pos = vrep.simxGetObjectPosition(clientID,joint_handle[id],-1,vrep.simx_opmode_oneshot_wait)
        retcode, tip = vrep.simxGetObjectPosition(clientID,tip_handle, -1, vrep.simx_opmode_oneshot_wait)
        
        # Get the vector from the current bone to the end effector position.
        curToEndX = tip[0] - J_pos[0]
        curToEndY = tip[1] - J_pos[1]
        curToEndMag = math.sqrt( curToEndX*curToEndX + curToEndY*curToEndY )
          
        # Get the vector from the current bone to the target position.
        curToTargetX = target[0] - J_pos[0];
        curToTargetY = target[1] - J_pos[1];
        curToTargetMag = math.sqrt(curToTargetX*curToTargetX+curToTargetY*curToTargetY)
          
        # Get rotation 
        endTargetMag = curToEndMag*curToTargetMag
        if endTargetMag &lt;= 0.0001:    # prevent division by small numbers
            cosRotAng = 1
            sinRotAng = 0
        else:
            cosRotAng = (curToEndX*curToTargetX + curToEndY*curToTargetY) / endTargetMag
            sinRotAng = (curToEndX*curToTargetY - curToEndY*curToTargetX) / endTargetMag
        
        # Clamp the cosine into range when computing the angle(might be out of rangedue to floating point error)
        rotAng = math.acos(max(-1, min(1,cosRotAng)))
        if  sinRotAng &lt; 0.0:
            rotAng = -rotAng
                
        q[id] = q[id] + rotAng
        
        # Rotate the current link
        if(id == 0):
            vrep.simxSetJointPosition(clientID,joint_handle[id], ConfineAngle(q[id])+math.pi/2, vrep.simx_opmode_oneshot)
        else:
            vrep.simxSetJointPosition(clientID,joint_handle[id], ConfineAngle(q[id]), vrep.simx_opmode_oneshot)
        
        # Check for termination
        retcode, tip = vrep.simxGetObjectPosition(clientID,tip_handle, -1, vrep.simx_opmode_oneshot_wait)
        endToTargetX = (target[0] - tip[0])
        endToTargetY = (target[1] - tip[1])
        error = math.sqrt(endToTargetX*endToTargetX + endToTargetY*endToTargetY)
        if( error &lt;= stol ):
            # We found a valid solution.
            return 1, error
        id = id - 1
        
    return 0, error  # cannot get to the target in this iteration
    
    
        
if __name__ == "__main__":
    # Starts a communication thread with the server
    clientID = vrep.simxStart('127.0.0.1', 20001, True, True, 5000, 5)
    
    # clientID: the client ID, or -1 if the connection to the server was not possible
    if clientID != -1:  #check if client connection successful
        print 'Connected to remote API server'
    else:
        print 'Connection not successful'
        sys.exit('Could not connect')    # Exit from Python


    # Retrieves an object handle based on its name.
    errorCode,tip_handle = vrep.simxGetObjectHandle(clientID,'tip',vrep.simx_opmode_oneshot_wait)
    errorCode,target_handle = vrep.simxGetObjectHandle(clientID,'target',vrep.simx_opmode_oneshot_wait)
    errorCode,consoleHandle = vrep.simxAuxiliaryConsoleOpen(clientID,'info',4,1+4,None,None,None,None,vrep.simx_opmode_oneshot_wait)
    joint_handle = [-1,-1,-1]    # store the joint handles
    for i in range(3):
        errorCode,joint_handle[i] = vrep.simxGetObjectHandle(clientID,'j'+str(i+1),vrep.simx_opmode_oneshot_wait)

    ilimit = 100    # maximum iteration
    stol = 1e-2     # tolerance
    q = [0,0,0]     # initial joint value
    linkNum = 3     # number of links
    
    retcode, target = vrep.simxGetObjectPosition(clientID,target_handle, -1, vrep.simx_opmode_oneshot_wait)
    retcode, tip = vrep.simxGetObjectPosition(clientID,tip_handle, -1, vrep.simx_opmode_oneshot_wait)
    
    count = 0    
    isOK = 0
    while ( not isOK ):    
        isOK,err = CalcIK()
        
        vrep.simxAuxiliaryConsolePrint(clientID,consoleHandle,None,vrep.simx_opmode_oneshot_wait) 
        count = count + 1
        vrep.simxAuxiliaryConsolePrint(clientID,consoleHandle,str(count)+' iterations err:'+str(err),vrep.simx_opmode_oneshot_wait)   
        
        if count &gt; ilimit:
            vrep.simxAuxiliaryConsolePrint(clientID,consoleHandle,"Solution wouldn't converge\r\n",vrep.simx_opmode_oneshot_wait)
            break
        #time.sleep(0.1)
    
    # Ends the communication thread. This should be the very last remote API function called on the client side
    vrep.simxFinish(clientID)</t>
<t tx="yen.20170210202015.1">simxCloseScene
simxCopyPasteObjects
simxCreateDummy
simxDisplayDialog
simxEndDialog 
simxEraseFile
simxFinish
simxGetArrayParameter
</t>
<t tx="yen.20170210221519.1">import vrep
import sys
import time

print('Program started')

portNb = 0
leftMotorHandle = 0
rightMotorHandle = 0
sensorHandle = 0

if len(sys.argv) &gt;= 5:
    portNb = int(sys.argv[1])
    leftMotorHandle = int(sys.argv[2])
    rightMotorHandle = int(sys.argv[3])
    sensorHandle = int(sys.argv[4])
else:
    print("Indicate following arguments: 'portNumber leftMotorHandle rightMotorHandle sensorHandle'")
    time.sleep(5000.0 / 1000.0)
    sys.exit(0)

vrep.simxFinish(-1) # just in case, close all opened connections
clientID = vrep.simxStart('127.0.0.1', portNb, True, True, 2000, 5)
if clientID != -1:
    print 'Connected to remote API server'
    driveBackStartTime = -99000
    motorSpeeds = [0, 0]

    while vrep.simxGetConnectionId(clientID) != -1:
        (errorCode, detectionState, detectedPoint, detectedObjectHandle, detectedSurfaceNormalVector) = vrep.simxReadProximitySensor(clientID, sensorHandle, vrep.simx_opmode_streaming)
        if errorCode == vrep.simx_return_ok:
            simulationTime = vrep.simxGetLastCmdTime(clientID)
            if simulationTime - driveBackStartTime &lt; 3000:
                motorSpeeds[0] = -3.1415 * 0.5
                motorSpeeds[1] = -3.1415 * 0.25
            else:
                motorSpeeds[0] = 3.1415
                motorSpeeds[1] = 3.1415
                if detectionState:
                    driveBackStartTime = simulationTime

            errorCode = vrep.simxSetJointTargetVelocity(clientID, leftMotorHandle, motorSpeeds[0], vrep.simx_opmode_oneshot)
            vrep.simxSetJointTargetVelocity(clientID, rightMotorHandle, motorSpeeds[1], vrep.simx_opmode_oneshot)
            if errorCode != vrep.simx_return_ok:
                print("SetJointTargetVelocity got error code: %s" % errorCode)

        else:
            print("ReadProximitySensor got error code: %s" % errorCode)

        time.sleep(5.0 / 1000.0)

    vrep.simxFinish(clientID)
else:
    print('Failed connecting to remote API server')
print('Program ended')</t>
<t tx="yen.20170210222733.1">##==============================================================#
## SECTION: Imports                                             #
##==============================================================#

import vrep

##==============================================================#
## SECTION: Class Definitions                                   #
##==============================================================#

class Robot:
    def __init__(self, client_id, opmode):
        self.cid = client_id
        self.op = opmode

        # Setup wheel joints.
        self.wj_locs = ["Left","Right"]
        self.wjs = {}
        for loc in self.wj_locs:
            name = "Dynamic{0}Joint".format(loc)
            _,h = vrep.simxGetObjectHandle(client_id, name, opmode)
            self.wjs[loc] = h

        # Setup vision sensors.
        self.vs_locs = ["Left","Middle","Right"]
        self.vss = {}
        for loc in self.vs_locs:
            name = "{0}Sensor".format(loc)
            _,h = vrep.simxGetObjectHandle(client_id, name, opmode)
            self.vss[loc] = h

    def set_wheel_vel(self, left, right):
        """Sets the wheel target velocities."""
        vrep.simxSetJointTargetVelocity(self.cid, self.wjs['Left'], left, self.op)
        vrep.simxSetJointTargetVelocity(self.cid, self.wjs['Right'], right, self.op)

    def get_wheel_vel(self):
        """Returns the wheel velocities as a list of (left,right)."""
        vels = []
        for loc in self.wj_locs:
            _,vel = vrep.simxGetObjectFloatParameter(self.cid, self.wjs[loc], vrep.sim_jointfloatparam_velocity, self.op)
            vels.append(vel)
        return vels

    def get_vis_sensors(self):
        """Returns a list of lists containing the average red/green/blue value
        from the left/middle/right vision sensor."""
        aves = []
        for loc in self.vs_locs:
            h = self.vss[loc]
            _,_,pkt = vrep.simxReadVisionSensor(client_id, h, opmode)
            aves.append(pkt[0][11:14])
        return aves

##==============================================================#
## SECTION: Function Definitions                                #
##==============================================================#

def is_green(a):
    """Returns true if the reading from Robot.get_vis_sensors() is green."""
    return (a[0] &lt; 0.4 and a[2] &lt; 0.4) and (a[1] &gt; 0.5)

##==============================================================#
## SECTION: Main Body                                           #
##==============================================================#

if __name__ == '__main__':
    vrep.simxFinish(-1) # Stop any running simulation.
    client_id = vrep.simxStart("127.0.0.1", 19997, True, True, 5000, 5)
    if client_id == -1:
        print("Failed to connect.")
        exit()
    print("Connected to V-REP.")
    print("Running robot logic, will exit when simulation is ended...")
    try:
        opmode = vrep.simx_opmode_blocking
        vrep.simxStartSimulation(client_id, opmode)
        robot = Robot(client_id, opmode)
        robot.set_wheel_vel(1.0, 1.0)
        vrep.simxSynchronousTrigger(client_id)
        while True:
            # Very simple robot line following logic.
            l,m,r = robot.get_vis_sensors()
            if is_green(m):
                robot.set_wheel_vel(1.0, 1.0)
            elif is_green(l):
                robot.set_wheel_vel(0.2, 1.0)
            elif is_green(r):
                robot.set_wheel_vel(1.0, 0.2)
            vrep.simxSynchronousTrigger(client_id)
    except:
        vrep.simxFinish(client_id)
        print("Simulation ended.")
</t>
<t tx="yen.20170215103217.1"></t>
<t tx="yen.20170215103228.1"></t>
<t tx="yen.20170314213424.1">@language md
Title: 網際 Brython 3.3.1 程式執行環境 
Date: 2017-03-14 11:00
Category: Course
Tags: brython, w1
Slug: brython-editor-331
Author: yen

Brython 程式環境可以用來練習許多 Python3 的簡單語法, 也可以納入 Javascript 程式庫, 利用 Ajax 模式結合網際瀏覽器與伺服器上的資源解決協同產品設計流程上的問題.

&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;!-- 導入 FileSaver 與 filereader --&gt;
&lt;script type="text/javascript" src="./../ace/FileSaver.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="./../ace/filereader.js"&gt;&lt;/script&gt;

&lt;!-- 導入最新版的 Brython 標準程式庫 3.3.1 --&gt;
&lt;script type="text/javascript" src="./../data/brython_dist.js"&gt;
&lt;/script&gt;


&lt;!-- 啟動 Brython 時, 設定 pythonpath 為 data/py, 並將 script1.py 放入, 以便取代 3.2.9 之前版本的 script id 導入 --&gt;
&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

列出 2017 Spring 協同產品設計實習課程日期之 Python 程式碼如下:

&lt;pre class="brush: python"&gt;
&lt;div id="cal2"&gt;&lt;/div&gt;
&lt;script type="text/python3"&gt;
from browser import document, html
import calendar
import locale

cal2 = document["cal2"]

def getClassdate(year=2017, startM=2, startD=20, w=0, note=""):
    # w=0 表示課程排在星期一
    # startM 表示開學月份, startD 表示開學日
    # note 為課程初始告示
    # default calendar MONDAY is the first day of the week
    # 每學期共有 18 週
    totalW = 18
    count = 0
    # output = "2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: "
    output = note + html.BR()
    # 若必須全年搜尋則 7 改為 12, 但是因為只有 18 週, 因此邏輯要修改讓程式較快結束
    for month in range(startM, 7):
        monthArray = calendar.monthcalendar(2017, month)
        for week in range(len(monthArray)):
            weekArray = monthArray[week]
            # 只需要列出星期 (w+1)
            if weekArray[w] != 0:
                if month == startM:
                    if weekArray[startM] &gt; startD:
                        count += 1
                        if count &lt;= totalW:
                            if month == 3 and weekArray[w] == 31:
                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "
                            else:
                                output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
                else:
                    count += 1
                    if count &lt;=  totalW:
                        if month == 3 and weekArray[w] == 31:
                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + "(放假), "
                        else:
                            output += "w"+str(count)+"-"+ str(month)+ "/" + str(weekArray[w]) + ", "
    cal2 &lt;= output

# 2b 協同產品設計實習 (三 w=2)
getClassdate(year=2017, startM=2, startD=20, w=2, note="2017 Spring 2bCD (三) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 2a 協同產品設計實習 (四 w=3)
getClassdate(year=2017, startM=2, startD=20, w=3, note="2017 Spring 2aCD (四) 08:10-12:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# 1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring 1aWCM (五) 13:20-16:10 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
# VE1a 網際內容管理 (五 w=4)
getClassdate(year=2017, startM=2, startD=20, w=4, note="2017 Spring VE1aCP (五) 18:30-20:00 各週上課日期: ")
cal2 &lt;= html.BR() + html.BR()
&lt;/script&gt;
&lt;/pre&gt;

### 利用伺服器執行 Python3 程式

Jupyterhub: &lt;a href="https://8888.kmol.info:9443"&gt;https://8888.kmol.info:9443&lt;/a&gt;

### 利用以下的編輯器執行 Python3 程式

在 Firefox 中, 以 Preferences - General - Downloads 選擇"Always ask me where to save files"

在 Chrome 中, 以 Settings - Advanced - Downloads 選擇 Ask where to save each file before downloading

&lt;script src="./../ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="./../ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="./../ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="./../ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;
&lt;script type="text/javascript"&gt;
function doSave(){
    var blob = new Blob([localStorage["py_src"]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById('filename').value
    saveAs(blob, filename+".py");
}
&lt;/script&gt;

&lt;!-- 請注意 Brython 3.3.0 之後的版本, 已經不能使用 script id 模式導入, 改用 pythonpath 中的 script1.py 供後續導入 --&gt;

&lt;script type="text/python3" id="script1"&gt;
import sys
import time
import traceback
import javascript

from browser import document as doc, window, alert

has_ace = True
try:
    editor = window.ace.edit("editor")
    session = editor.getSession()
    session.setMode("ace/mode/python")

    editor.setOptions({
     'enableLiveAutocompletion': True,
     'enableSnippets': True,
     'highlightActiveLine': False,
     'highlightSelectedWord': True
    })
except:
    from browser import html
    editor = html.TEXTAREA(rows=20, cols=70)
    doc["editor"] &lt;= editor
    def get_value(): return editor.value
    def set_value(x):editor.value = x
    editor.getValue = get_value
    editor.setValue = set_value
    has_ace = False

if hasattr(window, 'localStorage'):
    from browser.local_storage import storage
else:
    storage = None

def reset_src():
    if storage is not None and "py_src" in storage:
        editor.setValue(storage["py_src"])
    else:
        editor.setValue('for i in range(10):\n\tprint(i)')
    editor.scrollToRow(0)
    editor.gotoLine(0)

def reset_src_area():
    if storage and "py_src" in storage:
        editor.value = storage["py_src"]
    else:
        editor.value = 'for i in range(10):\n\tprint(i)'

class cOutput:

    def __init__(self,target):
        self.target = doc[target]
    def write(self,data):
        self.target.value += str(data)
        

#if "console" in doc:
sys.stdout = cOutput("console")
sys.stderr = cOutput("console")

def to_str(xx):
    return str(xx)

info = sys.implementation.version
doc['version'].text = 'Brython %s.%s.%s' % (info.major, info.minor, info.micro)

output = ''

def show_console(ev):
    doc["console"].value = output
    doc["console"].cols = 60
    doc["console"].rows = 10

# load a Python script
def load_script(evt):
    _name = evt.target.value + '?foo=%s' % time.time()
    editor.setValue(open(_name).read())

# run a script, in global namespace if in_globals is True
def run(*args):
    global output
    doc["console"].value = ''
    src = editor.getValue()
    if storage is not None:
       storage["py_src"] = src

    t0 = time.perf_counter()
    try:
        #ns = {'__name__':'__main__'}
        ns = {'__name__':'editor'}
        exec(src, ns)
        state = 1
    except Exception as exc:
        traceback.print_exc(file=sys.stderr)
        state = 0
    output = doc["console"].value

    print('&lt;completed in %6.2f ms&gt;' % ((time.perf_counter() - t0) * 1000.0))
    return state

if has_ace:
    reset_src()
else:
    reset_src_area()
    
def clear_console(ev):
    doc["console"].value = ""

doc['run'].bind('click',run)
doc['show_console'].bind('click',show_console)
doc['clear_console'].bind('click',clear_console)
&lt;/script&gt;

&lt;div id="version"&gt;&lt;/div&gt;
&lt;div id="editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave();"/&gt;
&lt;/form&gt;
&lt;button id="run"&gt;Run&lt;/button&gt;
&lt;button id="show_console"&gt;Output&lt;/button&gt;
&lt;button id="clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="common"&gt;&lt;/div&gt;
@others</t>
<t tx="yen.20170314213424.2">
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex1(ev):
    script1.editor.setValue('''#ex1 簡單的 for 迴圈範例
    for i in range(10):
        print(i)
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex1'].bind('click',ex1)
&lt;/script&gt;&lt;a id="ex1"&gt;ex1&lt;/a&gt;-for 迴圈
</t>
<t tx="yen.20170314213424.3">
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex2(ev):
    script1.editor.setValue('''#溫度轉換程式
from browser import document as doc

# 因為此函式與滑鼠互動, 需要 event 當作輸入
def convTemp():
    mystring = ""
    cdegree = input("請輸入攝氏溫度:")
    fdegree = float(cdegree)*9/5 + 32
    output_string = "攝氏 " + str(cdegree) + "度=華氏 " + str(fdegree) + "度" 
    # 利用 print() 將轉換結果送到 console 區
    print(output_string)

#直接呼叫 convTemp() 執行
convTemp()
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex2'].bind('click',ex2)
&lt;/script&gt;&lt;a id="ex2"&gt;ex2&lt;/a&gt;-溫度換算</t>
<t tx="yen.20170314213424.4">
&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_file(e):
    data = open("./../python_ex/for1.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
    
document["get"].bind("click", get_file)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_temp1(e):
    data = open("./../python_ex/temp1.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
    
document["get_temp1"].bind("click", get_temp1)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def get_ver_and_kw(e):
    data = open("./../python_ex/ver_and_kw.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
    
document["get_ver_and_kw"].bind("click", get_ver_and_kw)
&lt;/script&gt;

&lt;script type="text/python3"&gt;
from browser import document
import script1

def jansen(e):
    data = open("./../python_ex/jansen.py").read()
    script1.editor.setValue(data)
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
    
document["jansen"].bind("click", jansen)
&lt;/script&gt;

&lt;button id="get"&gt;for1.py&lt;/button&gt;&lt;button id="get_temp1"&gt;temp1.py&lt;/button&gt;&lt;button id="get_ver_and_kw"&gt;ver_and_kw.py&lt;/button&gt;&lt;button id="jansen"&gt;jansen.py&lt;/button&gt;

Jansen 多連桿機構尺寸圖:

&lt;img src="./../data/jansen_sympy.png" width="800" /&gt;
</t>
<t tx="yen.20170314214818.1">
&lt;script type="text/python3"&gt;
from browser import document as doc
import script1

def ex3(ev):
    script1.editor.setValue('''#jansen 多連桿機構驗算
from math import pi, cos, sin, sqrt, acos

radian = 180/pi
degree = pi/180

#PLAP
def plap(ax, ay, ac, bac, bx, by, ccw):
    if ccw == 1:
        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    else:
        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    return cx, cy

#PLLP
def pllp(ax, ay, ac, cb, bx, by, cw):
    if cw == 1:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    else:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    return cx, cy

ax = -38
ay = 0
# b 為原點
bx = 0
by = 0
cx = 0
cy = 7.8
# m 為配合 PLAP 新增固定點
mx = 30
my = 7.8
# dcm ccw 方向角度
dcm = 30*degree
cd = 15
# 三角形 dcm 為 ccw plap d=(a, cd, dcm, m)
dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1)
print("dx=", dx, "dy=", dy)
# 三角形 aed 為 cw pllp e=(a, ae, ed, d)
ae = 41.5
ed = 50
ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1)
print("ex=", ex, "ey=", ey)
# 三角形 afe 為 cw pllp f=(a, af, fe, e)
af = 40.1
fe = 55.8
fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1)
print("fx=", fx, "fy=", fy)
# 三角形 dha 為 cw pllp h=(d, dh, ha, a)
dh = 61.9
ha = 39.3
hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1)
print("hx=", hx, "hy=", hy)
# 三角形 hgf 為 cw pllp g=(h, hg, gf, f)
hg = 36.7
gf = 39.4
gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1)
print("gx=", gx, "gy=", gy)
# 三角形 hkg 為 cw pllp k=(h, hk, kg, g)
hk = 49
kg = 65.7
kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1)
print("kx=", kx, "ky=", ky)
    ''')
    script1.editor.scrollToRow(0)
    script1.editor.gotoLine(0)
doc['ex3'].bind('click',ex3)
&lt;/script&gt;&lt;a id="ex3"&gt;ex3&lt;/a&gt;-多連桿機構</t>
<t tx="yen.20170503173014.1">  以下程式對應 canvas:
  
&lt;canvas id="cvs0" width="475" height="300"&gt;&lt;/canvas&gt;
  
&lt;script type="text/javascript"&gt;
    function distanceFromCurve(pt, bezNodes)
    {
      /* Calculates distance from point (pt) to the closest point on cubic Bezier curve (bez)
       * Algoritm suggested by Mike Kamermans http://pomax.github.io/bezierinfo/
       * Note: this is designed for well behaved Bezier curves only (no kinks)
       */
      var mu = 0.5,
          dMu = 1.0,
          dMuMin = 0.000001,
          testPt, testLft, testRgt;

      function pointOnBezier(p)
      {
        var x1 = bezNodes[0].x,
            y1 = bezNodes[0].y,
            x2 = bezNodes[1].x,
            y2 = bezNodes[1].y,
            x3 = bezNodes[2].x,
            y3 = bezNodes[2].y,
            x4 = bezNodes[3].x,
            y4 = bezNodes[3].y,
            f1 = function(t) { return (t*t*t); },
            f2 = function(t) { return (3*t*t*(1-t)); },
            f3 = function(t) { return (3*t*(1-t)*(1-t)); },
            f4 = function(t) { return ((1-t)*(1-t)*(1-t)); },
            /* p from 0 to 1 */
            bezX = function() { return x1*f1(p) + x2*f2(p) + x3*f3(p) + x4*f4(p); },
            bezY = function() { return y1*f1(p) + y2*f2(p) + y3*f3(p) + y4*f4(p); };

        return {x:bezX(), y:bezY()}
      }

      function calcDist(p, u)
      {
        var bezPt = pointOnBezier(u),
            distVal = Math.sqrt((bezPt.x-p.x)*(bezPt.x-p.x)+(bezPt.y-p.y)*(bezPt.y-p.y));

        return {distance: distVal, x: bezPt.x, y: bezPt.y};
      }

      do
      {
        testPt = calcDist(pt, mu);
        // half distance to left
        dMu /= 2;
        testLft = calcDist(pt, mu-dMu);
        testRgt = calcDist(pt, mu+dMu);
        if (testLft.distance&lt;testPt.distance)
        {
          mu -= dMu;
          if (mu&lt;0) { mu = 0; }
        }
        if (testRgt.distance&lt;testPt.distance)
        {
          mu += dMu;
          if (mu&gt;1) { mu = 1; }
        }
      }
      while (dMu&gt;dMuMin)

      return testPt;   // object {distance:, x:, y: }
    }

    function updateErrors(tbl, rowNum, str0, str1, str2)
    {
      var rowId = "t"+tbl+"row"+rowNum;
      var rowNode = document.getElementById(rowId);
      var tds = rowNode.getElementsByTagName("TD");   // array of TD elements
      tds[0].childNodes[0].nodeValue = str0;    // text node of TD element
      tds[1].childNodes[0].nodeValue = str1;
      tds[2].childNodes[0].nodeValue = str2;
    }

    function InvoluteDefined(cvsID, module, teeth, pressureAngle)
    {
      'use strict';
      var savThis = this,
          m, Z, phi, Rpitch, Rb, addendum, Ra,
          toothData, toothObj,
          pitchToBaseAngle,
          gear, invData,
          invMax, invMin,
          xspan, yspan,
          pt, A,
          cx1, cy1,
          c1,
          g, xmin, xmax, ymin, ymax,
          i, theta, newTooth;

      function toCartesian(radius, angle)
      {
        return {x: radius*Math.cos(angle), y: radius*Math.sin(angle)};
      }

      function genInvolute2(Rb, theta)
      {
        // given the parameter theta, return the x, y of the involute
        var ix = Rb*(Math.cos(theta) + theta*Math.sin(theta));
        var iy = Rb*(Math.sin(theta) - theta*Math.cos(theta));

        return {x:ix, y:iy};
      }

      function dragC1(mousePos)    // called in scope of dragNdrop obj
      {
        var xp, yp,
            wPos = {x:mousePos.x - this.grabOfs.x, y:mousePos.y - this.grabOfs.y};
// generate a value of A (involute generating angle) near to the drag point
// origin is at invMin and invMax is the end, get current pos as proportion of inv span
        xp = (wPos.x&lt;0)? 0: wPos.x/xspan;
        if (xp&gt;1)
        {
          xp = 1;
        }
        yp = (wPos.y&lt;0)? 0: wPos.y/yspan;
        if (yp&gt;1)
        {
          yp = 1;
        }
        A = Math.sqrt(0.707*Math.sqrt(xp*xp + yp*yp));
        pt = genInvolute2(Rb, A);
        cx1 = pt.x - Rb;
        cy1 = pt.y;
        savThis.drawInv();
      }

      g = new Cango(cvsID);      // g is the graphics context for the background
      xmin = -54;
      xmax = 20;
      ymin = -5;
      ymax = 40;

      g.setGridboxRHC();          // full canvas
      g.setWorldCoords(xmin, ymin, xmax-xmin);   // square pixels
      g.setPropertyDefault("fillColor", 'black');
      g.setPropertyDefault("fontSize", 12);
      // =============== DIN GEAR DESIGN ===================
      m = module;                // Module = teeth per inch of diamter
      Z = teeth;
      phi = pressureAngle || 20; // pressure angle in degs
      Rpitch = Z*m/2;                // pitch radius
      Rb = Rpitch*Math.cos(phi*Math.PI/180);  // base radius
      addendum = m;             // distance from pitch circle to outer circle
      Ra = Rpitch + addendum;       // addendum (outer) radius
      // generate gear tooth outline path
      toothData = createGearTooth(m, Z, phi);
      toothObj = new Path(toothData, {strokeColor:'red'});
      toothObj.rotate(-270/Z);
      // rotate the tooth to put start of involute on the x axis
      pitchToBaseAngle = (Math.sqrt(Rpitch*Rpitch - Rb*Rb)/Rb) - Math.acos(Rb/Rpitch);
      toothObj.rotate(180*pitchToBaseAngle/Math.PI);
      // make 5 teeth by duplicating
      gear = [];
      gear.push(toothObj);
      for (i=0, newTooth; i&lt;4; i++)
      {
        newTooth = toothObj.dup();
        newTooth.rotate(360*i/Z);
        gear.push(newTooth);
      }
      // now draw the extended involute
      invData = [];
      pt = {};
      for (theta=0; theta&lt;1; theta+= 0.05)   // step along involute by inc parameter
      {
        pt = genInvolute2(Rb, theta);
        invData.push(pt.x, pt.y);
      }
      invMax = genInvolute2(Rb, 1);
      invData.push(invMax.x, invMax.y);   // plot the last point (theta = 1 radian)
      invMin = {x:Rb, y: 0} ;
      xspan = invMax.x-invMin.x;      // use these when dragging dot
      yspan = invMax.y-invMin.y;
      A = 0.8;                    // initial involute generating angle 0.8 rads
      cx1 = 59.7-Rb;
      cy1 = 7.5;  // eqiv x,y on involute for 0.8 theta
      // compile the involute control point and make it draggable
      c1 = new Shape(shapeDefs.circle(2), {fillColor:'red', iso:true});
      c1.enableDrag(null, dragC1, null);

      this.showConst = false;    // show construction lines

      this.drawInv = function()
      {
        var compA, gPt, genLines;

        g.clearCanvas();
        g.drawAxes(xmin, xmax, ymin, ymax, {xOrigin:-Rb, yOrigin:0, yTickInterval:50, strokeColor:"#888888", fillColor:"#888888"});  // don't show y ticks
        g.render(gear, {x:-Rb, y:0});
        g.drawPath(shapeDefs.circle(Rb*2), {x:-Rb, y:0, strokeColor:'rgba(0,0,255,0.3)'});

        g.drawPath(invData, {x:-Rb, y:0, strokeColor:'magenta'});

        // draw generating right angle
        compA = Math.PI/2 - A;
        gPt = toCartesian(Rb, A);
        genLines = ['M', 0, 0, 'l', gPt.x, gPt.y, Rb*A*Math.cos(compA), -Rb*A*Math.sin(compA)];
        g.drawPath(genLines, {x:-Rb, y:0});
        // draw little right angle sign
        genLines = ['M', 0.95*gPt.x, 0.95*gPt.y, 'l', 0.05*Rb*Math.cos(compA), -0.05*Rb*Math.sin(compA),
                    0.05*Rb*Math.cos(A), 0.05*Rb*Math.sin(A)];
        g.drawPath(genLines, {x:-Rb, y:0});
        // draw draggable end point
        g.render(c1, {x:cx1, y:cy1});
        if (this.showConst)
        {
          genLines = ['M', 0, 0, 'L', gPt.x, gPt.y, gPt.x, 0, "Z", "M", gPt.x, gPt.y,
                      "l", Rb*A*Math.cos(compA), -Rb*A*Math.sin(compA), -Rb*A*Math.cos(compA), 0, "Z"];
          g.drawPath(genLines, {x:-Rb, y:0});
          // label if they fit
          g.drawText("R", {x:gPt.x/2-Rb-1.8, y:gPt.y/2+1.5, lorg:9});
          g.drawText("b", {x:gPt.x/2-Rb-1, y:gPt.y/2+1, fontSize:10, lorg:9});
          if (A&gt;0.3)
          {
            g.drawArrowArc(7.5, 0, 180*A/Math.PI, {
              x:-Rb, y:0,
              fillColor:"#aaaaaa",
              clockWise:false,
              shaftWidth:1,
              headSize:7});
            g.drawText("\u03B8", {x:gPt.x/4-Rb, y:gPt.y/8, lorg:4});
            g.drawText("x'", {x:2*gPt.x/3-Rb, y:2, lorg:5});
            g.drawText("y'", {x:gPt.x-Rb-1, y:gPt.y/3, lorg:3});
            g.drawText("\u03B8", {x:gPt.x-Rb+Rb*A*Math.sin(A)/20, y:gPt.y-4, lorg:1});
            g.drawText("x", {x:gPt.x-Rb+Rb*A*Math.sin(A)/2, y:gPt.y-Rb*A*Math.cos(A)+1, lorg:9});
            g.drawText("y", {x:gPt.x-Rb+1, y:2*gPt.y/3, lorg:1});
            g.drawText("c", {x:gPt.x-Rb+Rb*A*Math.sin(A)/2+1, y:gPt.y-Rb*A*Math.cos(A)/2+1, lorg:7});
            g.drawText("c'", {x:-Rb+Rb*Math.cos(A/2)-1, y:Rb*Math.sin(A/2)-1, lorg:6});
          }
        }
      };

      this.drawInv();
    }

    function InvoluteDefined2(cvsID, module, teeth, pressureAngle)
    {
      'use strict';
      var m, Z, phi,
          Rpitch, Rb, addendum, Ra,
          toothData, toothObj,
          pitchToBaseAngle,
          gear, i, newTooth,
          invData, pt, theta,
          invMax, invMin,
          xspan, yspan,
          A, cx1, cy1,
          compA, gPt,
          genLines, ph,
          g, xmin, xmax, ymin, ymax;

      function toCartesian(radius, angle)
      {
        return {x: radius*Math.cos(angle), y: radius*Math.sin(angle)};
      }

      function genInvolute2(Rb, theta)
      {
        // given the parameter theta, return the x, y of the involute
        var ix = Rb*(Math.cos(theta) + theta*Math.sin(theta)),
            iy = Rb*(Math.sin(theta) - theta*Math.cos(theta));

        return {x:ix, y:iy};
      }

      xmin = -45;
      xmax = 20;
      ymin = -4;
      ymax = 40;
      g = new Cango(cvsID);     // g is the graphics context for the background
      g.setGridboxRHC();          // full canvas
      g.setWorldCoords(xmin, ymin, xmax-xmin);  // square pixels
      g.setPropertyDefault("fillColor", 'black');
      g.setPropertyDefault("fontSize", 12);
      // =============== DIN GEAR DESIGN ===================
      m = module;                // Module = teeth per inch of diamter
      Z = teeth;
      phi = pressureAngle || 20; // pressure angle in degs
      Rpitch = Z*m/2;                // pitch radius
      Rb = Rpitch*Math.cos(phi*Math.PI/180);  // base radius
      addendum = m;             // distance from pitch circle to outer circle
      Ra = Rpitch + addendum;       // addendum (outer) radius
      // generate gear tooth outline path
      toothData = createGearTooth(m, Z, phi);
      toothObj = new Path(toothData, {strokeColor:'red'});
      toothObj.rotate(-270/Z);
      // rotate the tooth to put start of involute on the x axis
      pitchToBaseAngle = (Math.sqrt(Rpitch*Rpitch - Rb*Rb)/Rb) - Math.acos(Rb/Rpitch);
      toothObj.rotate(180*pitchToBaseAngle/Math.PI);
      // make 5 teeth by duplicating
      gear = [];
      gear.push(toothObj);
      for (i=0, newTooth; i&lt;3; i++)
      {
        newTooth = toothObj.dup();
        newTooth.rotate(360*i/Z);
        gear.push(newTooth);
      }
      // now draw the extended involute
      invData = [];
      pt = {};
      for (theta=0; theta&lt;1; theta+= 0.05)   // step along involute by inc parameter
      {
        pt = genInvolute2(Rb, theta);
        invData.push(pt.x, pt.y);
      }
      invMax = genInvolute2(Rb, 1);
      invData.push(invMax.x, invMax.y);   // plot the last point (theta = 1 radian)
      invMin = {x:Rb, y: 0} ;
      xspan = invMax.x-invMin.x;      // use these when dragging dot
      yspan = invMax.y-invMin.y;
      A = 0.8;                    // initial involute generating angle 0.8 rads
      cx1 = 59.7-Rb;
      cy1 = 7.5;  // eqiv x,y on involute for 0.8 theta

      g.clearCanvas();
      g.drawAxes(xmin, xmax, ymin, ymax, {
        xOrigin:-Rb, yOrigin:0,
        yTickInterval:50,
        strokeColor:"#888888",
        fillColor:"#888888"});  // don't show y ticks
      g.render(gear, {x:-Rb, y:0});
      g.drawPath(shapeDefs.circle(Rb*2), {x:-Rb, y:0, strokeColor:'rgba(0,0,255,0.3)'});
      g.drawPath(invData, {x:-Rb, y:0, strokeColor:'magenta'});
      // draw generating right angle
      compA = Math.PI/2 - A;
      gPt = toCartesian(Rb, A);
      genLines = ['M', 0, 0, 'l', gPt.x, gPt.y, Rb*A*Math.cos(compA), -Rb*A*Math.sin(compA), 'z'];
      g.drawPath(genLines, {x:-Rb, y:0});

      g.drawArrowArc(9, 0, 180*A/Math.PI, {
        x:-Rb, y:0,
        fillColor:"#aaaaaa",
        clockwise:false,
        shaftWidth:1,
        headSize:7});
      ph = 0.13;
      g.drawArrowArc(20, 0, 180*ph/Math.PI, {
        x:-Rb, y:0,
        fillColor:"#aaaaaa",
        clockWise:false,
        shaftWidth:1,  
        headSize:7});
      // draw little right angle sign
      genLines = ['M', 0.95*gPt.x, 0.95*gPt.y, 'l', 0.05*Rb*Math.cos(compA), -0.05*Rb*Math.sin(compA),
                  0.05*Rb*Math.cos(A), 0.05*Rb*Math.sin(A)];
      g.drawPath(genLines, {x:-Rb, y:0});
      // label if they fit
      g.drawText("R", {x:gPt.x/2-Rb-1.8, y:gPt.y/2+1.5, lorg:9});
      g.drawText("b", {x:gPt.x/2-Rb-1, y:gPt.y/2+1, fontSize:10, lorg:9});
      g.drawText("R", {x:gPt.x-Rb, y:gPt.y/6, lorg:9});
      g.drawText("\u03B8", {x:3*gPt.x/8-Rb, y:gPt.y/8, lorg:4});
      g.drawText("\u03C8", {x:7*gPt.x/8-Rb, y:1.5, lorg:5});
      g.drawText("c", {x:gPt.x-Rb+Rb*A*Math.sin(A)/2+1, y:gPt.y-Rb*A*Math.cos(A)/2+1, lorg:7});
      g.drawText("c'", {x:-Rb+Rb*Math.cos(A/2)-1, y:Rb*Math.sin(A/2)-1, lorg:6});
    }

    function InvoluteProfile(g, module, teeth, pressureAngle)
    {
      'use strict';
      var m, Z, phi, Rpitch, Rb, addendum, Ra, ta, order,
          fs, fm, fe,
          dedBez, addBez, bez,
          xmin, xmax, ymin, ymax;

      function genInvolute2(Rb, theta)
      {
        // given the parameter theta, return the x, y of the involute
        var ix = Rb*(Math.cos(theta) + theta*Math.sin(theta)),
            iy = Rb*(Math.sin(theta) - theta*Math.cos(theta));

        return {x:ix, y:iy};
      }

      xmin = -3;
      xmax = 3;
      ymin = -0.5;
      ymax = 5.5;

      g.setGridboxRHC();
      g.setWorldCoords(xmin, ymin, xmax-xmin);  // square pixels

      // =============== Demo Gear ===================
      m = module;                         // Module = pitch diameter (mm)/teeth
      Z = teeth;
      phi = pressureAngle || 20;          // pressure angle in degs
      Rpitch = Z*m/2;                     // pitch radius
      Rb = Rpitch*Math.cos(phi*Math.PI/180);  // base radius
      addendum = m;                       // pitch circle to outer circle
      Ra = Rpitch + addendum;             // addendum (outer) radius
      ta = Math.sqrt(Ra*Ra-Rb*Rb)/Rb;     // involute angle at addendum
      order = 4;

      this.drawCubicBezInvolute = function()
      {
        var data, p, theta, row, sa, s, err, pt;

        // generate 2 Cubic Bezier approximation
        fs = 0.01;  // start 1% off the base circle
        fm = 0.25;  // break 25% along involute
        fe = 1;     // end at 100%
        dedBez = involuteBezCoeffs(m, Z, phi, 3, fs, fm);
        addBez = involuteBezCoeffs(m, Z, phi, 3, fm, fe);

        g.clearCanvas();
        g.drawAxes(-5, 5, -5, 5, {
          xOrigin:0,
          yOrigin:0,
          xUnits:"mm",
          yUnits:"mm",
          xLabel:"X",
          yLabels:"Y" });
        g.drawPath(shapeDefs.circle(Rpitch*2), {x:-Rpitch, y:0, strokeColor:'orange'});
        g.drawPath(shapeDefs.circle(Rb*2), {x:-Rpitch, y:0, strokeColor:'red'});
        g.drawPath(shapeDefs.circle(Ra*2), {x:-Rpitch, y:0, strokeColor:'green'});

        // draw the approximation
        data = ["M", dedBez[0].x, dedBez[0].y,
                    "C", dedBez[1].x, dedBez[1].y, dedBez[2].x, dedBez[2].y, dedBez[3].x, dedBez[3].y,
                    "C", addBez[1].x, addBez[1].y, addBez[2].x, addBez[2].y, addBez[3].x, addBez[3].y];
        g.drawPath(data, {x:-Rpitch, y:0, strokeColor:'blue'});
        // plot the Bezier nodes as exes
        for (p=0; p&lt;dedBez.length; p++)    // skip duplicate at start
        {
          g.drawPath(shapeDefs.ex(0.2), {x:dedBez[p].x-Rpitch, y:dedBez[p].y, strokeColor:'blue'});
        }
        // plot the Bezier nodes
        for (p=0; p&lt;addBez.length; p++)    // skip duplicate at start
        {
          g.drawPath(shapeDefs.cross(0.2), {x:addBez[p].x-Rpitch, y:addBez[p].y, strokeColor:'green'});
        }
        // calculate the errors
        sa = (Ra*Ra - Rb*Rb)/(2*Rb);
        for (theta=0.08, row=0; theta&lt;ta; theta+= 0.08, row++)   // step along involute
        {
          pt = genInvolute2(Rb, theta);
          // calculate the errors
          s = Rb*theta*theta/2;
          if ((s/sa) &lt; 0.25)
          {
            err = distanceFromCurve(pt, dedBez);
          }
          else
          {
            err = distanceFromCurve(pt, addBez);
          }
          // write the error in table
          updateErrors(2, row, sprintf("%4.2f", s/sa), sprintf("%7.5f", err.distance), sprintf("%.1E", err.distance/(Z*m)));
        }
      };

      this.drawRealInvolute = function()
      {
        var theta, pt,
          data = [];

        // now draw the real involute
        for (theta=0; theta&lt;ta; theta+= 0.01)   // step along involute
        {
          pt = genInvolute2(Rb, theta);
          data.push(pt.x, pt.y);
        }
        pt = genInvolute2(Rb, ta);     // add the end point
        data.push(pt.x, pt.y);
        g.drawPath(data, {x:-Rpitch, y:0, strokeColor:'magenta'});
      };

      this.drawCubicBezInvolute();
      this.drawRealInvolute();
    }

    function InvoluteOrderN(g, module, teeth, pressureAngle, bezOrder)
    {
      'use strict';
      var m, Z, phi, Rpitch, Rb, addendum, Ra, order,
          fs, fe,
          ta, ts,
          bez,
          xmin, xmax, ymin, ymax;

      function genInvolute2(Rb, theta)
      {
        // given the parameter theta, return the x, y of the involute
        var ix = Rb*(Math.cos(theta) + theta*Math.sin(theta)),
            iy = Rb*(Math.sin(theta) - theta*Math.cos(theta));

        return {x:ix, y:iy};
      }

     /* Computes deCasteljau p(t) for n-control points
      * @param cp - list of control points [][x,y]
      * @param r - amount points (init value : points.length-1)
      * @param i - start value (init value : 0)
      * @param t - portion on the graph (range between 0.0 and 1.0)
      * @return point{x:,y:} - point on graph at p(t)
      *
      * @see http://stackoverflow.com/a/6271870 for n-control points
      */
      function getBezierPoint(cp, r, i, t)
      {
        var p1, p2;

        if (r == 0)
        {
          return cp[i];
        }
        p1 = getBezierPoint(cp, r - 1, i, t);
        p2 = getBezierPoint(cp, r - 1, i + 1, t);

        return {x:(1 - t) * p1.x + t * p2.x, y:(1 - t) * p1.y + t * p2.y};
      }

      xmin = -3;
      xmax = 3;
      ymin = -0.5;
      ymax = 5.5;

      g.setGridboxRHC();          // full canvas
      g.setWorldCoords(xmin, ymin, xmax-xmin);  // square pixels

      // =============== this Demo Gear has Rroot &lt; Rbase ===================
      m = module;                         // Module = pitch diameter (mm)/teeth
      Z = teeth;
      phi = pressureAngle || 20;          // pressure angle in degs
      Rpitch = Z*m/2;                     // pitch radius
      Rb = Rpitch*Math.cos(phi*Math.PI/180);  // base radius
      addendum = m;                       // pitch circle to outer circle
      Ra = Rpitch + addendum;             // addendum (outer) radius
      order = bezOrder || 4;
      fs = 0.01;                          // start offset as fraction of length
      fe = 1;                             // fraction of length at end of approx
      ta = Math.sqrt(Ra*Ra-Rb*Rb)/Rb;     // involute angle at addendum, end of approx
      ts = Math.sqrt(fs)*ta;              // involute angle, theta, at start of approx
      // generate Bezier approximation
      bez = involuteBezCoeffs(m, Z, phi, order, fs, fe);

      this.drawBezInvolute = function()
      {
        var data = [],
            t, p, pt, theta, row,
            sa, s, err;

        g.clearCanvas();
        g.drawAxes(-5, 5, -5, 5, {
          xOrigin:0,
          yOrigin:0,
          xUnits:"mm",
          yUnits:"mm",
          xLabel:"X",
          yLabels:"Y"});
        g.drawPath(shapeDefs.circle(Rpitch*2), {x:-Rpitch, y:0, strokeColor:'orange'});
        g.drawPath(shapeDefs.circle(Rb*2), {x:-Rpitch, y:0, strokeColor:'red'});
        g.drawPath(shapeDefs.circle(Ra*2), {x:-Rpitch, y:0, strokeColor:'green'});

        // draw approximation Bezier
        for (theta=ts; theta&lt;ta; theta+= 0.05) // fraction of theta_a
        {
          t =  (theta-ts)/(ta - ts);  // map t (0 &lt;= t &lt;= 1) from theta (ts &lt;= theta &lt;= ta)
          pt = getBezierPoint(bez, order, 0, t);
          data.push(pt.x, pt.y);
        }
        // add the end point
        data.push(bez[bez.length-1].x, bez[bez.length-1].y);
        g.drawPath(data, {x:-Rpitch, y:0, strokeColor:'green'});
        // plot the Bezier nodes
        for (p=0; p&lt;bez.length; p++)
        {
          g.drawPath(shapeDefs.ex(0.2), {x:bez[p].x-Rpitch, y:bez[p].y, strokeColor:'green'});
        }

        // calculate the errors (need a higher order version of Simon Porritt's jsBezier code)
        if (order==3)
        {
          sa = (Ra*Ra - Rb*Rb)/(2*Rb);
          for (theta=0.08, row=0; theta&lt;ta; theta+= 0.08, row++)   // step along involute
          {
            pt = genInvolute2(Rb, theta);
            // calculate the errors
            s = Rb*theta*theta/2;
            err = distanceFromCurve(pt, bez);
            // write the error in table
            updateErrors(1, row, sprintf("%4.2f", s/sa),
                                 sprintf("%6.4f", err.distance),
                                 sprintf("%.1E", err.distance/(Z*m)));
          }
        }
      };

      this.drawRealInvolute = function()
      {
        var theta, pt,
            data = [];

        // now draw the real involute
        for (theta=0; theta&lt;ta; theta+= 0.01)   // step along involute by inc parameter
        {
          pt = genInvolute2(Rb, theta);
          data.push(pt.x, pt.y);
        }
        pt = genInvolute2(Rb, ta);     // add the end point
        data.push(pt.x, pt.y);
        g.drawPath(data, {x:-Rpitch, y:0, strokeColor:'magenta'});
      };

      this.drawBezInvolute();
      this.drawRealInvolute();
    }

    function initGear(opts)
    {
      // create the required contents of next state vector (the default for others are OK)
      this.nextState.x = opts.cx;
      this.nextState.y = opts.cy;
    }

    function GearAnimation(g, module, gearTeeth, pinionTeeth, pressureAngle)
    {
      'use strict';
      // =============== DIN GEAR DESIGN ===================
      var m = module,               // Module = mm of pitch diameter per tooth
          Zp = pinionTeeth,
          Zg = gearTeeth,
          gr = Zg/Zp,               // gear ratio
          phi = pressureAngle || 20,
          Rg = Zg*m/2,              // gear Pitch Radius
          Rp = Zp*m/2,              // pinion Pitch Radius
          bklsh = 0.04*m,           // backlash (mm)
          dC = bklsh/(2*Math.tan(Math.PI*phi/180)), // centre shift to make backlash
          data, newTooth,
          Dsg, gearTooth, gear,
          Dsp, pinionTooth, pinion,
          shaft,
          org, cx, cy,
          xmin = -50,
          ymin = -30,
          xspan = 100,
          i,
          gearConfig, pinionConfig,
          twnr;

      g.setGridboxRHC();
      g.setWorldCoords(xmin, ymin, xspan);

      // generate gear
      data = createGearTooth(m, Zg, phi);
      gearTooth = new Shape(data, {
        fillColor:"#ddd0dd",
        border: true,
        strokeColor: "#606060" });
      gearTooth.rotate(180/Zg);     // rotate gear 1/2 tooth to mesh
      gear = gearTooth.dup();
      for (i=1; i&lt;Zg; i++)
      {
        newTooth = gearTooth.dup();
        newTooth.rotate(360*i/Zg);
        gear.appendPath(newTooth, true);  // trim move command = true
      }
      // add axle hole
      Dsg = 0.6*Rg;             // diameter of gear shaft
      shaft = new Path(shapeDefs.circle(Dsg));
      shaft.revWinding();
      gear.appendPath(shaft);       // retain the 'moveTo' command for shaft sub path

      // generate pinion
      data = createGearTooth(m, Zp, phi);
      pinionTooth = new Shape(data, {
        fillColor:"#d0d0e8",
        border: true,
        strokeColor: "#606060" });
      pinionTooth.rotate(-(180/Math.PI)*0.5*bklsh/Rp);  // rotate gear to take up backlash
      pinion = pinionTooth.dup();
      for (i=1; i&lt;Zp; i++)
      {
        newTooth = pinionTooth.dup();
        newTooth.rotate(360*i/Zp);
        pinion.appendPath(newTooth, true);  // trim 'moveto' command = true
      }
      // add axle hole
      Dsp = 0.6*Rp;             // diameter of pinion shaft
      shaft = new Path(shapeDefs.circle(Dsp));
      shaft.revWinding();
      pinion.appendPath(shaft);     // retain the 'moveTo' command for shaft sub path

      // setup the animation
      gearConfig = {cx:-Rg, cy:0, degs:[0, 360]};
      pinionConfig = {cx:Rp+dC, cy:0, degs:[0, -gr*360]};  // gr*0.666 rpm
			twnr = new Tweener(0, 90000, "loop");               // 0.666 rpm

      function initGear(opts)
      {
        // create the required contents of next state vector (the default for others are OK)
        this.nextState.x = opts.cx;
        this.nextState.y = opts.cy;
      }

      function gearPath(time, opts)
      {
        var rotVal = twnr.getVal(time, opts.degs);
        // create the required contents of next state vector (the default for others are OK)
        this.nextState.degs = rotVal;
      }

      g.animate(gear, initGear, null, gearPath, gearConfig);
      g.animate(pinion, initGear, null, gearPath, pinionConfig);

      this.run = function()
      {
        g.playAnimation();
      };

      this.halt = function()
      {
        g.pauseAnimation();
      };

      g.playAnimation();
    }

    function IntGearAnimation(g, module, gearTeeth, pinionTeeth, pressureAngle)
    {
      'use strict';
      // ==================== DIN GEAR DESIGN ====================
      var m = module,           // Module = teeth per inch of diamter
          Zp = pinionTeeth,
          Zg = gearTeeth,
          gr = Zg/Zp,           // gear teeth
          phi = pressureAngle || 20,
          Rg = Zg*m/2,          // gear Pitch radius
          Rp = Zp*m/2,          // pinion Pitch radius
          Rrim = Rg+2.75*m,     // ring gear outer radius
          bklsh = 0.04*m,       // backlash
          dC = bklsh/(2*Math.tan(Math.PI*phi/180)), // centre shift to make backlash
          data, newTooth,
          gear, gearTooth, teeth,
          pinion, pinionTooth,
          Rshaft, shaft,
          org, cx, cy,
          xmin = -250,
          ymin = -125,
          xspan = 400,
          i,
          gearConfig, pinionConfig,
          twnr;

      g.setGridboxRHC();              // full canvas
      g.setWorldCoords(xmin, ymin, xspan);

      // create ring gear outer rim
      gear = new Shape(shapeDefs.circle(2*Rrim), {
        fillColor:"#ddddd0",
        border: true,
        strokeColor: "#606060" });
      gear.revWinding();   // reverse winding so hole center hole won't be filled
      // now generate ring gear teeth
      data = createIntGearTooth(m, Zg, phi);
      gearTooth = new Path(data);
      gearTooth.rotate(180/Zg);  // rotate gear 1/2 tooth to mesh
      teeth = gearTooth.dup();
      for (i=1, newTooth; i&lt;Zg; i++)
      {
        newTooth = gearTooth.dup();
        newTooth.rotate(360*i/Zg);
        teeth.appendPath(newTooth, true); // trim initial 'moveTo'
      }
      gear.appendPath(teeth);   // retain the moveTo to make sub-path
      // generate pinion
      data = createGearTooth(m, Zp, phi);
      pinionTooth = new Shape(data, {
        fillColor:"#d0dddd",
        border: true,
        strokeColor: "#606060" });
      pinionTooth.rotate((180/Math.PI)*0.5*bklsh/Rp);  // rotate gear close backlash
      pinion = pinionTooth.dup();
      for (i=1; i&lt;Zp; i++)
      {
        newTooth = pinionTooth.dup();
        newTooth.rotate(360*i/Zp);
        pinion.appendPath(newTooth, true);  // trim move command = true
      }
      // add axle shaft hole
      Rshaft = 0.3*Rp;      // shaft radius
      shaft = new Path(shapeDefs.circle(2*Rshaft));
      shaft.revWinding();       // reverse the winding so hole not filled
      pinion.appendPath(shaft); // retain the moveTo to make sub-path

      // setup the animation
      gearConfig = {cx:-Rg, cy:0, degs:[0, 360]};
      pinionConfig = {cx:-Rp-dC, cy:0, degs:[0, gr*360]};    // gr*1 rpm
			twnr = new Tweener(0, 60000, "loop");                 // 1 rpm

      function initGear(opts)
      {
        // create the required contents of next state vector (the default for others are OK)
        this.nextState.x = opts.cx;
        this.nextState.y = opts.cy;
      }

      function gearPath(time, opts)
      {
        var rotVal = twnr.getVal(time, opts.degs);
        // create the required contents of next state vector (the default for others are OK)
        this.nextState.degs = rotVal;
      }

      g.animate(gear, initGear, null, gearPath, gearConfig);
      g.animate(pinion, initGear, null, gearPath, pinionConfig);

      this.run = function()
      {
        g.playAnimation();
      };

      this.halt = function()
      {
        g.pauseAnimation();
      };

      g.playAnimation();
    }

//============================================================
    var invDiagram, involuteDemo1, involuteDemo2, gearDemo, intGearDemo;

    function init()
    {
      var g1, g2, g3, g4;

      invDiagram = new InvoluteDefined('cvs0', 5, 20, 20);
      InvoluteDefined2('cvsA', 10, 8, 20);

      g1 = new Cango('cvs1');
      involuteDemo1 = new InvoluteOrderN(g1, 3, 17, 25, 3);
      initZoomPan(g1.createLayer(), g1, function(){involuteDemo1.drawBezInvolute(); involuteDemo1.drawRealInvolute();});

      g2 = new Cango('cvs2');
      involuteDemo2 = new InvoluteProfile(g2, 3, 17, 25);
      initZoomPan(g2.createLayer(), g2, function(){involuteDemo2.drawCubicBezInvolute(); involuteDemo2.drawRealInvolute();});

      g3 = new Cango('cvs3');
      gearDemo = new GearAnimation(g3, 5, 52, 24);
      initZoomPan(g3.createLayer(), g3, function(){g3.redrawAnimation;});

      g4 = new Cango('cvs4');
      intGearDemo = new IntGearAnimation(g4, 5, 42, 22, 20);
      initZoomPan(g4.createLayer(), g4, function(){g4.redrawAnimation;});
    }

    function showConstruction()
    {
      invDiagram.showConst = !invDiagram.showConst;
      invDiagram.drawInv();
      return false;
    }

    var consoleBtns3 =
    {
      f1:function(){gearDemo.run()},
      f2:function(){gearDemo.halt()}
    };

    var consoleBtns4 =
    {
      f1:function(){intGearDemo.run()},
      f2:function(){intGearDemo.halt()}
    };
  &lt;/script&gt;</t>
<t tx="yen.20170503210042.1">/*=====================================================================
  Filename: CangoAnimation-5v00.js
  Rev 5
  By: A.R.Collins
  Description:  This file augments the core Cango object with
                animation methods
  License: Released into the public domain
  latest version at
  &lt;http://www/arc.id.au/&gt;

  Date    Description                                             |By
  --------------------------------------------------------------------
  11May14 First release                                            ARC
  21Jul14 Updated to Cango-5 _buf becomes this.cnvs.buf            ARC
  24Jul14 Enable synchronised timeline for all layers
          Released as Version 2                                    ARC
  14Nov15 Dropped non-functional references to duration=0
          Rename Timeline to CgoTimeline to avoid conflicts        ARC
  16Nov15 Allow any path function, not just interpolate            ARC
  17Nov15 Add standard interpolateKeyFrames path function          ARC
          Let Timeline handle saving draw time as currState.time   ARC
  20Nov15 Support calling clipPath in pathFn (requires Cango7v16)  ARC
  22Nov15 rename 'interpolateKeyFrmaes' to 'interpolate',
          use x,y,scl,rot not xKeyFrames etc.
          Call render(obj, nextState) immediatley after initFn
          Make currState clone of nextState after initFn called    ARC
  23Nov15 Add support for ketTimes in interpolate
          Added optional start offset from paused                  ARC
  24Nov15 Change mode to STOPPED after duration time (not pause)   ARC
  28Nov15 Add resetClip after render in Animation instantiation
          ctx.save before pathFn call and ctx.restore after render ARC
  01Dec15 Released as 3v00 (based on 3beta-19)                     ARC
  17Dec15 bugfix: resume from stop didn't set currState.time=0.
          deleteAnimation forces timeline to paused mode           ARC
  21Jan16 bugfix: resetClip called after buffer switch             ARC
  02Feb16 Add Tweener utility, drop interpolate
          Release as Version 4  (based on 4beta-01)                ARC
  13Feb16 Define animation keyTimes in percentage of duration      ARC
  12Mar17 Update to use Cango Ver 9
          Don't assume nextState properties except time            ARC
  25Mar17 Add drawFn to Animation parameters to match Timeline     ARC
  26Mar17 bugfix: restore ctx after render                         ARC
  30Mar17 Released as CangoAnimation-5v00                          ARC
 =====================================================================*/

var CgoTimeline, Tweener;

Cango = (function(CangoCore)  // Cango must be declared a global before this file is loaded
{
  "use strict";

  if (!Date.now)
  {
    Date.now = function now()
    {
      return new Date().getTime();
    };
  }

  var isArray = function(obj)
  {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  var isNumber = function(o)
  {
    return !isNaN(o) &amp;&amp; o !== null &amp;&amp; o !== "" &amp;&amp; o !== false;
  };

  Tweener = function(delay, duration, loopStr)    // a pre-defined pathFn
  {
		this.delay = delay || 0;
    this.dur = duration || 5000;
    this.reStartOfs = 0;
    this.loop = false;
    this.loopAll = false;

    var savThis = this,
        loopParm = "noloop";

    if (typeof loopStr === 'string')
    {
      loopParm = loopStr.toLowerCase();
    }
    if (loopParm === 'loop')
    {
      this.loop = true;
    }
    else if (loopParm === 'loopall')
    {
      this.loopAll = true;
    }

    this.getVal = function(time, vals, keyTimes)  // vals is an array of key frame values (or a static number)
    {
      var numSlabs, slabDur, slab, frac, i,
					t = 0,
					tFrac,
					localTime,
					values, times;

      if (time === 0)       // re-starting after a stop, otherwise this can increase forever (looping is handled here)
      {
        savThis.reStartOfs = 0;     // reset this to prevent negative times
      }
      localTime = time - savThis.reStartOfs;       // handles local looping
      if ((localTime &gt; savThis.dur+savThis.delay) &amp;&amp; (savThis.dur &gt; 0) &amp;&amp; (savThis.loop || savThis.loopAll))
      {
        savThis.reStartOfs = savThis.loop? time - savThis.delay : time;      // we will correct external time to re-start
        localTime = 0;          // force re-start at frame 0 now too
      }
      t = 0;    // t is the actual local time value used for interpolating
      if (localTime &gt; savThis.delay)    // repeat initial frame (t=0) if there is a delay to start
      {
        t = localTime - savThis.delay;   // localTime is contrained to 0 &lt; localTime &lt; this.dur
      }

      if (!isArray(vals))    // not an array, just a static value, return it every time
      {
        return vals;
      }
      if (!vals.length)
      {
        return 0;
      }
      if (vals.length === 1)
      {
        return vals[0];
      }
      // we have at least 2 element array of values
      if (t === 0)
      {
        return vals[0];
      }
      if (t &gt;= savThis.dur)
      {
        return vals[vals.length-1];  // freeze at end value
      }
      numSlabs = vals.length-1;
      if (!isArray(keyTimes) || (vals.length !== keyTimes.length))
      {
        slabDur = savThis.dur/numSlabs;
        slab = Math.floor(t/slabDur);
        frac = (t - slab*slabDur)/slabDur;

        return vals[slab] + frac*(vals[slab+1] - vals[slab]);
      }

      // we have keyTimes to play work with copies of arrays
      values = [].concat(vals);
      times = [].concat(keyTimes);
      // make sure times start with 0
      if (times[0] !== 0)
      {
        values.unshift(values[0]);
        times.unshift(0);
      }
      // make sure times end with 100
      if (times[times.length-1] !== 100)
      {
        values.push(values[values.length-1]);
        times.push(100);
      }
      i = 0;
      tFrac = t/savThis.dur;
      while ((i &lt; times.length-1) &amp;&amp; (times[i+1]/100 &lt; tFrac))
      {
        i++;
      }
      slabDur = (times[i+1]-times[i])/100;
      frac = (tFrac - times[i]/100)/slabDur;    // convert percentage time to fraction

      return values[i] + frac*(values[i+1] - values[i]);
    };
  };

  function Animation(id, gc, obj, initFn, drawFn, pathFn, options)
  {
    var prop;

    this.id = id;
    this.gc = gc;        // the Cango context to do the drawing
    this.obj = obj;
    this.drawFn = drawFn;
    this.pathFn = pathFn;    // root object (Obj2D or Group2D) of scene to be draw
    this.options = options;
    this.currState = {time:0};
    this.nextState = {time:0};
    this.gc.ctx.save();
    if (typeof initFn === "function")
    {
      initFn.call(this, options);  // call object creation code
    }
    // draw the object as setup by initFn (pathFn not called yet)
    if (typeof this.drawFn === "function")
    {
      this.drawFn.call(this, this.obj, this.nextState, options);   // call user custom function
    }
    else
    {
      this.gc.render(this.obj, this.nextState);     // call default draw function
    }
    this.gc.resetClip();    // if init calls clipPath, it must be reset so next frame doesn't combine clip areas
    this.gc.ctx.restore();  // if initFn makes changes to ctx restore to pre-initFn state
    // now it has been drawn save the currState values (nextState values are generated by pathFn)
    for (prop in this.nextState)   // if initFn creates new properties, make currState match
    {
      if (this.nextState.hasOwnProperty(prop))
      {
        this.currState[prop] = this.nextState[prop];
      }
    }
  }

  // this is the actual animator that draws the frame
  function drawFrame(timeline)
  {
    var temp, i, at,
        prevAt = null,
        localTime,
        time = Date.now();    // use this as a time stamp, browser don't all pass the same time code

    if (timeline.prevAnimMode === timeline.modes.STOPPED)
    {
      timeline.startTime = time - timeline.startOfs;    // forces localTime = 0, start from beginning
    }
    localTime =  time - timeline.startTime;

    // step through all the animation tasks
    for (i=0; i&lt;timeline.animTasks.length; i++)
    {
      at = timeline.animTasks[i];
      if (at.gc.cId !== prevAt)
      {
        // check for new layer, only clear a layer once, there maybe several Cango contexts on each canvas
        at.gc.clearCanvas();
        prevAt = at.gc.cId;
      }
      at.gc.ctx.save();
      // if re-starting after a stopAnimation reset the currState.time so pathFn doesn't get negative time between frames
      if (timeline.prevAnimMode === timeline.modes.STOPPED)
      {
        at.currState.time = 0;    // avoid -ve dT (=localTime-currState.time) in pathFn
      }
      if (typeof(at.pathFn) === 'function')  // static objects may have null or undefined
      {
        at.pathFn.call(at, localTime, at.options);
      }
      if (typeof at.drawFn === "function")
      {
        at.drawFn.call(at, at.obj, at.nextState, at.options);  // call user custom function
      }
      else
      {
        at.gc.render(at.obj, at.nextState);     // default draw function
      }
      at.gc.ctx.restore(); // if pathFn changes any ctx properties restore to pre pathFn state
      // now swap the currState and nextState vectors (pathFn may use currState to gen nextState)
      temp = at.currState;
      at.currState = at.nextState; // save current state vector, pathFn will use it
      at.nextState = temp;
      // save the draw time for pathFn
      at.currState.time = localTime;
    }
    timeline.currTime = localTime;      // timestamp of what is currently on screen
  }

  CgoTimeline = function()
  {
    this.animTasks = [];    // each layer can push an Animation object in here
    this.timer = null;                // need to save the rAF id for cancelling
    this.modes = {PAUSED:1, STOPPED:2, PLAYING:3, STEPPING:4};     // animation modes
    this.animMode = this.modes.STOPPED;
    this.prevAnimMode = this.modes.STOPPED;
    this.startTime = 0;               // Date.now when localTime was 0 used to generate localTime
    this.startOfs = 0;                // used if play calls with non-zero start time
    this.currTime = 0;                // time along timeline (starting at 0) of frame on screen
    this.stepTime = 50;               // animation step time interval (in msec)
  };

  CgoTimeline.prototype.stopAnimation = function()
  {
    window.cancelAnimationFrame(this.timer);
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.STOPPED;
    // reset the currTime so play and step know to start again
    this.currTime = 0;
    this.startOfs = 0;
  };

  CgoTimeline.prototype.pauseAnimation = function()
  {
    window.cancelAnimationFrame(this.timer);
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.PAUSED;
  };

  CgoTimeline.prototype.stepAnimation = function()
  {
    var savThis = this;

    // this is the actual animator that draws the frame
    function drawIt()
    {
      drawFrame(savThis);
      savThis.prevAnimMode = savThis.modes.PAUSED;
      savThis.animMode = savThis.modes.PAUSED;
    }

    // eqivalent to play for one frame and pause
    if (this.animMode === this.modes.PLAYING)
    {
      return;
    }
    if (this.animMode === this.modes.PAUSED)
    {
      this.startTime = Date.now() - this.currTime;  // move time as if currFrame just drawn
    }
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.STEPPING;

    setTimeout(drawIt, this.stepTime);
  };

  CgoTimeline.prototype.redrawAnimation = function()
  {
    // eqivalent to play for one frame and pause
    if (this.animMode === this.modes.PLAYING)
    {
      return;
    }
    this.startTime = Date.now() - this.currTime;  // move time as if currFrame just drawn

    drawFrame(this);
  };

  CgoTimeline.prototype.playAnimation = function(startOfs, stopOfs)
  {
    var savThis = this;

    function drawIt()
    {
      drawFrame(savThis);
      savThis.prevAnimMode = savThis.modes.PLAYING;
      if (stopOfs)
      {
        if (savThis.currTime &lt; stopOfs)
        {
          savThis.timer = window.requestAnimationFrame(drawIt);
        }
        else
        {
          savThis.stopAnimation();     // go back to start of time line
        }
      }
      else
      {
        savThis.timer = window.requestAnimationFrame(drawIt);   // go forever
      }
    }

    this.startOfs = startOfs || 0;
    if (this.animMode === this.modes.PLAYING)
    {
      return;
    }
    if (this.animMode === this.modes.PAUSED)
    {
      this.startTime = Date.now() - this.currTime;  // move time as if currFrame just drawn
    }
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.PLAYING;

    this.timer = window.requestAnimationFrame(drawIt);
  };

//===============================================================================

  CangoCore.prototype.animate = function(obj, init, draw, path, options)
  {
    var animObj,
        animId;

    animId = this.cId+"_"+this.getUnique();
    animObj = new Animation(animId, this, obj, init, draw, path, options);
    // push this into the Cango animations array
    this.stopAnimation();   // make sure we are not still running and old animation
    this.bkgCanvas.timeline.animTasks.push(animObj);

    return animObj.id;   // so the animation just created can be deleted if required
  };

  CangoCore.prototype.pauseAnimation = function()
  {
    this.bkgCanvas.timeline.pauseAnimation();
  };

  CangoCore.prototype.playAnimation = function(startTime, stopTime)
  {
    this.bkgCanvas.timeline.playAnimation(startTime, stopTime);
  };

  CangoCore.prototype.stepAnimation = function()
  {
    this.bkgCanvas.timeline.stepAnimation();
  };

  CangoCore.prototype.stopAnimation = function()
  {
    this.bkgCanvas.timeline.stopAnimation();
  };

  CangoCore.prototype.redrawAnimation = function()
  {
    this.bkgCanvas.timeline.redrawAnimation();
  };

  CangoCore.prototype.deleteAnimation = function(animId)
  {
    var idx = -1,
        i;

    this.pauseAnimation();   // pause all animations
    for (i=0; i&lt;this.bkgCanvas.timeline.animTasks.length; i++)
    {
      if (this.bkgCanvas.timeline.animTasks[i].id === animId)
      {
        idx = i;
        break;
      }
    }
    if (idx === -1)
    {
      // not found
      return;
    }
    this.bkgCanvas.timeline.animTasks.splice(idx,1);       // delete the animation object
  };

  CangoCore.prototype.deleteAllAnimations = function()
  {
    this.stopAnimation();
    this.bkgCanvas.timeline.animTasks = [];
  };

  return CangoCore;    // return the augmented Cango object, over-writing the existing

}(Cango));     // Take the existing Cango object and add animation methods
</t>
<t tx="yen.20170508001342.1"></t>
<t tx="yen.20170508001351.1"></t>
<t tx="yen.20170508001359.1">@others
@language python
@tabwidth -4
</t>
<t tx="yen.20170508010952.1">@others
@language python
@tabwidth -4
</t>
<t tx="yen.20170508011005.1">from math import pi, cos, sin, sqrt, acos
 
radian = 180/pi
degree = pi/180

#PLAP
</t>
<t tx="yen.20170508011005.10">@property
def ex(self):
    return pllp(self.cx, self.cy, self.ce, self.ed, self.dx, self.dy, pos=0)[0]

</t>
<t tx="yen.20170508011005.11">@property
def ey(self):
    return pllp(self.cx, self.cy, self.ce, self.ed, self.dx, self.dy, pos=0)[1]

</t>
<t tx="yen.20170508011005.2">def plap(ax, ay, ac, bac, bx, by, pos):
    if pos == 0:
        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    else:
        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    return cx, cy
    
#PLLP
</t>
<t tx="yen.20170508011005.3">def pllp(ax, ay, ac, cb, bx, by, pos):
    if pos == 0:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    else:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    return cx, cy
    
</t>
<t tx="yen.20170508011005.4">class fourbar(object):

    '''
    (ax, ay) motor coord
    (bx, by) rocker base coord
    bac motor angle
    ac link1 length
    cd link2 length
    db link3 length
    ce triangle side1
    ed triangle side2
    '''
    @others
'''    
# 利用 fourbar 物件建立案例
f = fourbar(ax = -60, ay = 0, bx = 0, by = 0, bac = 50*degree, ac = 30, cd = 50, db = 60, ce = 50, ed = 50)

# 利用 fourbar 物件案例的方法求各點座標
#f.cx, f.cy 為 C 點座標
#f.dx, f.dy 為 D 點座標
#f.ex, f.ey 為 E 點座標
'''
</t>
<t tx="yen.20170508011005.5">def __init__(self, ax, ay, bx, by, bac, ac, cd, db, ce, ed):

    self.ax = ax
    self.ay = ay
    self.bx = bx
    self.by = by
    self.bac = bac
    self.ac = ac
    self.cd = cd
    self.db = db
    self.ce = ce
    self.ed = ed
    
</t>
<t tx="yen.20170508011005.6">@property
def cx(self):
    return plap(self.ax, self.ay, self.ac, self.bac, self.bx, self.by, pos=0)[0]

</t>
<t tx="yen.20170508011005.7">@property
def cy(self):
    return plap(self.ax, self.ay, self.ac, self.bac, self.bx, self.by, pos=0)[1]

</t>
<t tx="yen.20170508011005.8">@property
def dx(self):
    return pllp(self.cx, self.cy, self.cd, self.db, self.bx, self.by, pos=0)[0]

</t>
<t tx="yen.20170508011005.9">@property
def dy(self):
    return pllp(self.cx, self.cy, self.cd, self.db, self.bx, self.by, pos=0)[1]
    
</t>
<t tx="yen.20170508011028.1">import math

</t>
<t tx="yen.20170508011028.10">class Point(object):
    # 起始方法
    @others
# Line 類別物件
</t>
<t tx="yen.20170508011028.11">def __init__(self, x, y):
    self.x = x
    self.y = y

# 繪製方法
</t>
<t tx="yen.20170508011028.12">def drawMe(self, g, r):
    self.g = g
    self.r = r
    self.g.save()
    self.g.moveTo(self.x,self.y)
    self.g.beginPath()
    # 根據 r 半徑繪製一個圓代表點的所在位置
    self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True)
    self.g.moveTo(self.x,self.y)
    self.g.lineTo(self.x+self.r, self.y)
    self.g.moveTo(self.x, self.y)
    self.g.lineTo(self.x-self.r, self.y)
    self.g.moveTo(self.x, self.y)
    self.g.lineTo(self.x, self.y+self.r)
    self.g.moveTo(self.x, self.y)
    self.g.lineTo(self.x, self.y-self.r)
    self.g.restore()
    self.g.stroke()

# 加入 Eq 方法
</t>
<t tx="yen.20170508011028.13">def Eq(self, pt):
    self.x = pt.x
    self.y = pt.y

# 加入 setPoint 方法
</t>
<t tx="yen.20170508011028.14">def setPoint(self, px, py):
    self.x = px
    self.y = py

# 加上 distance(pt) 方法, 計算點到 pt 的距離
</t>
<t tx="yen.20170508011028.15">def distance(self, pt):
    self.pt = pt
    x = self.x - self.pt.x
    y = self.y - self.pt.y
    return math.sqrt(x * x + y * y)

# 利用文字標示點的座標位置
</t>
<t tx="yen.20170508011028.16">def tag(self, g):
    self.g = g
    self.g.beginPath()
    self.g.fillText("%d, %d"%(self.x, self.y),self.x, self.y)
    self.g.stroke()


</t>
<t tx="yen.20170508011028.17">class Line(object):

    # 起始方法
    @others
</t>
<t tx="yen.20170508011028.18">def __init__(self, p1, p2):
    self.p1 = p1
    self.p2 = p2
    # 直線的第一點, 設為線尾
    self.Tail = self.p1
    # 直線組成的第二點, 設為線頭
    self.Head = self.p2
    # 直線的長度屬性
    self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

# setPP 以指定頭尾座標點來定義直線
</t>
<t tx="yen.20170508011028.19">def setPP(self, p1, p2):
    self.p1 = p1
    self.p2 = p2
    self.Tail = self.p1
    self.Head = self.p2
    self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

# setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
</t>
<t tx="yen.20170508011028.2">class Coord(object):
    @others
</t>
<t tx="yen.20170508011028.20">def setRT(self, r, t):
    self.r = r
    self.t = t
    x = self.r * math.cos(self.t)
    y = self.r * math.sin(self.t)
    self.Tail.Eq(self.p1)
    self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)

# getR 方法 for Line
</t>
<t tx="yen.20170508011028.21">def getR(self):
    # x 分量與 y 分量
    x = self.p1.x - self.p2.x
    y = self.p1.y - self.p2.y
    return math.sqrt(x * x + y * y)

# 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
</t>
<t tx="yen.20170508011028.22">def getT(self):
    x = self.p2.x - self.p1.x
    y = self.p2.y - self.p1.y
    if (math.fabs(x) &lt; math.pow(10,-100)):
        if(y &lt; 0.0):
            return (-math.pi/2)
        else:
            return (math.pi/2)
    else:
        return math.atan2(y, x)

# setTail 方法 for Line
</t>
<t tx="yen.20170508011028.23">def setTail(self, pt):
    self.pt = pt
    self.Tail.Eq(pt)
    self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)

# getHead 方法 for Line
</t>
<t tx="yen.20170508011028.24">def getHead(self):
    return self.Head

</t>
<t tx="yen.20170508011028.25">def getTail(self):
    return self.Tail

</t>
<t tx="yen.20170508011028.26">def drawMe(self, g):
    self.g = g
    self.g.beginPath()
    self.g.moveTo(self.p1.x,self.p1.y)
    self.g.lineTo(self.p2.x,self.p2.y)
    self.g.stroke()

</t>
<t tx="yen.20170508011028.27">def test(self):
    return ("this is pure test to Inherit")


</t>
<t tx="yen.20170508011028.28">class Link(Line):
    @others
</t>
<t tx="yen.20170508011028.29">def __init__(self, p1, p2):
    self.p1 = p1
    self.p2 = p2
    self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))

#g context
</t>
<t tx="yen.20170508011028.3">def __init__(self,x,y):
    self.x = x
    self.y = y

</t>
<t tx="yen.20170508011028.30">def drawMe(self, g):
    self.g = g
    hole = 5
    radius = 10
    length = self.getR()
    # alert(length)
    # 儲存先前的繪圖狀態
    self.g.save()
    self.g.translate(self.p1.x,self.p1.y)
    #alert(str(self.p1.x)+","+str(self.p1.y))
    #self.g.rotate(-((math.pi/2)-self.getT()))
    self.g.rotate(-math.pi*0.5 + self.getT())
    #alert(str(self.getT()))
    #self.g.rotate(10*math.pi/180)
    #this.g.rotate(-(Math.PI/2-this.getT()));
    # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
    self.g.beginPath()
    self.g.moveTo(0,0)
    self.g.arc(0, 0, hole, 0, 2*math.pi, True)
    self.g.stroke()
    self.g.moveTo(0,length)
    self.g.beginPath()
    self.g.arc(0,length, hole, 0, 2*math.pi, True)
    self.g.stroke()
    self.g.moveTo(0,0)
    self.g.beginPath()
    self.g.arc(0,0, radius, 0, math.pi, True)
    self.g.moveTo(0+radius,0)
    self.g.lineTo(0+radius,0+length)
    self.g.stroke()
    self.g.moveTo(0,0+length)
    self.g.beginPath()
    self.g.arc(0, 0+length, radius, math.pi, 0, True)
    self.g.moveTo(0-radius,0+length)
    self.g.lineTo(0-radius,0)
    self.g.stroke()
    self.g.restore()
    '''
    self.g.beginPath()
    self.g.fillStyle = "red"
    self.g.font = "bold 18px sans-serif"
    self.g.fillText("%d, %d"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y)
    self.g.stroke()
    '''


</t>
<t tx="yen.20170508011028.31">class Triangle(object):
    @others
</t>
<t tx="yen.20170508011028.32">def __init__(self, p1, p2, p3):
    self.p1 = p1
    self.p2 = p2
    self.p3 = p3

</t>
<t tx="yen.20170508011028.33">def getLenp3(self):
    p1 = self.p1
    ret = p1.distance(self.p2)
    return ret

</t>
<t tx="yen.20170508011028.34">def getLenp1(self):
    p2 = self.p2
    ret = p2.distance(self.p3)
    return ret

</t>
<t tx="yen.20170508011028.35">def getLenp2(self):
    p1 = self.p1
    ret = p1.distance(self.p3)
    return ret

# 角度
</t>
<t tx="yen.20170508011028.36">def getAp1(self):
    ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
    return ret

#
</t>
<t tx="yen.20170508011028.37">def getAp2(self):
    ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
    return ret

</t>
<t tx="yen.20170508011028.38">def getAp3(self):
    ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
    return ret

</t>
<t tx="yen.20170508011028.39">def drawMe(self, g):
    self.g = g
    r = 5
    # 繪出三個頂點
    self.p1.drawMe(self.g,r)
    self.p2.drawMe(self.g,r)
    self.p3.drawMe(self.g,r)
    line1 = Line(self.p1,self.p2)
    line2 = Line(self.p1,self.p3)
    line3 = Line(self.p2,self.p3)
    # 繪出三邊線
    line1.drawMe(self.g)
    line2.drawMe(self.g)
    line3.drawMe(self.g)

# ends Triangle def
# 透過三個邊長定義三角形
</t>
<t tx="yen.20170508011028.4">def __sub__(self,other):
    # This allows you to substract vectors
    return Coord(self.x-other.x,self.y-other.y)

</t>
<t tx="yen.20170508011028.40">def setSSS(self, lenp3, lenp1, lenp2):
    self.lenp3 = lenp3
    self.lenp1 = lenp1
    self.lenp2 = lenp2
    self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
    self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
    self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))

# 透過兩個邊長與夾角定義三角形
</t>
<t tx="yen.20170508011028.41">def setSAS(self, lenp3, ap2, lenp1):
    self.lenp3 = lenp3
    self.ap2 = ap2
    self.lenp1 = lenp1
    self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
    #等於 SSS(AB, BC, CA)

</t>
<t tx="yen.20170508011028.42">def setSaSS(self, lenp2, lenp3, lenp1):
    self.lenp2 = lenp2
    self.lenp3 = lenp3
    self.lenp1 = lenp1
    if(self.lenp1 &gt; (self.lenp2 + self.lenp3)):
    #&lt;CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
        ret = math.pi
    else :
        # &lt;CAB 夾角為 0, 三點共線且 A 不在 BC 之間
        if((self.lenp1 &lt; (self.lenp2 - self.lenp3)) or (self.lenp1 &lt; (self.lenp3 - self.lenp2))):
            ret = 0.0
        else :
        # 透過餘絃定理求出夾角 &lt;CAB 
            ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
    return ret

# 取得三角形的三個邊長值
</t>
<t tx="yen.20170508011028.43">def getSSS(self):
    temp = []
    temp.append( self.getLenp1() )
    temp.append( self.getLenp2() )
    temp.append( self.getLenp3() )
    return temp

# 取得三角形的三個角度值
</t>
<t tx="yen.20170508011028.44">def getAAA(self):
    temp = []
    temp.append( self.getAp1() )
    temp.append( self.getAp2() )
    temp.append( self.getAp3() )
    return temp

# 取得三角形的三個角度與三個邊長
</t>
<t tx="yen.20170508011028.45">def getASASAS(self):
    temp = []
    temp.append(self.getAp1())
    temp.append(self.getLenp1())
    temp.append(self.getAp2())
    temp.append(self.getLenp2())
    temp.append(self.getAp3())
    temp.append(self.getLenp3())
    return temp
#2P 2L return mid P
</t>
<t tx="yen.20170508011028.46">def setPPSS(self, p1, p3, lenp1, lenp3):
    temp = []
    self.p1 = p1
    self.p3 = p3
    self.lenp1 = lenp1
    self.lenp3 = lenp3

    #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
    line31 = Line(p3, p1)
    self.lenp2 = line31.getR()
    #self.lenp2 = self.p3.distance(self.p1)
    #這裡是求角3
    ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
    #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))
    bp3 = line31.getT()
    cp3 = bp3 - ap3
    temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
    temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
    return temp
</t>
<t tx="yen.20170508011028.5">def __repr__(self):
    # Used to get human readable coordinates when printing
    return "Coord(%f,%f)"%(self.x,self.y)

</t>
<t tx="yen.20170508011028.6">def length(self):
    # Returns the length of the vector
    return math.sqrt(self.x**2 + self.y**2)

</t>
<t tx="yen.20170508011028.7">def angle(self):
    # Returns the vector's angle
    return math.atan2(self.y,self.x)

</t>
<t tx="yen.20170508011028.8">def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )

</t>
<t tx="yen.20170508011028.9">def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )

# 點類別
</t>
<t tx="yen.20170508020303.1">https://www.brython.info/gallery/draw.html</t>
</tnodes>
</leo_file>
